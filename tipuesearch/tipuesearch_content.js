var tipuesearch = {"pages":[{"text":"ROHSA ROHSA (Regularized Optimization for Hyper-Spectral Analysis) was developped in Paris-Saclay University\n(IAS/CEA) to study the statistical properties of interstellar gas through atomic and molecular lines. This code is a \"Gaussian Decomposition Algorithm\" designed to decompose any kind of hyper-spectral \nobservations into a sum of coherent Gaussian. It is written in Fortran 90 on CPU. An extended version \nwith GPU implementation is currently in development. Exemple of a three componant Gaussian decomposition with ROHSA. This work is part of the Hyperstars project supported by MASTODONS . Developer Info Antoine Marchal PhD Student in Astrophysics at IAS/CEA","tags":"home","loc":"index.html","title":" ROHSA "},{"text":"L-BFGS-B submodule Contents Functions dnrm2 ddot Subroutines daxpy dcopy dscal Source Code blas.f Source Code !! L-BFGS-B submodule c c  L-BFGS-B is released under the “New BSD License” (aka “Modified BSD License” c  or “3-clause license”) c  Please read attached file License.txt c double precision function dnrm2 ( n , x , incx ) integer n , incx double precision x ( n ) c     ********** c c     Function dnrm2 c !!     Given a vector x of length n, this function calculates the Euclidean norm of x with stride incx. c c     The function statement is c c       double precision function dnrm2(n,x,incx) c c     where c c       n is a positive integer input variable. c c       x is an input array of length n. c c       incx is a positive integer variable that specifies the c         stride of the vector. c c     Subprograms called c c       FORTRAN-supplied ... abs, max, sqrt c c     MINPACK-2 Project. February 1991. c     Argonne National Laboratory. c     Brett M. Averick. c c     ********** integer i double precision scale dnrm2 = 0.0d0 scale = 0.0d0 do 10 i = 1 , n , incx scale = max ( scale , abs ( x ( i ))) 10 continue if ( scale . eq . 0.0d0 ) return do 20 i = 1 , n , incx dnrm2 = dnrm2 + ( x ( i ) / scale ) ** 2 20 continue dnrm2 = scale * sqrt ( dnrm2 ) return end c====================== The end of dnrm2 =============================== subroutine daxpy ( n , da , dx , incx , dy , incy ) !! constant times a vector plus a vector. !! uses unrolled loops for increments equal to one. !!     jack dongarra, linpack, 3/11/78. c double precision dx ( * ), dy ( * ), da integer i , incx , incy , ix , iy , m , mp1 , n c if ( n . le . 0 ) return if ( da . eq . 0.0d0 ) return if ( incx . eq . 1. and . incy . eq . 1 ) go to 20 c c        code for unequal increments or equal increments c          not equal to 1 c ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do 10 i = 1 , n dy ( iy ) = dy ( iy ) + da * dx ( ix ) ix = ix + incx iy = iy + incy 10 continue return c c        code for both increments equal to 1 c c c        clean-up loop c 20 m = mod ( n , 4 ) if ( m . eq . 0 ) go to 40 do 30 i = 1 , m dy ( i ) = dy ( i ) + da * dx ( i ) 30 continue if ( n . lt . 4 ) return 40 mp1 = m + 1 do 50 i = mp1 , n , 4 dy ( i ) = dy ( i ) + da * dx ( i ) dy ( i + 1 ) = dy ( i + 1 ) + da * dx ( i + 1 ) dy ( i + 2 ) = dy ( i + 2 ) + da * dx ( i + 2 ) dy ( i + 3 ) = dy ( i + 3 ) + da * dx ( i + 3 ) 50 continue return end c====================== The end of daxpy =============================== subroutine dcopy ( n , dx , incx , dy , incy ) c c     copies a vector, x, to a vector, y. c     uses unrolled loops for increments equal to one. c     jack dongarra, linpack, 3/11/78. c double precision dx ( * ), dy ( * ) integer i , incx , incy , ix , iy , m , mp1 , n c if ( n . le . 0 ) return if ( incx . eq . 1. and . incy . eq . 1 ) go to 20 c c        code for unequal increments or equal increments c          not equal to 1 c ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do 10 i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy 10 continue return c c        code for both increments equal to 1 c c c        clean-up loop c 20 m = mod ( n , 7 ) if ( m . eq . 0 ) go to 40 do 30 i = 1 , m dy ( i ) = dx ( i ) 30 continue if ( n . lt . 7 ) return 40 mp1 = m + 1 do 50 i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) 50 continue return end c====================== The end of dcopy =============================== double precision function ddot ( n , dx , incx , dy , incy ) c c     forms the dot product of two vectors. c     uses unrolled loops for increments equal to one. c     jack dongarra, linpack, 3/11/78. c double precision dx ( * ), dy ( * ), dtemp integer i , incx , incy , ix , iy , m , mp1 , n c ddot = 0.0d0 dtemp = 0.0d0 if ( n . le . 0 ) return if ( incx . eq . 1. and . incy . eq . 1 ) go to 20 c c        code for unequal increments or equal increments c          not equal to 1 c ix = 1 iy = 1 if ( incx . lt . 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy . lt . 0 ) iy = ( - n + 1 ) * incy + 1 do 10 i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy 10 continue ddot = dtemp return c c        code for both increments equal to 1 c c c        clean-up loop c 20 m = mod ( n , 5 ) if ( m . eq . 0 ) go to 40 do 30 i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) 30 continue if ( n . lt . 5 ) go to 60 40 mp1 = m + 1 do 50 i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + * dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) 50 continue 60 ddot = dtemp return end c====================== The end of ddot ================================ subroutine dscal ( n , da , dx , incx ) c c     scales a vector by a constant. c     uses unrolled loops for increment equal to one. c     jack dongarra, linpack, 3/11/78. c     modified 3/93 to return if incx .le. 0. c double precision da , dx ( * ) integer i , incx , m , mp1 , n , nincx c if ( n . le . 0 . or . incx . le . 0 ) return if ( incx . eq . 1 ) go to 20 c c        code for increment not equal to 1 c nincx = n * incx do 10 i = 1 , nincx , incx dx ( i ) = da * dx ( i ) 10 continue return c c        code for increment equal to 1 c c c        clean-up loop c 20 m = mod ( n , 5 ) if ( m . eq . 0 ) go to 40 do 30 i = 1 , m dx ( i ) = da * dx ( i ) 30 continue if ( n . lt . 5 ) return 40 mp1 = m + 1 do 50 i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) 50 continue return end c====================== The end of dscal ===============================","tags":"","loc":"sourcefile/blas.f.html","title":"blas.f – ROHSA"},{"text":"L-BFGS-B module Contents Subroutines setulb mainlb active bmv cauchy cmprlb errclb formk formt freev hpsolb lnsrlb matupd prn1lb prn2lb prn3lb projgr subsm dcsrch dcstep Source Code lbfgsb.f Source Code !! L-BFGS-B module c c  L-BFGS-B is released under the “New BSD License” (aka “Modified BSD License” c  or “3-clause license”) c  Please read attached file License.txt c c===========   L-BFGS-B (version 3.0.  April 25, 2011  =================== c c     This is a modified version of L-BFGS-B. Minor changes in the updated c     code appear preceded by a line comment as follows c c     c-jlm-jn c c     Major changes are described in the accompanying paper: c c         Jorge Nocedal and Jose Luis Morales, Remark on \"Algorithm 778: c         L-BFGS-B: Fortran Subroutines for Large-Scale Bound Constrained c         Optimization\"  (2011). To appear in  ACM Transactions on c         Mathematical Software, c c     The paper describes an improvement and a correction to Algorithm 778. c     It is shown that the performance of the algorithm can be improved c     significantly by making a relatively simple modication to the subspace c     minimization phase. The correction concerns an error caused by the use c     of routine dpmeps to estimate machine precision. c c     The total work space **wa** required by the new version is c c                  2*m*n + 11m*m + 5*n + 8*m c c     the old version required c c                  2*m*n + 12m*m + 4*n + 12*m c c c            J. Nocedal  Department of Electrical Engineering and c                        Computer Science. c                        Northwestern University. Evanston, IL. USA c c c           J.L Morales  Departamento de Matematicas, c                        Instituto Tecnologico Autonomo de Mexico c                        Mexico D.F. Mexico. c c                        March  2011 c c============================================================================= subroutine setulb ( n , m , x , l , u , nbd , f , g , factr , pgtol , wa , iwa , + task , iprint , csave , lsave , isave , dsave ) character * 60 task , csave logical lsave ( 4 ) integer n , m , iprint , + nbd ( n ), iwa ( 3 * n ), isave ( 44 ) double precision f , factr , pgtol , x ( n ), l ( n ), u ( n ), g ( n ), c c-jlm-jn + wa ( 2 * m * n + 5 * n + 11 * m * m + 8 * m ), dsave ( 29 ) c     ************ c c     Subroutine setulb c c     This subroutine partitions the working arrays wa and iwa, and c       then uses the limited memory BFGS method to solve the bound c       constrained optimization problem by calling mainlb. c       (The direct method will be used in the subspace minimization.) c c     n is an integer variable. c       On entry n is the dimension of the problem. c       On exit n is unchanged. c c     m is an integer variable. c       On entry m is the maximum number of variable metric corrections c         used to define the limited memory matrix. c       On exit m is unchanged. c c     x is a double precision array of dimension n. c       On entry x is an approximation to the solution. c       On exit x is the current approximation. c c     l is a double precision array of dimension n. c       On entry l is the lower bound on x. c       On exit l is unchanged. c c     u is a double precision array of dimension n. c       On entry u is the upper bound on x. c       On exit u is unchanged. c c     nbd is an integer array of dimension n. c       On entry nbd represents the type of bounds imposed on the c         variables, and must be specified as follows: c         nbd(i)=0 if x(i) is unbounded, c                1 if x(i) has only a lower bound, c                2 if x(i) has both lower and upper bounds, and c                3 if x(i) has only an upper bound. c       On exit nbd is unchanged. c c     f is a double precision variable. c       On first entry f is unspecified. c       On final exit f is the value of the function at x. c c     g is a double precision array of dimension n. c       On first entry g is unspecified. c       On final exit g is the value of the gradient at x. c c     factr is a double precision variable. c       On entry factr >= 0 is specified by the user.  The iteration c         will stop when c c         (f&#94;k - f&#94;{k+1})/max{|f&#94;k|,|f&#94;{k+1}|,1} <= factr*epsmch c c         where epsmch is the machine precision, which is automatically c         generated by the code. Typical values for factr: 1.d+12 for c         low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely c         high accuracy. c       On exit factr is unchanged. c c     pgtol is a double precision variable. c       On entry pgtol >= 0 is specified by the user.  The iteration c         will stop when c c                 max{|proj g_i | i = 1, ..., n} <= pgtol c c         where pg_i is the ith component of the projected gradient. c       On exit pgtol is unchanged. c c     wa is a double precision working array of length c       (2mmax + 5)nmax + 12mmax&#94;2 + 12mmax. c c     iwa is an integer working array of length 3nmax. c c     task is a working string of characters of length 60 indicating c       the current job when entering and quitting this subroutine. c c     iprint is an integer variable that must be set by the user. c       It controls the frequency and type of output generated: c        iprint<0    no output is generated; c        iprint=0    print only one line at the last iteration; c        0<iprint<99 print also f and |proj g| every iprint iterations; c        iprint=99   print details of every iteration except n-vectors; c        iprint=100  print also the changes of active set and final x; c        iprint>100  print details of every iteration including x and g; c       When iprint > 0, the file iterate.dat will be created to c                        summarize the iteration. c c     csave is a working string of characters of length 60. c c     lsave is a logical working array of dimension 4. c       On exit with 'task' = NEW_X, the following information is c                                                             available: c         If lsave(1) = .true.  then  the initial X has been replaced by c                                     its projection in the feasible set; c         If lsave(2) = .true.  then  the problem is constrained; c         If lsave(3) = .true.  then  each variable has upper and lower c                                     bounds; c c     isave is an integer working array of dimension 44. c       On exit with 'task' = NEW_X, the following information is c                                                             available: c         isave(22) = the total number of intervals explored in the c                         search of Cauchy points; c         isave(26) = the total number of skipped BFGS updates before c                         the current iteration; c         isave(30) = the number of current iteration; c         isave(31) = the total number of BFGS updates prior the current c                         iteration; c         isave(33) = the number of intervals explored in the search of c                         Cauchy point in the current iteration; c         isave(34) = the total number of function and gradient c                         evaluations; c         isave(36) = the number of function value or gradient c                                  evaluations in the current iteration; c         if isave(37) = 0  then the subspace argmin is within the box; c         if isave(37) = 1  then the subspace argmin is beyond the box; c         isave(38) = the number of free variables in the current c                         iteration; c         isave(39) = the number of active constraints in the current c                         iteration; c         n + 1 - isave(40) = the number of variables leaving the set of c                           active constraints in the current iteration; c         isave(41) = the number of variables entering the set of active c                         constraints in the current iteration. c c     dsave is a double precision working array of dimension 29. c       On exit with 'task' = NEW_X, the following information is c                                                             available: c         dsave(1) = current 'theta' in the BFGS matrix; c         dsave(2) = f(x) in the previous iteration; c         dsave(3) = factr*epsmch; c         dsave(4) = 2-norm of the line search direction vector; c         dsave(5) = the machine precision epsmch generated by the code; c         dsave(7) = the accumulated time spent on searching for c                                                         Cauchy points; c         dsave(8) = the accumulated time spent on c                                                 subspace minimization; c         dsave(9) = the accumulated time spent on line search; c         dsave(11) = the slope of the line search function at c                                  the current point of line search; c         dsave(12) = the maximum relative step length imposed in c                                                           line search; c         dsave(13) = the infinity norm of the projected gradient; c         dsave(14) = the relative step length in the line search; c         dsave(15) = the slope of the line search function at c                                 the starting point of the line search; c         dsave(16) = the square of the 2-norm of the line search c                                                      direction vector. c c     Subprograms called: c c       L-BFGS-B Library ... mainlb. c c c     References: c c       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited c       memory algorithm for bound constrained optimization'', c       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. c c       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a c       limited memory FORTRAN code for solving bound constrained c       optimization problems'', Tech. Report, NAM-11, EECS Department, c       Northwestern University, 1994. c c       (Postscript files of these papers are available via anonymous c        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.) c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ c-jlm-jn integer lws , lr , lz , lt , ld , lxp , lwa , + lwy , lsy , lss , lwt , lwn , lsnd if ( task . eq . 'START' ) then isave ( 1 ) = m * n isave ( 2 ) = m ** 2 isave ( 3 ) = 4 * m ** 2 isave ( 4 ) = 1 ! ws      m*n isave ( 5 ) = isave ( 4 ) + isave ( 1 ) ! wy      m*n isave ( 6 ) = isave ( 5 ) + isave ( 1 ) ! wsy     m**2 isave ( 7 ) = isave ( 6 ) + isave ( 2 ) ! wss     m**2 isave ( 8 ) = isave ( 7 ) + isave ( 2 ) ! wt      m**2 isave ( 9 ) = isave ( 8 ) + isave ( 2 ) ! wn      4*m**2 isave ( 10 ) = isave ( 9 ) + isave ( 3 ) ! wsnd    4*m**2 isave ( 11 ) = isave ( 10 ) + isave ( 3 ) ! wz      n isave ( 12 ) = isave ( 11 ) + n ! wr      n isave ( 13 ) = isave ( 12 ) + n ! wd      n isave ( 14 ) = isave ( 13 ) + n ! wt      n isave ( 15 ) = isave ( 14 ) + n ! wxp     n isave ( 16 ) = isave ( 15 ) + n ! wa      8*m endif lws = isave ( 4 ) lwy = isave ( 5 ) lsy = isave ( 6 ) lss = isave ( 7 ) lwt = isave ( 8 ) lwn = isave ( 9 ) lsnd = isave ( 10 ) lz = isave ( 11 ) lr = isave ( 12 ) ld = isave ( 13 ) lt = isave ( 14 ) lxp = isave ( 15 ) lwa = isave ( 16 ) call mainlb ( n , m , x , l , u , nbd , f , g , factr , pgtol , + wa ( lws ), wa ( lwy ), wa ( lsy ), wa ( lss ), wa ( lwt ), + wa ( lwn ), wa ( lsnd ), wa ( lz ), wa ( lr ), wa ( ld ), wa ( lt ), wa ( lxp ), + wa ( lwa ), + iwa ( 1 ), iwa ( n + 1 ), iwa ( 2 * n + 1 ), task , iprint , + csave , lsave , isave ( 22 ), dsave ) return end c======================= The end of setulb ============================= subroutine mainlb ( n , m , x , l , u , nbd , f , g , factr , pgtol , ws , wy , + sy , ss , wt , wn , snd , z , r , d , t , xp , wa , + index , iwhere , indx2 , task , + iprint , csave , lsave , isave , dsave ) implicit none character * 60 task , csave logical lsave ( 4 ) integer n , m , iprint , nbd ( n ), index ( n ), + iwhere ( n ), indx2 ( n ), isave ( 23 ) double precision f , factr , pgtol , + x ( n ), l ( n ), u ( n ), g ( n ), z ( n ), r ( n ), d ( n ), t ( n ), c-jlm-jn + xp ( n ), + wa ( 8 * m ), + ws ( n , m ), wy ( n , m ), sy ( m , m ), ss ( m , m ), + wt ( m , m ), wn ( 2 * m , 2 * m ), snd ( 2 * m , 2 * m ), dsave ( 29 ) c     ************ c c     Subroutine mainlb c c     This subroutine solves bound constrained optimization problems by c       using the compact formula of the limited memory BFGS updates. c c     n is an integer variable. c       On entry n is the number of variables. c       On exit n is unchanged. c c     m is an integer variable. c       On entry m is the maximum number of variable metric c          corrections allowed in the limited memory matrix. c       On exit m is unchanged. c c     x is a double precision array of dimension n. c       On entry x is an approximation to the solution. c       On exit x is the current approximation. c c     l is a double precision array of dimension n. c       On entry l is the lower bound of x. c       On exit l is unchanged. c c     u is a double precision array of dimension n. c       On entry u is the upper bound of x. c       On exit u is unchanged. c c     nbd is an integer array of dimension n. c       On entry nbd represents the type of bounds imposed on the c         variables, and must be specified as follows: c         nbd(i)=0 if x(i) is unbounded, c                1 if x(i) has only a lower bound, c                2 if x(i) has both lower and upper bounds, c                3 if x(i) has only an upper bound. c       On exit nbd is unchanged. c c     f is a double precision variable. c       On first entry f is unspecified. c       On final exit f is the value of the function at x. c c     g is a double precision array of dimension n. c       On first entry g is unspecified. c       On final exit g is the value of the gradient at x. c c     factr is a double precision variable. c       On entry factr >= 0 is specified by the user.  The iteration c         will stop when c c         (f&#94;k - f&#94;{k+1})/max{|f&#94;k|,|f&#94;{k+1}|,1} <= factr*epsmch c c         where epsmch is the machine precision, which is automatically c         generated by the code. c       On exit factr is unchanged. c c     pgtol is a double precision variable. c       On entry pgtol >= 0 is specified by the user.  The iteration c         will stop when c c                 max{|proj g_i | i = 1, ..., n} <= pgtol c c         where pg_i is the ith component of the projected gradient. c       On exit pgtol is unchanged. c c     ws, wy, sy, and wt are double precision working arrays used to c       store the following information defining the limited memory c          BFGS matrix: c          ws, of dimension n x m, stores S, the matrix of s-vectors; c          wy, of dimension n x m, stores Y, the matrix of y-vectors; c          sy, of dimension m x m, stores S'Y; c          ss, of dimension m x m, stores S'S; c          yy, of dimension m x m, stores Y'Y; c          wt, of dimension m x m, stores the Cholesky factorization c                                  of (theta*S'S+LD&#94;(-1)L'); see eq. c                                  (2.26) in [3]. c c     wn is a double precision working array of dimension 2m x 2m c       used to store the LEL&#94;T factorization of the indefinite matrix c                 K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ] c                     [L_a -R_z           theta*S'AA'S ] c c       where     E = [-I  0] c                     [ 0  I] c c     snd is a double precision working array of dimension 2m x 2m c       used to store the lower triangular part of c                 N = [Y' ZZ'Y   L_a'+R_z'] c                     [L_a +R_z  S'AA'S   ] c c     z(n),r(n),d(n),t(n), xp(n),wa(8*m) are double precision working arrays. c       z  is used at different times to store the Cauchy point and c          the Newton point. c       xp is used to safeguard the projected Newton direction c c     sg(m),sgo(m),yg(m),ygo(m) are double precision working arrays. c c     index is an integer working array of dimension n. c       In subroutine freev, index is used to store the free and fixed c          variables at the Generalized Cauchy Point (GCP). c c     iwhere is an integer working array of dimension n used to record c       the status of the vector x for GCP computation. c       iwhere(i)=0 or -3 if x(i) is free and has bounds, c                 1       if x(i) is fixed at l(i), and l(i) .ne. u(i) c                 2       if x(i) is fixed at u(i), and u(i) .ne. l(i) c                 3       if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i) c                -1       if x(i) is always free, i.e., no bounds on it. c c     indx2 is an integer working array of dimension n. c       Within subroutine cauchy, indx2 corresponds to the array iorder. c       In subroutine freev, a list of variables entering and leaving c       the free set is stored in indx2, and it is passed on to c       subroutine formk with this information. c c     task is a working string of characters of length 60 indicating c       the current job when entering and leaving this subroutine. c c     iprint is an INTEGER variable that must be set by the user. c       It controls the frequency and type of output generated: c        iprint<0    no output is generated; c        iprint=0    print only one line at the last iteration; c        0<iprint<99 print also f and |proj g| every iprint iterations; c        iprint=99   print details of every iteration except n-vectors; c        iprint=100  print also the changes of active set and final x; c        iprint>100  print details of every iteration including x and g; c       When iprint > 0, the file iterate.dat will be created to c                        summarize the iteration. c c     csave is a working string of characters of length 60. c c     lsave is a logical working array of dimension 4. c c     isave is an integer working array of dimension 23. c c     dsave is a double precision working array of dimension 29. c c c     Subprograms called c c       L-BFGS-B Library ... cauchy, subsm, lnsrlb, formk, c c        errclb, prn1lb, prn2lb, prn3lb, active, projgr, c c        freev, cmprlb, matupd, formt. c c       Minpack2 Library ... timer c c       Linpack Library ... dcopy, ddot. c c c     References: c c       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited c       memory algorithm for bound constrained optimization'', c       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. c c       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN c       Subroutines for Large Scale Bound Constrained Optimization'' c       Tech. Report, NAM-11, EECS Department, Northwestern University, c       1994. c c       [3] R. Byrd, J. Nocedal and R. Schnabel \"Representations of c       Quasi-Newton Matrices and their use in Limited Memory Methods'', c       Mathematical Programming 63 (1994), no. 4, pp. 129-156. c c       (Postscript files of these papers are available via anonymous c        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.) c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ logical prjctd , cnstnd , boxed , updatd , wrk character * 3 word integer i , k , nintol , itfile , iback , nskip , + head , col , iter , itail , iupdat , + nseg , nfgv , info , ifun , + iword , nfree , nact , ileave , nenter double precision theta , fold , ddot , dr , rr , tol , + xstep , sbgnrm , ddum , dnorm , dtd , epsmch , + cpu1 , cpu2 , cachyt , sbtime , lnscht , time1 , time2 , + gd , gdold , stp , stpmx , time double precision one , zero parameter ( one = 1.0d0 , zero = 0.0d0 ) if ( task . eq . 'START' ) then epsmch = epsilon ( one ) call timer ( time1 ) c        Initialize counters and scalars when task='START'. c           for the limited memory BFGS matrices: col = 0 head = 1 theta = one iupdat = 0 updatd = . false . iback = 0 itail = 0 iword = 0 nact = 0 ileave = 0 nenter = 0 fold = zero dnorm = zero cpu1 = zero gd = zero stpmx = zero sbgnrm = zero stp = zero gdold = zero dtd = zero c           for operation counts: iter = 0 nfgv = 0 nseg = 0 nintol = 0 nskip = 0 nfree = n ifun = 0 c           for stopping tolerance: tol = factr * epsmch c           for measuring running time: cachyt = 0 sbtime = 0 lnscht = 0 c           'word' records the status of subspace solutions. word = '---' c           'info' records the termination information. info = 0 itfile = 8 if ( iprint . ge . 1 ) then c                                open a summary file 'iterate.dat' open ( 8 , file = 'iterate.dat' , status = 'unknown' ) endif c        Check the input arguments for errors. call errclb ( n , m , factr , l , u , nbd , task , info , k ) if ( task ( 1 : 5 ) . eq . 'ERROR' ) then call prn3lb ( n , x , f , task , iprint , info , itfile , + iter , nfgv , nintol , nskip , nact , sbgnrm , + zero , nseg , word , iback , stp , xstep , k , + cachyt , sbtime , lnscht ) return endif call prn1lb ( n , m , l , u , x , iprint , itfile , epsmch ) c        Initialize iwhere & project x onto the feasible set. call active ( n , l , u , nbd , x , iwhere , iprint , prjctd , cnstnd , boxed ) c        The end of the initialization. else c          restore local variables. prjctd = lsave ( 1 ) cnstnd = lsave ( 2 ) boxed = lsave ( 3 ) updatd = lsave ( 4 ) nintol = isave ( 1 ) itfile = isave ( 3 ) iback = isave ( 4 ) nskip = isave ( 5 ) head = isave ( 6 ) col = isave ( 7 ) itail = isave ( 8 ) iter = isave ( 9 ) iupdat = isave ( 10 ) nseg = isave ( 12 ) nfgv = isave ( 13 ) info = isave ( 14 ) ifun = isave ( 15 ) iword = isave ( 16 ) nfree = isave ( 17 ) nact = isave ( 18 ) ileave = isave ( 19 ) nenter = isave ( 20 ) theta = dsave ( 1 ) fold = dsave ( 2 ) tol = dsave ( 3 ) dnorm = dsave ( 4 ) epsmch = dsave ( 5 ) cpu1 = dsave ( 6 ) cachyt = dsave ( 7 ) sbtime = dsave ( 8 ) lnscht = dsave ( 9 ) time1 = dsave ( 10 ) gd = dsave ( 11 ) stpmx = dsave ( 12 ) sbgnrm = dsave ( 13 ) stp = dsave ( 14 ) gdold = dsave ( 15 ) dtd = dsave ( 16 ) c        After returning from the driver go to the point where execution c        is to resume. if ( task ( 1 : 5 ) . eq . 'FG_LN' ) goto 666 if ( task ( 1 : 5 ) . eq . 'NEW_X' ) goto 777 if ( task ( 1 : 5 ) . eq . 'FG_ST' ) goto 111 if ( task ( 1 : 4 ) . eq . 'STOP' ) then if ( task ( 7 : 9 ) . eq . 'CPU' ) then c                                          restore the previous iterate. call dcopy ( n , t , 1 , x , 1 ) call dcopy ( n , r , 1 , g , 1 ) f = fold endif goto 999 endif endif c     Compute f0 and g0. task = 'FG_START' c          return to the driver to calculate f and g; reenter at 111. goto 1000 111 continue nfgv = 1 c     Compute the infinity norm of the (-) projected gradient. call projgr ( n , l , u , nbd , x , g , sbgnrm ) if ( iprint . ge . 1 ) then write ( 6 , 1002 ) iter , f , sbgnrm write ( itfile , 1003 ) iter , nfgv , sbgnrm , f endif if ( sbgnrm . le . pgtol ) then c                                terminate the algorithm. task = 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL' goto 999 endif c ----------------- the beginning of the loop -------------------------- 222 continue if ( iprint . ge . 99 ) write ( 6 , 1001 ) iter + 1 iword = - 1 c if (. not . cnstnd . and . col . gt . 0 ) then c                                            skip the search for GCP. call dcopy ( n , x , 1 , z , 1 ) wrk = updatd nseg = 0 goto 333 endif cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc c c     Compute the Generalized Cauchy Point (GCP). c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc call timer ( cpu1 ) call cauchy ( n , x , l , u , nbd , g , indx2 , iwhere , t , d , z , + m , wy , ws , sy , wt , theta , col , head , + wa ( 1 ), wa ( 2 * m + 1 ), wa ( 4 * m + 1 ), wa ( 6 * m + 1 ), nseg , + iprint , sbgnrm , info , epsmch ) if ( info . ne . 0 ) then c         singular triangular system detected; refresh the lbfgs memory. if ( iprint . ge . 1 ) write ( 6 , 1005 ) info = 0 col = 0 head = 1 theta = one iupdat = 0 updatd = . false . call timer ( cpu2 ) cachyt = cachyt + cpu2 - cpu1 goto 222 endif call timer ( cpu2 ) cachyt = cachyt + cpu2 - cpu1 nintol = nintol + nseg c     Count the entering and leaving variables for iter > 0; c     find the index set of free and active variables at the GCP. call freev ( n , nfree , index , nenter , ileave , indx2 , + iwhere , wrk , updatd , cnstnd , iprint , iter ) nact = n - nfree 333 continue c     If there are no free variables or B=theta*I, then c                                        skip the subspace minimization. if ( nfree . eq . 0 . or . col . eq . 0 ) goto 555 cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc c c     Subspace minimization. c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc call timer ( cpu1 ) c     Form  the LEL&#94;T factorization of the indefinite c       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ] c                     [L_a -R_z           theta*S'AA'S ] c       where     E = [-I  0] c                     [ 0  I] if ( wrk ) call formk ( n , nfree , index , nenter , ileave , indx2 , iupdat , + updatd , wn , snd , m , ws , wy , sy , theta , col , head , info ) if ( info . ne . 0 ) then c          nonpositive definiteness in Cholesky factorization; c          refresh the lbfgs memory and restart the iteration. if ( iprint . ge . 1 ) write ( 6 , 1006 ) info = 0 col = 0 head = 1 theta = one iupdat = 0 updatd = . false . call timer ( cpu2 ) sbtime = sbtime + cpu2 - cpu1 goto 222 endif c        compute r=-Z'B(xcp-xk)-Z'g (using wa(2m+1)=W'(xcp-x) c                                                   from 'cauchy'). call cmprlb ( n , m , x , g , ws , wy , sy , wt , z , r , wa , index , + theta , col , head , nfree , cnstnd , info ) if ( info . ne . 0 ) goto 444 c-jlm-jn   call the direct method. call subsm ( n , m , nfree , index , l , u , nbd , z , r , xp , ws , wy , + theta , x , g , col , head , iword , wa , wn , iprint , info ) 444 continue if ( info . ne . 0 ) then c          singular triangular system detected; c          refresh the lbfgs memory and restart the iteration. if ( iprint . ge . 1 ) write ( 6 , 1005 ) info = 0 col = 0 head = 1 theta = one iupdat = 0 updatd = . false . call timer ( cpu2 ) sbtime = sbtime + cpu2 - cpu1 goto 222 endif call timer ( cpu2 ) sbtime = sbtime + cpu2 - cpu1 555 continue cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc c c     Line search and optimality tests. c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc c     Generate the search direction d:=z-x. do 40 i = 1 , n d ( i ) = z ( i ) - x ( i ) 40 continue call timer ( cpu1 ) 666 continue call lnsrlb ( n , l , u , nbd , x , f , fold , gd , gdold , g , d , r , t , z , stp , dnorm , + dtd , xstep , stpmx , iter , ifun , iback , nfgv , info , task , + boxed , cnstnd , csave , isave ( 22 ), dsave ( 17 )) if ( info . ne . 0 . or . iback . ge . 20 ) then c          restore the previous iterate. call dcopy ( n , t , 1 , x , 1 ) call dcopy ( n , r , 1 , g , 1 ) f = fold if ( col . eq . 0 ) then c             abnormal termination. if ( info . eq . 0 ) then info = - 9 c                restore the actual number of f and g evaluations etc. nfgv = nfgv - 1 ifun = ifun - 1 iback = iback - 1 endif task = 'ABNORMAL_TERMINATION_IN_LNSRCH' iter = iter + 1 goto 999 else c             refresh the lbfgs memory and restart the iteration. if ( iprint . ge . 1 ) write ( 6 , 1008 ) if ( info . eq . 0 ) nfgv = nfgv - 1 info = 0 col = 0 head = 1 theta = one iupdat = 0 updatd = . false . task = 'RESTART_FROM_LNSRCH' call timer ( cpu2 ) lnscht = lnscht + cpu2 - cpu1 goto 222 endif else if ( task ( 1 : 5 ) . eq . 'FG_LN' ) then c          return to the driver for calculating f and g; reenter at 666. goto 1000 else c          calculate and print out the quantities related to the new X. call timer ( cpu2 ) lnscht = lnscht + cpu2 - cpu1 iter = iter + 1 c        Compute the infinity norm of the projected (-)gradient. call projgr ( n , l , u , nbd , x , g , sbgnrm ) c        Print iteration information. call prn2lb ( n , x , f , g , iprint , itfile , iter , nfgv , nact , + sbgnrm , nseg , word , iword , iback , stp , xstep ) goto 1000 endif 777 continue c     Test for termination. if ( sbgnrm . le . pgtol ) then c                                terminate the algorithm. task = 'CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL' goto 999 endif ddum = max ( abs ( fold ), abs ( f ), one ) if (( fold - f ) . le . tol * ddum ) then c                                        terminate the algorithm. task = 'CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH' if ( iback . ge . 10 ) info = - 5 c           i.e., to issue a warning if iback>10 in the line search. goto 999 endif c     Compute d=newx-oldx, r=newg-oldg, rr=y'y and dr=y's. do 42 i = 1 , n r ( i ) = g ( i ) - r ( i ) 42 continue rr = ddot ( n , r , 1 , r , 1 ) if ( stp . eq . one ) then dr = gd - gdold ddum = - gdold else dr = ( gd - gdold ) * stp call dscal ( n , stp , d , 1 ) ddum = - gdold * stp endif if ( dr . le . epsmch * ddum ) then c                            skip the L-BFGS update. nskip = nskip + 1 updatd = . false . if ( iprint . ge . 1 ) write ( 6 , 1004 ) dr , ddum goto 888 endif cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc c c     Update the L-BFGS matrix. c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc updatd = . true . iupdat = iupdat + 1 c     Update matrices WS and WY and form the middle matrix in B. call matupd ( n , m , ws , wy , sy , ss , d , r , itail , + iupdat , col , head , theta , rr , dr , stp , dtd ) c     Form the upper half of the pds T = theta*SS + L*D&#94;(-1)*L'; c        Store T in the upper triangular of the array wt; c        Cholesky factorize T to J*J' with c           J' stored in the upper triangular of wt. call formt ( m , wt , sy , ss , col , theta , info ) if ( info . ne . 0 ) then c          nonpositive definiteness in Cholesky factorization; c          refresh the lbfgs memory and restart the iteration. if ( iprint . ge . 1 ) write ( 6 , 1007 ) info = 0 col = 0 head = 1 theta = one iupdat = 0 updatd = . false . goto 222 endif c     Now the inverse of the middle matrix in B is c       [  D&#94;(1/2)      O ] [ -D&#94;(1/2)  D&#94;(-1/2)*L' ] c       [ -L*D&#94;(-1/2)   J ] [  0        J'          ] 888 continue c -------------------- the end of the loop ----------------------------- goto 222 999 continue call timer ( time2 ) time = time2 - time1 call prn3lb ( n , x , f , task , iprint , info , itfile , + iter , nfgv , nintol , nskip , nact , sbgnrm , + time , nseg , word , iback , stp , xstep , k , + cachyt , sbtime , lnscht ) 1000 continue c     Save local variables. lsave ( 1 ) = prjctd lsave ( 2 ) = cnstnd lsave ( 3 ) = boxed lsave ( 4 ) = updatd isave ( 1 ) = nintol isave ( 3 ) = itfile isave ( 4 ) = iback isave ( 5 ) = nskip isave ( 6 ) = head isave ( 7 ) = col isave ( 8 ) = itail isave ( 9 ) = iter isave ( 10 ) = iupdat isave ( 12 ) = nseg isave ( 13 ) = nfgv isave ( 14 ) = info isave ( 15 ) = ifun isave ( 16 ) = iword isave ( 17 ) = nfree isave ( 18 ) = nact isave ( 19 ) = ileave isave ( 20 ) = nenter dsave ( 1 ) = theta dsave ( 2 ) = fold dsave ( 3 ) = tol dsave ( 4 ) = dnorm dsave ( 5 ) = epsmch dsave ( 6 ) = cpu1 dsave ( 7 ) = cachyt dsave ( 8 ) = sbtime dsave ( 9 ) = lnscht dsave ( 10 ) = time1 dsave ( 11 ) = gd dsave ( 12 ) = stpmx dsave ( 13 ) = sbgnrm dsave ( 14 ) = stp dsave ( 15 ) = gdold dsave ( 16 ) = dtd 1001 format ( // , 'ITERATION ' , i5 ) 1002 format + ( / , 'At iterate' , i5 , 4 x , 'f= ' , 1 p , d12 . 5 , 4 x , '|proj g|= ' , 1 p , d12 . 5 ) 1003 format ( 2 ( 1 x , i4 ), 5 x , '-' , 5 x , '-' , 3 x , '-' , 5 x , '-' , 5 x , '-' , 8 x , '-' , 3 x , + 1 p , 2 ( 1 x , d10 . 3 )) 1004 format ( '  ys=' , 1 p , e10 . 3 , '  -gs=' , 1 p , e10 . 3 , ' BFGS update SKIPPED' ) 1005 format ( / , + ' Singular triangular system detected;' , / , + '   refresh the lbfgs memory and restart the iteration.' ) 1006 format ( / , + ' Nonpositive definiteness in Cholesky factorization in formk;' , / , + '   refresh the lbfgs memory and restart the iteration.' ) 1007 format ( / , + ' Nonpositive definiteness in Cholesky factorization in formt;' , / , + '   refresh the lbfgs memory and restart the iteration.' ) 1008 format ( / , + ' Bad direction in the line search;' , / , + '   refresh the lbfgs memory and restart the iteration.' ) return end c======================= The end of mainlb ============================= subroutine active ( n , l , u , nbd , x , iwhere , iprint , + prjctd , cnstnd , boxed ) logical prjctd , cnstnd , boxed integer n , iprint , nbd ( n ), iwhere ( n ) double precision x ( n ), l ( n ), u ( n ) c     ************ c c     Subroutine active c c     This subroutine initializes iwhere and projects the initial x to c       the feasible set if necessary. c c     iwhere is an integer array of dimension n. c       On entry iwhere is unspecified. c       On exit iwhere(i)=-1  if x(i) has no bounds c                         3   if l(i)=u(i) c                         0   otherwise. c       In cauchy, iwhere is given finer gradations. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer nbdd , i double precision zero parameter ( zero = 0.0d0 ) c     Initialize nbdd, prjctd, cnstnd and boxed. nbdd = 0 prjctd = . false . cnstnd = . false . boxed = . true . c     Project the initial x to the easible set if necessary. do 10 i = 1 , n if ( nbd ( i ) . gt . 0 ) then if ( nbd ( i ) . le . 2 . and . x ( i ) . le . l ( i )) then if ( x ( i ) . lt . l ( i )) then prjctd = . true . x ( i ) = l ( i ) endif nbdd = nbdd + 1 else if ( nbd ( i ) . ge . 2 . and . x ( i ) . ge . u ( i )) then if ( x ( i ) . gt . u ( i )) then prjctd = . true . x ( i ) = u ( i ) endif nbdd = nbdd + 1 endif endif 10 continue c     Initialize iwhere and assign values to cnstnd and boxed. do 20 i = 1 , n if ( nbd ( i ) . ne . 2 ) boxed = . false . if ( nbd ( i ) . eq . 0 ) then c                                this variable is always free iwhere ( i ) = - 1 c           otherwise set x(i)=mid(x(i), u(i), l(i)). else cnstnd = . true . if ( nbd ( i ) . eq . 2 . and . u ( i ) - l ( i ) . le . zero ) then c                   this variable is always fixed iwhere ( i ) = 3 else iwhere ( i ) = 0 endif endif 20 continue if ( iprint . ge . 0 ) then if ( prjctd ) write ( 6 , * ) + 'The initial X is infeasible.  Restart with its projection.' if (. not . cnstnd ) + write ( 6 , * ) 'This problem is unconstrained.' endif if ( iprint . gt . 0 ) write ( 6 , 1001 ) nbdd 1001 format ( / , 'At X0 ' , i9 , ' variables are exactly at the bounds' ) return end c======================= The end of active ============================= subroutine bmv ( m , sy , wt , col , v , p , info ) integer m , col , info double precision sy ( m , m ), wt ( m , m ), v ( 2 * col ), p ( 2 * col ) c     ************ c c     Subroutine bmv c c     This subroutine computes the product of the 2m x 2m middle matrix c       in the compact L-BFGS formula of B and a 2m vector v; c       it returns the product in p. c c     m is an integer variable. c       On entry m is the maximum number of variable metric corrections c         used to define the limited memory matrix. c       On exit m is unchanged. c c     sy is a double precision array of dimension m x m. c       On entry sy specifies the matrix S'Y. c       On exit sy is unchanged. c c     wt is a double precision array of dimension m x m. c       On entry wt specifies the upper triangular matrix J' which is c         the Cholesky factor of (thetaS'S+LD&#94;(-1)L'). c       On exit wt is unchanged. c c     col is an integer variable. c       On entry col specifies the number of s-vectors (or y-vectors) c         stored in the compact L-BFGS formula. c       On exit col is unchanged. c c     v is a double precision array of dimension 2col. c       On entry v specifies vector v. c       On exit v is unchanged. c c     p is a double precision array of dimension 2col. c       On entry p is unspecified. c       On exit p is the product Mv. c c     info is an integer variable. c       On entry info is unspecified. c       On exit info = 0       for normal return, c                    = nonzero for abnormal return when the system c                                to be solved by dtrsl is singular. c c     Subprograms called: c c       Linpack ... dtrsl. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer i , k , i2 double precision sum if ( col . eq . 0 ) return c     PART I: solve [  D&#94;(1/2)      O ] [ p1 ] = [ v1 ] c                   [ -L*D&#94;(-1/2)   J ] [ p2 ]   [ v2 ]. c       solve Jp2=v2+LD&#94;(-1)v1. p ( col + 1 ) = v ( col + 1 ) do 20 i = 2 , col i2 = col + i sum = 0.0d0 do 10 k = 1 , i - 1 sum = sum + sy ( i , k ) * v ( k ) / sy ( k , k ) 10 continue p ( i2 ) = v ( i2 ) + sum 20 continue c     Solve the triangular system call dtrsl ( wt , m , col , p ( col + 1 ), 11 , info ) if ( info . ne . 0 ) return c       solve D&#94;(1/2)p1=v1. do 30 i = 1 , col p ( i ) = v ( i ) / sqrt ( sy ( i , i )) 30 continue c     PART II: solve [ -D&#94;(1/2)   D&#94;(-1/2)*L'  ] [ p1 ] = [ p1 ] c                    [  0         J'           ] [ p2 ]   [ p2 ]. c       solve J&#94;Tp2=p2. call dtrsl ( wt , m , col , p ( col + 1 ), 01 , info ) if ( info . ne . 0 ) return c       compute p1=-D&#94;(-1/2)(p1-D&#94;(-1/2)L'p2) c                 =-D&#94;(-1/2)p1+D&#94;(-1)L'p2. do 40 i = 1 , col p ( i ) = - p ( i ) / sqrt ( sy ( i , i )) 40 continue do 60 i = 1 , col sum = 0.d0 do 50 k = i + 1 , col sum = sum + sy ( k , i ) * p ( col + k ) / sy ( i , i ) 50 continue p ( i ) = p ( i ) + sum 60 continue return end c======================== The end of bmv =============================== subroutine cauchy ( n , x , l , u , nbd , g , iorder , iwhere , t , d , xcp , + m , wy , ws , sy , wt , theta , col , head , p , c , wbp , + v , nseg , iprint , sbgnrm , info , epsmch ) implicit none integer n , m , head , col , nseg , iprint , info , + nbd ( n ), iorder ( n ), iwhere ( n ) double precision theta , epsmch , + x ( n ), l ( n ), u ( n ), g ( n ), t ( n ), d ( n ), xcp ( n ), + wy ( n , col ), ws ( n , col ), sy ( m , m ), + wt ( m , m ), p ( 2 * m ), c ( 2 * m ), wbp ( 2 * m ), v ( 2 * m ) c     ************ c c     Subroutine cauchy c c     For given x, l, u, g (with sbgnrm > 0), and a limited memory c       BFGS matrix B defined in terms of matrices WY, WS, WT, and c       scalars head, col, and theta, this subroutine computes the c       generalized Cauchy point (GCP), defined as the first local c       minimizer of the quadratic c c                  Q(x + s) = g's + 1/2 s'Bs c c       along the projected gradient direction P(x-tg,l,u). c       The routine returns the GCP in xcp. c c     n is an integer variable. c       On entry n is the dimension of the problem. c       On exit n is unchanged. c c     x is a double precision array of dimension n. c       On entry x is the starting point for the GCP computation. c       On exit x is unchanged. c c     l is a double precision array of dimension n. c       On entry l is the lower bound of x. c       On exit l is unchanged. c c     u is a double precision array of dimension n. c       On entry u is the upper bound of x. c       On exit u is unchanged. c c     nbd is an integer array of dimension n. c       On entry nbd represents the type of bounds imposed on the c         variables, and must be specified as follows: c         nbd(i)=0 if x(i) is unbounded, c                1 if x(i) has only a lower bound, c                2 if x(i) has both lower and upper bounds, and c                3 if x(i) has only an upper bound. c       On exit nbd is unchanged. c c     g is a double precision array of dimension n. c       On entry g is the gradient of f(x).  g must be a nonzero vector. c       On exit g is unchanged. c c     iorder is an integer working array of dimension n. c       iorder will be used to store the breakpoints in the piecewise c       linear path and free variables encountered. On exit, c         iorder(1),...,iorder(nleft) are indices of breakpoints c                                which have not been encountered; c         iorder(nleft+1),...,iorder(nbreak) are indices of c                                     encountered breakpoints; and c         iorder(nfree),...,iorder(n) are indices of variables which c                 have no bound constraits along the search direction. c c     iwhere is an integer array of dimension n. c       On entry iwhere indicates only the permanently fixed (iwhere=3) c       or free (iwhere= -1) components of x. c       On exit iwhere records the status of the current x variables. c       iwhere(i)=-3  if x(i) is free and has bounds, but is not moved c                 0   if x(i) is free and has bounds, and is moved c                 1   if x(i) is fixed at l(i), and l(i) .ne. u(i) c                 2   if x(i) is fixed at u(i), and u(i) .ne. l(i) c                 3   if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i) c                 -1  if x(i) is always free, i.e., it has no bounds. c c     t is a double precision working array of dimension n. c       t will be used to store the break points. c c     d is a double precision array of dimension n used to store c       the Cauchy direction P(x-tg)-x. c c     xcp is a double precision array of dimension n used to return the c       GCP on exit. c c     m is an integer variable. c       On entry m is the maximum number of variable metric corrections c         used to define the limited memory matrix. c       On exit m is unchanged. c c     ws, wy, sy, and wt are double precision arrays. c       On entry they store information that defines the c                             limited memory BFGS matrix: c         ws(n,m) stores S, a set of s-vectors; c         wy(n,m) stores Y, a set of y-vectors; c         sy(m,m) stores S'Y; c         wt(m,m) stores the c                 Cholesky factorization of (theta*S'S+LD&#94;(-1)L'). c       On exit these arrays are unchanged. c c     theta is a double precision variable. c       On entry theta is the scaling factor specifying B_0 = theta I. c       On exit theta is unchanged. c c     col is an integer variable. c       On entry col is the actual number of variable metric c         corrections stored so far. c       On exit col is unchanged. c c     head is an integer variable. c       On entry head is the location of the first s-vector (or y-vector) c         in S (or Y). c       On exit col is unchanged. c c     p is a double precision working array of dimension 2m. c       p will be used to store the vector p = W&#94;(T)d. c c     c is a double precision working array of dimension 2m. c       c will be used to store the vector c = W&#94;(T)(xcp-x). c c     wbp is a double precision working array of dimension 2m. c       wbp will be used to store the row of W corresponding c         to a breakpoint. c c     v is a double precision working array of dimension 2m. c c     nseg is an integer variable. c       On exit nseg records the number of quadratic segments explored c         in searching for the GCP. c c     sg and yg are double precision arrays of dimension m. c       On entry sg  and yg store S'g and Y'g correspondingly. c       On exit they are unchanged. c c     iprint is an INTEGER variable that must be set by the user. c       It controls the frequency and type of output generated: c        iprint<0    no output is generated; c        iprint=0    print only one line at the last iteration; c        0<iprint<99 print also f and |proj g| every iprint iterations; c        iprint=99   print details of every iteration except n-vectors; c        iprint=100  print also the changes of active set and final x; c        iprint>100  print details of every iteration including x and g; c       When iprint > 0, the file iterate.dat will be created to c                        summarize the iteration. c c     sbgnrm is a double precision variable. c       On entry sbgnrm is the norm of the projected gradient at x. c       On exit sbgnrm is unchanged. c c     info is an integer variable. c       On entry info is 0. c       On exit info = 0       for normal return, c                    = nonzero for abnormal return when the the system c                              used in routine bmv is singular. c c     Subprograms called: c c       L-BFGS-B Library ... hpsolb, bmv. c c       Linpack ... dscal dcopy, daxpy. c c c     References: c c       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited c       memory algorithm for bound constrained optimization'', c       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. c c       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN c       Subroutines for Large Scale Bound Constrained Optimization'' c       Tech. Report, NAM-11, EECS Department, Northwestern University, c       1994. c c       (Postscript files of these papers are available via anonymous c        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.) c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ logical xlower , xupper , bnded integer i , j , col2 , nfree , nbreak , pointr , + ibp , nleft , ibkmin , iter double precision f1 , f2 , dt , dtm , tsum , dibp , zibp , dibp2 , bkmin , + tu , tl , wmc , wmp , wmw , ddot , tj , tj0 , neggi , sbgnrm , + f2_org double precision one , zero parameter ( one = 1.0d0 , zero = 0.0d0 ) c     Check the status of the variables, reset iwhere(i) if necessary; c       compute the Cauchy direction d and the breakpoints t; initialize c       the derivative f1 and the vector p = W'd (for theta = 1). if ( sbgnrm . le . zero ) then if ( iprint . ge . 0 ) write ( 6 , * ) 'Subgnorm = 0.  GCP = X.' call dcopy ( n , x , 1 , xcp , 1 ) return endif bnded = . true . nfree = n + 1 nbreak = 0 ibkmin = 0 bkmin = zero col2 = 2 * col f1 = zero if ( iprint . ge . 99 ) write ( 6 , 3010 ) c     We set p to zero and build it up as we determine d. do 20 i = 1 , col2 p ( i ) = zero 20 continue c     In the following loop we determine for each variable its bound c        status and its breakpoint, and update p accordingly. c        Smallest breakpoint is identified. do 50 i = 1 , n neggi = - g ( i ) if ( iwhere ( i ) . ne . 3 . and . iwhere ( i ) . ne . - 1 ) then c             if x(i) is not a constant and has bounds, c             compute the difference between x(i) and its bounds. if ( nbd ( i ) . le . 2 ) tl = x ( i ) - l ( i ) if ( nbd ( i ) . ge . 2 ) tu = u ( i ) - x ( i ) c           If a variable is close enough to a bound c             we treat it as at bound. xlower = nbd ( i ) . le . 2 . and . tl . le . zero xupper = nbd ( i ) . ge . 2 . and . tu . le . zero c              reset iwhere(i). iwhere ( i ) = 0 if ( xlower ) then if ( neggi . le . zero ) iwhere ( i ) = 1 else if ( xupper ) then if ( neggi . ge . zero ) iwhere ( i ) = 2 else if ( abs ( neggi ) . le . zero ) iwhere ( i ) = - 3 endif endif pointr = head if ( iwhere ( i ) . ne . 0 . and . iwhere ( i ) . ne . - 1 ) then d ( i ) = zero else d ( i ) = neggi f1 = f1 - neggi * neggi c             calculate p := p - W'e_i* (g_i). do 40 j = 1 , col p ( j ) = p ( j ) + wy ( i , pointr ) * neggi p ( col + j ) = p ( col + j ) + ws ( i , pointr ) * neggi pointr = mod ( pointr , m ) + 1 40 continue if ( nbd ( i ) . le . 2 . and . nbd ( i ) . ne . 0 + . and . neggi . lt . zero ) then c                                 x(i) + d(i) is bounded; compute t(i). nbreak = nbreak + 1 iorder ( nbreak ) = i t ( nbreak ) = tl / ( - neggi ) if ( nbreak . eq . 1 . or . t ( nbreak ) . lt . bkmin ) then bkmin = t ( nbreak ) ibkmin = nbreak endif else if ( nbd ( i ) . ge . 2 . and . neggi . gt . zero ) then c                                 x(i) + d(i) is bounded; compute t(i). nbreak = nbreak + 1 iorder ( nbreak ) = i t ( nbreak ) = tu / neggi if ( nbreak . eq . 1 . or . t ( nbreak ) . lt . bkmin ) then bkmin = t ( nbreak ) ibkmin = nbreak endif else c                x(i) + d(i) is not bounded. nfree = nfree - 1 iorder ( nfree ) = i if ( abs ( neggi ) . gt . zero ) bnded = . false . endif endif 50 continue c     The indices of the nonzero components of d are now stored c       in iorder(1),...,iorder(nbreak) and iorder(nfree),...,iorder(n). c       The smallest of the nbreak breakpoints is in t(ibkmin)=bkmin. if ( theta . ne . one ) then c                   complete the initialization of p for theta not= one. call dscal ( col , theta , p ( col + 1 ), 1 ) endif c     Initialize GCP xcp = x. call dcopy ( n , x , 1 , xcp , 1 ) if ( nbreak . eq . 0 . and . nfree . eq . n + 1 ) then c                  is a zero vector, return with the initial xcp as GCP. if ( iprint . gt . 100 ) write ( 6 , 1010 ) ( xcp ( i ), i = 1 , n ) return endif c     Initialize c = W'(xcp - x) = 0. do 60 j = 1 , col2 c ( j ) = zero 60 continue c     Initialize derivative f2. f2 = - theta * f1 f2_org = f2 if ( col . gt . 0 ) then call bmv ( m , sy , wt , col , p , v , info ) if ( info . ne . 0 ) return f2 = f2 - ddot ( col2 , v , 1 , p , 1 ) endif dtm = - f1 / f2 tsum = zero nseg = 1 if ( iprint . ge . 99 ) + write ( 6 , * ) 'There are ' , nbreak , '  breakpoints ' c     If there are no breakpoints, locate the GCP and return. if ( nbreak . eq . 0 ) goto 888 nleft = nbreak iter = 1 tj = zero c------------------- the beginning of the loop ------------------------- 777 continue c     Find the next smallest breakpoint; c       compute dt = t(nleft) - t(nleft + 1). tj0 = tj if ( iter . eq . 1 ) then c         Since we already have the smallest breakpoint we need not do c         heapsort yet. Often only one breakpoint is used and the c         cost of heapsort is avoided. tj = bkmin ibp = iorder ( ibkmin ) else if ( iter . eq . 2 ) then c             Replace the already used smallest breakpoint with the c             breakpoint numbered nbreak > nlast, before heapsort call. if ( ibkmin . ne . nbreak ) then t ( ibkmin ) = t ( nbreak ) iorder ( ibkmin ) = iorder ( nbreak ) endif c        Update heap structure of breakpoints c           (if iter=2, initialize heap). endif call hpsolb ( nleft , t , iorder , iter - 2 ) tj = t ( nleft ) ibp = iorder ( nleft ) endif dt = tj - tj0 if ( dt . ne . zero . and . iprint . ge . 100 ) then write ( 6 , 4011 ) nseg , f1 , f2 write ( 6 , 5010 ) dt write ( 6 , 6010 ) dtm endif c     If a minimizer is within this interval, locate the GCP and return. if ( dtm . lt . dt ) goto 888 c     Otherwise fix one variable and c       reset the corresponding component of d to zero. tsum = tsum + dt nleft = nleft - 1 iter = iter + 1 dibp = d ( ibp ) d ( ibp ) = zero if ( dibp . gt . zero ) then zibp = u ( ibp ) - x ( ibp ) xcp ( ibp ) = u ( ibp ) iwhere ( ibp ) = 2 else zibp = l ( ibp ) - x ( ibp ) xcp ( ibp ) = l ( ibp ) iwhere ( ibp ) = 1 endif if ( iprint . ge . 100 ) write ( 6 , * ) 'Variable  ' , ibp , '  is fixed.' if ( nleft . eq . 0 . and . nbreak . eq . n ) then c                                             all n variables are fixed, c                                                return with xcp as GCP. dtm = dt goto 999 endif c     Update the derivative information. nseg = nseg + 1 dibp2 = dibp ** 2 c     Update f1 and f2. c        temporarily set f1 and f2 for col=0. f1 = f1 + dt * f2 + dibp2 - theta * dibp * zibp f2 = f2 - theta * dibp2 if ( col . gt . 0 ) then c                          update c = c + dt*p. call daxpy ( col2 , dt , p , 1 , c , 1 ) c           choose wbp, c           the row of W corresponding to the breakpoint encountered. pointr = head do 70 j = 1 , col wbp ( j ) = wy ( ibp , pointr ) wbp ( col + j ) = theta * ws ( ibp , pointr ) pointr = mod ( pointr , m ) + 1 70 continue c           compute (wbp)Mc, (wbp)Mp, and (wbp)M(wbp)'. call bmv ( m , sy , wt , col , wbp , v , info ) if ( info . ne . 0 ) return wmc = ddot ( col2 , c , 1 , v , 1 ) wmp = ddot ( col2 , p , 1 , v , 1 ) wmw = ddot ( col2 , wbp , 1 , v , 1 ) c           update p = p - dibp*wbp. call daxpy ( col2 , - dibp , wbp , 1 , p , 1 ) c           complete updating f1 and f2 while col > 0. f1 = f1 + dibp * wmc f2 = f2 + 2.0d0 * dibp * wmp - dibp2 * wmw endif f2 = max ( epsmch * f2_org , f2 ) if ( nleft . gt . 0 ) then dtm = - f1 / f2 goto 777 c                 to repeat the loop for unsearched intervals. else if ( bnded ) then f1 = zero f2 = zero dtm = zero else dtm = - f1 / f2 endif c------------------- the end of the loop ------------------------------- 888 continue if ( iprint . ge . 99 ) then write ( 6 , * ) write ( 6 , * ) 'GCP found in this segment' write ( 6 , 4010 ) nseg , f1 , f2 write ( 6 , 6010 ) dtm endif if ( dtm . le . zero ) dtm = zero tsum = tsum + dtm c     Move free variables (i.e., the ones w/o breakpoints) and c       the variables whose breakpoints haven't been reached. call daxpy ( n , tsum , d , 1 , xcp , 1 ) 999 continue c     Update c = c + dtm*p = W'(x&#94;c - x) c       which will be used in computing r = Z'(B(x&#94;c - x) + g). if ( col . gt . 0 ) call daxpy ( col2 , dtm , p , 1 , c , 1 ) if ( iprint . gt . 100 ) write ( 6 , 1010 ) ( xcp ( i ), i = 1 , n ) if ( iprint . ge . 99 ) write ( 6 , 2010 ) 1010 format ( 'Cauchy X =  ' , / ,( 4 x , 1 p , 6 ( 1 x , d11 . 4 ))) 2010 format ( / , '---------------- exit CAUCHY----------------------' , / ) 3010 format ( / , '---------------- CAUCHY entered-------------------' ) 4010 format ( 'Piece    ' , i3 , ' --f1, f2 at start point ' , 1 p , 2 ( 1 x , d11 . 4 )) 4011 format ( / , 'Piece    ' , i3 , ' --f1, f2 at start point ' , + 1 p , 2 ( 1 x , d11 . 4 )) 5010 format ( 'Distance to the next break point =  ' , 1 p , d11 . 4 ) 6010 format ( 'Distance to the stationary point =  ' , 1 p , d11 . 4 ) return end c====================== The end of cauchy ============================== subroutine cmprlb ( n , m , x , g , ws , wy , sy , wt , z , r , wa , index , + theta , col , head , nfree , cnstnd , info ) logical cnstnd integer n , m , col , head , nfree , info , index ( n ) double precision theta , + x ( n ), g ( n ), z ( n ), r ( n ), wa ( 4 * m ), + ws ( n , m ), wy ( n , m ), sy ( m , m ), wt ( m , m ) c     ************ c c     Subroutine cmprlb c c       This subroutine computes r=-Z'B(xcp-xk)-Z'g by using c         wa(2m+1)=W'(xcp-x) from subroutine cauchy. c c     Subprograms called: c c       L-BFGS-B Library ... bmv. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer i , j , k , pointr double precision a1 , a2 if (. not . cnstnd . and . col . gt . 0 ) then do 26 i = 1 , n r ( i ) = - g ( i ) 26 continue else do 30 i = 1 , nfree k = index ( i ) r ( i ) = - theta * ( z ( k ) - x ( k )) - g ( k ) 30 continue call bmv ( m , sy , wt , col , wa ( 2 * m + 1 ), wa ( 1 ), info ) if ( info . ne . 0 ) then info = - 8 return endif pointr = head do 34 j = 1 , col a1 = wa ( j ) a2 = theta * wa ( col + j ) do 32 i = 1 , nfree k = index ( i ) r ( i ) = r ( i ) + wy ( k , pointr ) * a1 + ws ( k , pointr ) * a2 32 continue pointr = mod ( pointr , m ) + 1 34 continue endif return end c======================= The end of cmprlb ============================= subroutine errclb ( n , m , factr , l , u , nbd , task , info , k ) character * 60 task integer n , m , info , k , nbd ( n ) double precision factr , l ( n ), u ( n ) c     ************ c c     Subroutine errclb c c     This subroutine checks the validity of the input data. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer i double precision one , zero parameter ( one = 1.0d0 , zero = 0.0d0 ) c     Check the input arguments for errors. if ( n . le . 0 ) task = 'ERROR: N .LE. 0' if ( m . le . 0 ) task = 'ERROR: M .LE. 0' if ( factr . lt . zero ) task = 'ERROR: FACTR .LT. 0' c     Check the validity of the arrays nbd(i), u(i), and l(i). do 10 i = 1 , n if ( nbd ( i ) . lt . 0 . or . nbd ( i ) . gt . 3 ) then c                                                   return task = 'ERROR: INVALID NBD' info = - 6 k = i endif if ( nbd ( i ) . eq . 2 ) then if ( l ( i ) . gt . u ( i )) then c                                    return task = 'ERROR: NO FEASIBLE SOLUTION' info = - 7 k = i endif endif 10 continue return end c======================= The end of errclb ============================= subroutine formk ( n , nsub , ind , nenter , ileave , indx2 , iupdat , + updatd , wn , wn1 , m , ws , wy , sy , theta , col , + head , info ) integer n , nsub , m , col , head , nenter , ileave , iupdat , + info , ind ( n ), indx2 ( n ) double precision theta , wn ( 2 * m , 2 * m ), wn1 ( 2 * m , 2 * m ), + ws ( n , m ), wy ( n , m ), sy ( m , m ) logical updatd c     ************ c c     Subroutine formk c c     This subroutine forms  the LEL&#94;T factorization of the indefinite c c       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ] c                     [L_a -R_z           theta*S'AA'S ] c                                                    where E = [-I  0] c                                                              [ 0  I] c     The matrix K can be shown to be equal to the matrix M&#94;[-1]N c       occurring in section 5.1 of [1], as well as to the matrix c       Mbar&#94;[-1] Nbar in section 5.3. c c     n is an integer variable. c       On entry n is the dimension of the problem. c       On exit n is unchanged. c c     nsub is an integer variable c       On entry nsub is the number of subspace variables in free set. c       On exit nsub is not changed. c c     ind is an integer array of dimension nsub. c       On entry ind specifies the indices of subspace variables. c       On exit ind is unchanged. c c     nenter is an integer variable. c       On entry nenter is the number of variables entering the c         free set. c       On exit nenter is unchanged. c c     ileave is an integer variable. c       On entry indx2(ileave),...,indx2(n) are the variables leaving c         the free set. c       On exit ileave is unchanged. c c     indx2 is an integer array of dimension n. c       On entry indx2(1),...,indx2(nenter) are the variables entering c         the free set, while indx2(ileave),...,indx2(n) are the c         variables leaving the free set. c       On exit indx2 is unchanged. c c     iupdat is an integer variable. c       On entry iupdat is the total number of BFGS updates made so far. c       On exit iupdat is unchanged. c c     updatd is a logical variable. c       On entry 'updatd' is true if the L-BFGS matrix is updatd. c       On exit 'updatd' is unchanged. c c     wn is a double precision array of dimension 2m x 2m. c       On entry wn is unspecified. c       On exit the upper triangle of wn stores the LEL&#94;T factorization c         of the 2*col x 2*col indefinite matrix c                     [-D -Y'ZZ'Y/theta     L_a'-R_z'  ] c                     [L_a -R_z           theta*S'AA'S ] c c     wn1 is a double precision array of dimension 2m x 2m. c       On entry wn1 stores the lower triangular part of c                     [Y' ZZ'Y   L_a'+R_z'] c                     [L_a+R_z   S'AA'S   ] c         in the previous iteration. c       On exit wn1 stores the corresponding updated matrices. c       The purpose of wn1 is just to store these inner products c       so they can be easily updated and inserted into wn. c c     m is an integer variable. c       On entry m is the maximum number of variable metric corrections c         used to define the limited memory matrix. c       On exit m is unchanged. c c     ws, wy, sy, and wtyy are double precision arrays; c     theta is a double precision variable; c     col is an integer variable; c     head is an integer variable. c       On entry they store the information defining the c                                          limited memory BFGS matrix: c         ws(n,m) stores S, a set of s-vectors; c         wy(n,m) stores Y, a set of y-vectors; c         sy(m,m) stores S'Y; c         wtyy(m,m) stores the Cholesky factorization c                                   of (theta*S'S+LD&#94;(-1)L') c         theta is the scaling factor specifying B_0 = theta I; c         col is the number of variable metric corrections stored; c         head is the location of the 1st s- (or y-) vector in S (or Y). c       On exit they are unchanged. c c     info is an integer variable. c       On entry info is unspecified. c       On exit info =  0 for normal return; c                    = -1 when the 1st Cholesky factorization failed; c                    = -2 when the 2st Cholesky factorization failed. c c     Subprograms called: c c       Linpack ... dcopy, dpofa, dtrsl. c c c     References: c       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited c       memory algorithm for bound constrained optimization'', c       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. c c       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a c       limited memory FORTRAN code for solving bound constrained c       optimization problems'', Tech. Report, NAM-11, EECS Department, c       Northwestern University, 1994. c c       (Postscript files of these papers are available via anonymous c        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.) c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer m2 , ipntr , jpntr , iy , is , jy , js , is1 , js1 , k1 , i , k , + col2 , pbegin , pend , dbegin , dend , upcl double precision ddot , temp1 , temp2 , temp3 , temp4 double precision one , zero parameter ( one = 1.0d0 , zero = 0.0d0 ) c     Form the lower triangular part of c               WN1 = [Y' ZZ'Y   L_a'+R_z'] c                     [L_a+R_z   S'AA'S   ] c        where L_a is the strictly lower triangular part of S'AA'Y c              R_z is the upper triangular part of S'ZZ'Y. if ( updatd ) then if ( iupdat . gt . m ) then c                                 shift old part of WN1. do 10 jy = 1 , m - 1 js = m + jy call dcopy ( m - jy , wn1 ( jy + 1 , jy + 1 ), 1 , wn1 ( jy , jy ), 1 ) call dcopy ( m - jy , wn1 ( js + 1 , js + 1 ), 1 , wn1 ( js , js ), 1 ) call dcopy ( m - 1 , wn1 ( m + 2 , jy + 1 ), 1 , wn1 ( m + 1 , jy ), 1 ) 10 continue endif c          put new rows in blocks (1,1), (2,1) and (2,2). pbegin = 1 pend = nsub dbegin = nsub + 1 dend = n iy = col is = m + col ipntr = head + col - 1 if ( ipntr . gt . m ) ipntr = ipntr - m jpntr = head do 20 jy = 1 , col js = m + jy temp1 = zero temp2 = zero temp3 = zero c             compute element jy of row 'col' of Y'ZZ'Y do 15 k = pbegin , pend k1 = ind ( k ) temp1 = temp1 + wy ( k1 , ipntr ) * wy ( k1 , jpntr ) 15 continue c             compute elements jy of row 'col' of L_a and S'AA'S do 16 k = dbegin , dend k1 = ind ( k ) temp2 = temp2 + ws ( k1 , ipntr ) * ws ( k1 , jpntr ) temp3 = temp3 + ws ( k1 , ipntr ) * wy ( k1 , jpntr ) 16 continue wn1 ( iy , jy ) = temp1 wn1 ( is , js ) = temp2 wn1 ( is , jy ) = temp3 jpntr = mod ( jpntr , m ) + 1 20 continue c          put new column in block (2,1). jy = col jpntr = head + col - 1 if ( jpntr . gt . m ) jpntr = jpntr - m ipntr = head do 30 i = 1 , col is = m + i temp3 = zero c             compute element i of column 'col' of R_z do 25 k = pbegin , pend k1 = ind ( k ) temp3 = temp3 + ws ( k1 , ipntr ) * wy ( k1 , jpntr ) 25 continue ipntr = mod ( ipntr , m ) + 1 wn1 ( is , jy ) = temp3 30 continue upcl = col - 1 else upcl = col endif c       modify the old parts in blocks (1,1) and (2,2) due to changes c       in the set of free variables. ipntr = head do 45 iy = 1 , upcl is = m + iy jpntr = head do 40 jy = 1 , iy js = m + jy temp1 = zero temp2 = zero temp3 = zero temp4 = zero do 35 k = 1 , nenter k1 = indx2 ( k ) temp1 = temp1 + wy ( k1 , ipntr ) * wy ( k1 , jpntr ) temp2 = temp2 + ws ( k1 , ipntr ) * ws ( k1 , jpntr ) 35 continue do 36 k = ileave , n k1 = indx2 ( k ) temp3 = temp3 + wy ( k1 , ipntr ) * wy ( k1 , jpntr ) temp4 = temp4 + ws ( k1 , ipntr ) * ws ( k1 , jpntr ) 36 continue wn1 ( iy , jy ) = wn1 ( iy , jy ) + temp1 - temp3 wn1 ( is , js ) = wn1 ( is , js ) - temp2 + temp4 jpntr = mod ( jpntr , m ) + 1 40 continue ipntr = mod ( ipntr , m ) + 1 45 continue c       modify the old parts in block (2,1). ipntr = head do 60 is = m + 1 , m + upcl jpntr = head do 55 jy = 1 , upcl temp1 = zero temp3 = zero do 50 k = 1 , nenter k1 = indx2 ( k ) temp1 = temp1 + ws ( k1 , ipntr ) * wy ( k1 , jpntr ) 50 continue do 51 k = ileave , n k1 = indx2 ( k ) temp3 = temp3 + ws ( k1 , ipntr ) * wy ( k1 , jpntr ) 51 continue if ( is . le . jy + m ) then wn1 ( is , jy ) = wn1 ( is , jy ) + temp1 - temp3 else wn1 ( is , jy ) = wn1 ( is , jy ) - temp1 + temp3 endif jpntr = mod ( jpntr , m ) + 1 55 continue ipntr = mod ( ipntr , m ) + 1 60 continue c     Form the upper triangle of WN = [D+Y' ZZ'Y/theta   -L_a'+R_z' ] c                                     [-L_a +R_z        S'AA'S*theta] m2 = 2 * m do 70 iy = 1 , col is = col + iy is1 = m + iy do 65 jy = 1 , iy js = col + jy js1 = m + jy wn ( jy , iy ) = wn1 ( iy , jy ) / theta wn ( js , is ) = wn1 ( is1 , js1 ) * theta 65 continue do 66 jy = 1 , iy - 1 wn ( jy , is ) = - wn1 ( is1 , jy ) 66 continue do 67 jy = iy , col wn ( jy , is ) = wn1 ( is1 , jy ) 67 continue wn ( iy , iy ) = wn ( iy , iy ) + sy ( iy , iy ) 70 continue c     Form the upper triangle of WN= [  LL'            L&#94;-1(-L_a'+R_z')] c                                    [(-L_a +R_z)L'&#94;-1   S'AA'S*theta  ] c        first Cholesky factor (1,1) block of wn to get LL' c                          with L' stored in the upper triangle of wn. call dpofa ( wn , m2 , col , info ) if ( info . ne . 0 ) then info = - 1 return endif c        then form L&#94;-1(-L_a'+R_z') in the (1,2) block. col2 = 2 * col do 71 js = col + 1 , col2 call dtrsl ( wn , m2 , col , wn ( 1 , js ), 11 , info ) 71 continue c     Form S'AA'S*theta + (L&#94;-1(-L_a'+R_z'))'L&#94;-1(-L_a'+R_z') in the c        upper triangle of (2,2) block of wn. do 72 is = col + 1 , col2 do 74 js = is , col2 wn ( is , js ) = wn ( is , js ) + ddot ( col , wn ( 1 , is ), 1 , wn ( 1 , js ), 1 ) 74 continue 72 continue c     Cholesky factorization of (2,2) block of wn. call dpofa ( wn ( col + 1 , col + 1 ), m2 , col , info ) if ( info . ne . 0 ) then info = - 2 return endif return end c======================= The end of formk ============================== subroutine formt ( m , wt , sy , ss , col , theta , info ) integer m , col , info double precision theta , wt ( m , m ), sy ( m , m ), ss ( m , m ) c     ************ c c     Subroutine formt c c       This subroutine forms the upper half of the pos. def. and symm. c         T = theta*SS + L*D&#94;(-1)*L', stores T in the upper triangle c         of the array wt, and performs the Cholesky factorization of T c         to produce J*J', with J' stored in the upper triangle of wt. c c     Subprograms called: c c       Linpack ... dpofa. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer i , j , k , k1 double precision ddum double precision zero parameter ( zero = 0.0d0 ) c     Form the upper half of  T = theta*SS + L*D&#94;(-1)*L', c        store T in the upper triangle of the array wt. do 52 j = 1 , col wt ( 1 , j ) = theta * ss ( 1 , j ) 52 continue do 55 i = 2 , col do 54 j = i , col k1 = min ( i , j ) - 1 ddum = zero do 53 k = 1 , k1 ddum = ddum + sy ( i , k ) * sy ( j , k ) / sy ( k , k ) 53 continue wt ( i , j ) = ddum + theta * ss ( i , j ) 54 continue 55 continue c     Cholesky factorize T to J*J' with c        J' stored in the upper triangle of wt. call dpofa ( wt , m , col , info ) if ( info . ne . 0 ) then info = - 3 endif return end c======================= The end of formt ============================== subroutine freev ( n , nfree , index , nenter , ileave , indx2 , + iwhere , wrk , updatd , cnstnd , iprint , iter ) integer n , nfree , nenter , ileave , iprint , iter , + index ( n ), indx2 ( n ), iwhere ( n ) logical wrk , updatd , cnstnd c     ************ c c     Subroutine freev c c     This subroutine counts the entering and leaving variables when c       iter > 0, and finds the index set of free and active variables c       at the GCP. c c     cnstnd is a logical variable indicating whether bounds are present c c     index is an integer array of dimension n c       for i=1,...,nfree, index(i) are the indices of free variables c       for i=nfree+1,...,n, index(i) are the indices of bound variables c       On entry after the first iteration, index gives c         the free variables at the previous iteration. c       On exit it gives the free variables based on the determination c         in cauchy using the array iwhere. c c     indx2 is an integer array of dimension n c       On entry indx2 is unspecified. c       On exit with iter>0, indx2 indicates which variables c          have changed status since the previous iteration. c       For i= 1,...,nenter, indx2(i) have changed from bound to free. c       For i= ileave+1,...,n, indx2(i) have changed from free to bound. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer iact , i , k nenter = 0 ileave = n + 1 if ( iter . gt . 0 . and . cnstnd ) then c                           count the entering and leaving variables. do 20 i = 1 , nfree k = index ( i ) c            write(6,*) ' k  = index(i) ', k c            write(6,*) ' index = ', i if ( iwhere ( k ) . gt . 0 ) then ileave = ileave - 1 indx2 ( ileave ) = k if ( iprint . ge . 100 ) write ( 6 , * ) + 'Variable ' , k , ' leaves the set of free variables' endif 20 continue do 22 i = 1 + nfree , n k = index ( i ) if ( iwhere ( k ) . le . 0 ) then nenter = nenter + 1 indx2 ( nenter ) = k if ( iprint . ge . 100 ) write ( 6 , * ) + 'Variable ' , k , ' enters the set of free variables' endif 22 continue if ( iprint . ge . 99 ) write ( 6 , * ) + n + 1 - ileave , ' variables leave; ' , nenter , ' variables enter' endif wrk = ( ileave . lt . n + 1 ) . or . ( nenter . gt . 0 ) . or . updatd c     Find the index set of free and active variables at the GCP. nfree = 0 iact = n + 1 do 24 i = 1 , n if ( iwhere ( i ) . le . 0 ) then nfree = nfree + 1 index ( nfree ) = i else iact = iact - 1 index ( iact ) = i endif 24 continue if ( iprint . ge . 99 ) write ( 6 , * ) + nfree , ' variables are free at GCP ' , iter + 1 return end c======================= The end of freev ============================== subroutine hpsolb ( n , t , iorder , iheap ) integer iheap , n , iorder ( n ) double precision t ( n ) c     ************ c c     Subroutine hpsolb c c     This subroutine sorts out the least element of t, and puts the c       remaining elements of t in a heap. c c     n is an integer variable. c       On entry n is the dimension of the arrays t and iorder. c       On exit n is unchanged. c c     t is a double precision array of dimension n. c       On entry t stores the elements to be sorted, c       On exit t(n) stores the least elements of t, and t(1) to t(n-1) c         stores the remaining elements in the form of a heap. c c     iorder is an integer array of dimension n. c       On entry iorder(i) is the index of t(i). c       On exit iorder(i) is still the index of t(i), but iorder may be c         permuted in accordance with t. c c     iheap is an integer variable specifying the task. c       On entry iheap should be set as follows: c         iheap .eq. 0 if t(1) to t(n) is not in the form of a heap, c         iheap .ne. 0 if otherwise. c       On exit iheap is unchanged. c c c     References: c       Algorithm 232 of CACM (J. W. J. Williams): HEAPSORT. c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c     ************ integer i , j , k , indxin , indxou double precision ddum , out if ( iheap . eq . 0 ) then c        Rearrange the elements t(1) to t(n) to form a heap. do 20 k = 2 , n ddum = t ( k ) indxin = iorder ( k ) c           Add ddum to the heap. i = k 10 continue if ( i . gt . 1 ) then j = i / 2 if ( ddum . lt . t ( j )) then t ( i ) = t ( j ) iorder ( i ) = iorder ( j ) i = j goto 10 endif endif t ( i ) = ddum iorder ( i ) = indxin 20 continue endif c     Assign to 'out' the value of t(1), the least member of the heap, c        and rearrange the remaining members to form a heap as c        elements 1 to n-1 of t. if ( n . gt . 1 ) then i = 1 out = t ( 1 ) indxou = iorder ( 1 ) ddum = t ( n ) indxin = iorder ( n ) c        Restore the heap 30 continue j = i + i if ( j . le . n - 1 ) then if ( t ( j + 1 ) . lt . t ( j )) j = j + 1 if ( t ( j ) . lt . ddum ) then t ( i ) = t ( j ) iorder ( i ) = iorder ( j ) i = j goto 30 endif endif t ( i ) = ddum iorder ( i ) = indxin c     Put the least member in t(n). t ( n ) = out iorder ( n ) = indxou endif return end c====================== The end of hpsolb ============================== subroutine lnsrlb ( n , l , u , nbd , x , f , fold , gd , gdold , g , d , r , t , + z , stp , dnorm , dtd , xstep , stpmx , iter , ifun , + iback , nfgv , info , task , boxed , cnstnd , csave , + isave , dsave ) character * 60 task , csave logical boxed , cnstnd integer n , iter , ifun , iback , nfgv , info , + nbd ( n ), isave ( 2 ) double precision f , fold , gd , gdold , stp , dnorm , dtd , xstep , + stpmx , x ( n ), l ( n ), u ( n ), g ( n ), d ( n ), r ( n ), t ( n ), + z ( n ), dsave ( 13 ) c     ********** c c     Subroutine lnsrlb c c     This subroutine calls subroutine dcsrch from the Minpack2 library c       to perform the line search.  Subroutine dscrch is safeguarded so c       that all trial points lie within the feasible region. c c     Subprograms called: c c       Minpack2 Library ... dcsrch. c c       Linpack ... dtrsl, ddot. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ********** integer i double precision ddot , a1 , a2 double precision one , zero , big parameter ( one = 1.0d0 , zero = 0.0d0 , big = 1.0d+10 ) double precision ftol , gtol , xtol parameter ( ftol = 1.0d-3 , gtol = 0.9d0 , xtol = 0.1d0 ) if ( task ( 1 : 5 ) . eq . 'FG_LN' ) goto 556 dtd = ddot ( n , d , 1 , d , 1 ) dnorm = sqrt ( dtd ) c     Determine the maximum step length. stpmx = big if ( cnstnd ) then if ( iter . eq . 0 ) then stpmx = one else do 43 i = 1 , n a1 = d ( i ) if ( nbd ( i ) . ne . 0 ) then if ( a1 . lt . zero . and . nbd ( i ) . le . 2 ) then a2 = l ( i ) - x ( i ) if ( a2 . ge . zero ) then stpmx = zero else if ( a1 * stpmx . lt . a2 ) then stpmx = a2 / a1 endif else if ( a1 . gt . zero . and . nbd ( i ) . ge . 2 ) then a2 = u ( i ) - x ( i ) if ( a2 . le . zero ) then stpmx = zero else if ( a1 * stpmx . gt . a2 ) then stpmx = a2 / a1 endif endif endif 43 continue endif endif if ( iter . eq . 0 . and . . not . boxed ) then stp = min ( one / dnorm , stpmx ) else stp = one endif call dcopy ( n , x , 1 , t , 1 ) call dcopy ( n , g , 1 , r , 1 ) fold = f ifun = 0 iback = 0 csave = 'START' 556 continue gd = ddot ( n , g , 1 , d , 1 ) if ( ifun . eq . 0 ) then gdold = gd if ( gd . ge . zero ) then c                               the directional derivative >=0. c                               Line search is impossible. write ( 6 , * ) ' ascent direction in projection gd = ' , gd info = - 4 return endif endif call dcsrch ( f , gd , stp , ftol , gtol , xtol , zero , stpmx , csave , isave , dsave ) xstep = stp * dnorm if ( csave ( 1 : 4 ) . ne . 'CONV' . and . csave ( 1 : 4 ) . ne . 'WARN' ) then task = 'FG_LNSRCH' ifun = ifun + 1 nfgv = nfgv + 1 iback = ifun - 1 if ( stp . eq . one ) then call dcopy ( n , z , 1 , x , 1 ) else do 41 i = 1 , n x ( i ) = stp * d ( i ) + t ( i ) 41 continue endif else task = 'NEW_X' endif return end c======================= The end of lnsrlb ============================= subroutine matupd ( n , m , ws , wy , sy , ss , d , r , itail , + iupdat , col , head , theta , rr , dr , stp , dtd ) integer n , m , itail , iupdat , col , head double precision theta , rr , dr , stp , dtd , d ( n ), r ( n ), + ws ( n , m ), wy ( n , m ), sy ( m , m ), ss ( m , m ) c     ************ c c     Subroutine matupd c c       This subroutine updates matrices WS and WY, and forms the c         middle matrix in B. c c     Subprograms called: c c       Linpack ... dcopy, ddot. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer j , pointr double precision ddot double precision one parameter ( one = 1.0d0 ) c     Set pointers for matrices WS and WY. if ( iupdat . le . m ) then col = iupdat itail = mod ( head + iupdat - 2 , m ) + 1 else itail = mod ( itail , m ) + 1 head = mod ( head , m ) + 1 endif c     Update matrices WS and WY. call dcopy ( n , d , 1 , ws ( 1 , itail ), 1 ) call dcopy ( n , r , 1 , wy ( 1 , itail ), 1 ) c     Set theta=yy/ys. theta = rr / dr c     Form the middle matrix in B. c        update the upper triangle of SS, c                                         and the lower triangle of SY: if ( iupdat . gt . m ) then c                              move old information do 50 j = 1 , col - 1 call dcopy ( j , ss ( 2 , j + 1 ), 1 , ss ( 1 , j ), 1 ) call dcopy ( col - j , sy ( j + 1 , j + 1 ), 1 , sy ( j , j ), 1 ) 50 continue endif c        add new information: the last row of SY c                                             and the last column of SS: pointr = head do 51 j = 1 , col - 1 sy ( col , j ) = ddot ( n , d , 1 , wy ( 1 , pointr ), 1 ) ss ( j , col ) = ddot ( n , ws ( 1 , pointr ), 1 , d , 1 ) pointr = mod ( pointr , m ) + 1 51 continue if ( stp . eq . one ) then ss ( col , col ) = dtd else ss ( col , col ) = stp * stp * dtd endif sy ( col , col ) = dr return end c======================= The end of matupd ============================= subroutine prn1lb ( n , m , l , u , x , iprint , itfile , epsmch ) integer n , m , iprint , itfile double precision epsmch , x ( n ), l ( n ), u ( n ) c     ************ c c     Subroutine prn1lb c c     This subroutine prints the input data, initial point, upper and c       lower bounds of each variable, machine precision, as well as c       the headings of the output. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer i if ( iprint . ge . 0 ) then write ( 6 , 7001 ) epsmch write ( 6 , * ) 'N = ' , n , '    M = ' , m if ( iprint . ge . 1 ) then write ( itfile , 2001 ) epsmch write ( itfile , * ) 'N = ' , n , '    M = ' , m write ( itfile , 9001 ) if ( iprint . gt . 100 ) then write ( 6 , 1004 ) 'L =' ,( l ( i ), i = 1 , n ) write ( 6 , 1004 ) 'X0 =' ,( x ( i ), i = 1 , n ) write ( 6 , 1004 ) 'U =' ,( u ( i ), i = 1 , n ) endif endif endif 1004 format ( / , a4 , 1 p , 6 ( 1 x , d11 . 4 ), / ,( 4 x , 1 p , 6 ( 1 x , d11 . 4 ))) 2001 format ( 'RUNNING THE L-BFGS-B CODE' , / , / , + 'it    = iteration number' , / , + 'nf    = number of function evaluations' , / , + 'nseg  = number of segments explored during the Cauchy search' , / , + 'nact  = number of active bounds at the generalized Cauchy point' + , / , + 'sub   = manner in which the subspace minimization terminated:' + , / , '        con = converged, bnd = a bound was reached' , / , + 'itls  = number of iterations performed in the line search' , / , + 'stepl = step length used' , / , + 'tstep = norm of the displacement (total step)' , / , + 'projg = norm of the projected gradient' , / , + 'f     = function value' , / , / , + '           * * *' , / , / , + 'Machine precision =' , 1 p , d10 . 3 ) 7001 format ( 'RUNNING THE L-BFGS-B CODE' , / , / , + '           * * *' , / , / , + 'Machine precision =' , 1 p , d10 . 3 ) 9001 format ( / , 3 x , 'it' , 3 x , 'nf' , 2 x , 'nseg' , 2 x , 'nact' , 2 x , 'sub' , 2 x , 'itls' , + 2 x , 'stepl' , 4 x , 'tstep' , 5 x , 'projg' , 8 x , 'f' ) return end c======================= The end of prn1lb ============================= subroutine prn2lb ( n , x , f , g , iprint , itfile , iter , nfgv , nact , + sbgnrm , nseg , word , iword , iback , stp , xstep ) character * 3 word integer n , iprint , itfile , iter , nfgv , nact , nseg , + iword , iback double precision f , sbgnrm , stp , xstep , x ( n ), g ( n ) c     ************ c c     Subroutine prn2lb c c     This subroutine prints out new information after a successful c       line search. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer i , imod c           'word' records the status of subspace solutions. if ( iword . eq . 0 ) then c                            the subspace minimization converged. word = 'con' else if ( iword . eq . 1 ) then c                          the subspace minimization stopped at a bound. word = 'bnd' else if ( iword . eq . 5 ) then c                             the truncated Newton step has been used. word = 'TNT' else word = '---' endif if ( iprint . ge . 99 ) then write ( 6 , * ) 'LINE SEARCH' , iback , ' times; norm of step = ' , xstep write ( 6 , 2001 ) iter , f , sbgnrm if ( iprint . gt . 100 ) then write ( 6 , 1004 ) 'X =' ,( x ( i ), i = 1 , n ) write ( 6 , 1004 ) 'G =' ,( g ( i ), i = 1 , n ) endif else if ( iprint . gt . 0 ) then imod = mod ( iter , iprint ) if ( imod . eq . 0 ) write ( 6 , 2001 ) iter , f , sbgnrm endif if ( iprint . ge . 1 ) write ( itfile , 3001 ) + iter , nfgv , nseg , nact , word , iback , stp , xstep , sbgnrm , f 1004 format ( / , a4 , 1 p , 6 ( 1 x , d11 . 4 ), / ,( 4 x , 1 p , 6 ( 1 x , d11 . 4 ))) 2001 format + ( / , 'At iterate' , i5 , 4 x , 'f= ' , 1 p , d12 . 5 , 4 x , '|proj g|= ' , 1 p , d12 . 5 ) 3001 format ( 2 ( 1 x , i4 ), 2 ( 1 x , i5 ), 2 x , a3 , 1 x , i4 , 1 p , 2 ( 2 x , d7 . 1 ), 1 p , 2 ( 1 x , d10 . 3 )) return end c======================= The end of prn2lb ============================= subroutine prn3lb ( n , x , f , task , iprint , info , itfile , + iter , nfgv , nintol , nskip , nact , sbgnrm , + time , nseg , word , iback , stp , xstep , k , + cachyt , sbtime , lnscht ) character * 60 task character * 3 word integer n , iprint , info , itfile , iter , nfgv , nintol , + nskip , nact , nseg , iback , k double precision f , sbgnrm , time , stp , xstep , cachyt , sbtime , + lnscht , x ( n ) c     ************ c c     Subroutine prn3lb c c     This subroutine prints out information when either a built-in c       convergence test is satisfied or when an error message is c       generated. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer i if ( task ( 1 : 5 ) . eq . 'ERROR' ) goto 999 if ( iprint . ge . 0 ) then write ( 6 , 3003 ) write ( 6 , 3004 ) write ( 6 , 3005 ) n , iter , nfgv , nintol , nskip , nact , sbgnrm , f if ( iprint . ge . 100 ) then write ( 6 , 1004 ) 'X =' ,( x ( i ), i = 1 , n ) endif if ( iprint . ge . 1 ) write ( 6 , * ) ' F =' , f endif 999 continue if ( iprint . ge . 0 ) then write ( 6 , 3009 ) task if ( info . ne . 0 ) then if ( info . eq . - 1 ) write ( 6 , 9011 ) if ( info . eq . - 2 ) write ( 6 , 9012 ) if ( info . eq . - 3 ) write ( 6 , 9013 ) if ( info . eq . - 4 ) write ( 6 , 9014 ) if ( info . eq . - 5 ) write ( 6 , 9015 ) if ( info . eq . - 6 ) write ( 6 , * ) ' Input nbd(' , k , ') is invalid.' if ( info . eq . - 7 ) + write ( 6 , * ) ' l(' , k , ') > u(' , k , ').  No feasible solution.' if ( info . eq . - 8 ) write ( 6 , 9018 ) if ( info . eq . - 9 ) write ( 6 , 9019 ) endif if ( iprint . ge . 1 ) write ( 6 , 3007 ) cachyt , sbtime , lnscht write ( 6 , 3008 ) time if ( iprint . ge . 1 ) then if ( info . eq . - 4 . or . info . eq . - 9 ) then write ( itfile , 3002 ) + iter , nfgv , nseg , nact , word , iback , stp , xstep endif write ( itfile , 3009 ) task if ( info . ne . 0 ) then if ( info . eq . - 1 ) write ( itfile , 9011 ) if ( info . eq . - 2 ) write ( itfile , 9012 ) if ( info . eq . - 3 ) write ( itfile , 9013 ) if ( info . eq . - 4 ) write ( itfile , 9014 ) if ( info . eq . - 5 ) write ( itfile , 9015 ) if ( info . eq . - 8 ) write ( itfile , 9018 ) if ( info . eq . - 9 ) write ( itfile , 9019 ) endif write ( itfile , 3008 ) time endif endif 1004 format ( / , a4 , 1 p , 6 ( 1 x , d11 . 4 ), / ,( 4 x , 1 p , 6 ( 1 x , d11 . 4 ))) 3002 format ( 2 ( 1 x , i4 ), 2 ( 1 x , i5 ), 2 x , a3 , 1 x , i4 , 1 p , 2 ( 2 x , d7 . 1 ), 6 x , '-' , 10 x , '-' ) 3003 format ( / , + '           * * *' , / , / , + 'Tit   = total number of iterations' , / , + 'Tnf   = total number of function evaluations' , / , + 'Tnint = total number of segments explored during' , + ' Cauchy searches' , / , + 'Skip  = number of BFGS updates skipped' , / , + 'Nact  = number of active bounds at final generalized' , + ' Cauchy point' , / , + 'Projg = norm of the final projected gradient' , / , + 'F     = final function value' , / , / , + '           * * *' ) 3004 format ( / , 3 x , 'N' , 4 x , 'Tit' , 5 x , 'Tnf' , 2 x , 'Tnint' , 2 x , + 'Skip' , 2 x , 'Nact' , 5 x , 'Projg' , 8 x , 'F' ) 3005 format ( i5 , 2 ( 1 x , i6 ),( 1 x , i6 ),( 2 x , i4 ),( 1 x , i5 ), 1 p , 2 ( 2 x , d10 . 3 )) 3007 format ( / , ' Cauchy                time' , 1 p , e10 . 3 , ' seconds.' , / + ' Subspace minimization time' , 1 p , e10 . 3 , ' seconds.' , / + ' Line search           time' , 1 p , e10 . 3 , ' seconds.' ) 3008 format ( / , ' Total User time' , 1 p , e10 . 3 , ' seconds.' , / ) 3009 format ( / , a60 ) 9011 format ( / , + ' Matrix in 1st Cholesky factorization in formk is not Pos. Def.' ) 9012 format ( / , + ' Matrix in 2st Cholesky factorization in formk is not Pos. Def.' ) 9013 format ( / , + ' Matrix in the Cholesky factorization in formt is not Pos. Def.' ) 9014 format ( / , + ' Derivative >= 0, backtracking line search impossible.' , / , + '   Previous x, f and g restored.' , / , + ' Possible causes: 1 error in function or gradient evaluation;' , / , + '                  2 rounding errors dominate computation.' ) 9015 format ( / , + ' Warning:  more than 10 function and gradient' , / , + '   evaluations in the last line search.  Termination' , / , + '   may possibly be caused by a bad search direction.' ) 9018 format ( / , ' The triangular system is singular.' ) 9019 format ( / , + ' Line search cannot locate an adequate point after 20 function' , / + , '  and gradient evaluations.  Previous x, f and g restored.' , / , + ' Possible causes: 1 error in function or gradient evaluation;' , / , + '                  2 rounding error dominate computation.' ) return end c======================= The end of prn3lb ============================= subroutine projgr ( n , l , u , nbd , x , g , sbgnrm ) integer n , nbd ( n ) double precision sbgnrm , x ( n ), l ( n ), u ( n ), g ( n ) c     ************ c c     Subroutine projgr c c     This subroutine computes the infinity norm of the projected c       gradient. c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer i double precision gi double precision one , zero parameter ( one = 1.0d0 , zero = 0.0d0 ) sbgnrm = zero do 15 i = 1 , n gi = g ( i ) if ( nbd ( i ) . ne . 0 ) then if ( gi . lt . zero ) then if ( nbd ( i ) . ge . 2 ) gi = max (( x ( i ) - u ( i )), gi ) else if ( nbd ( i ) . le . 2 ) gi = min (( x ( i ) - l ( i )), gi ) endif endif sbgnrm = max ( sbgnrm , abs ( gi )) 15 continue return end c======================= The end of projgr ============================= subroutine subsm ( n , m , nsub , ind , l , u , nbd , x , d , xp , ws , wy , + theta , xx , gg , + col , head , iword , wv , wn , iprint , info ) implicit none integer n , m , nsub , col , head , iword , iprint , info , + ind ( nsub ), nbd ( n ) double precision theta , + l ( n ), u ( n ), x ( n ), d ( n ), xp ( n ), xx ( n ), gg ( n ), + ws ( n , m ), wy ( n , m ), + wv ( 2 * m ), wn ( 2 * m , 2 * m ) c     ********************************************************************** c c     This routine contains the major changes in the updated version. c     The changes are described in the accompanying paper c c      Jose Luis Morales, Jorge Nocedal c      \"Remark On Algorithm 788: L-BFGS-B: Fortran Subroutines for Large-Scale c       Bound Constrained Optimization\". Decemmber 27, 2010. c c             J.L. Morales  Departamento de Matematicas, c                           Instituto Tecnologico Autonomo de Mexico c                           Mexico D.F. c c             J, Nocedal    Department of Electrical Engineering and c                           Computer Science. c                           Northwestern University. Evanston, IL. USA c c                           January 17, 2011 c c      ********************************************************************** c c c     Subroutine subsm c c     Given xcp, l, u, r, an index set that specifies c       the active set at xcp, and an l-BFGS matrix B c       (in terms of WY, WS, SY, WT, head, col, and theta), c       this subroutine computes an approximate solution c       of the subspace problem c c       (P)   min Q(x) = r'(x-xcp) + 1/2 (x-xcp)' B (x-xcp) c c             subject to l<=x<=u c                       x_i=xcp_i for all i in A(xcp) c c       along the subspace unconstrained Newton direction c c          d = -(Z'BZ)&#94;(-1) r. c c       The formula for the Newton direction, given the L-BFGS matrix c       and the Sherman-Morrison formula, is c c          d = (1/theta)r + (1/theta*2) Z'WK&#94;(-1)W'Z r. c c       where c                 K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ] c                     [L_a -R_z           theta*S'AA'S ] c c     Note that this procedure for computing d differs c     from that described in [1]. One can show that the matrix K is c     equal to the matrix M&#94;[-1]N in that paper. c c     n is an integer variable. c       On entry n is the dimension of the problem. c       On exit n is unchanged. c c     m is an integer variable. c       On entry m is the maximum number of variable metric corrections c         used to define the limited memory matrix. c       On exit m is unchanged. c c     nsub is an integer variable. c       On entry nsub is the number of free variables. c       On exit nsub is unchanged. c c     ind is an integer array of dimension nsub. c       On entry ind specifies the coordinate indices of free variables. c       On exit ind is unchanged. c c     l is a double precision array of dimension n. c       On entry l is the lower bound of x. c       On exit l is unchanged. c c     u is a double precision array of dimension n. c       On entry u is the upper bound of x. c       On exit u is unchanged. c c     nbd is a integer array of dimension n. c       On entry nbd represents the type of bounds imposed on the c         variables, and must be specified as follows: c         nbd(i)=0 if x(i) is unbounded, c                1 if x(i) has only a lower bound, c                2 if x(i) has both lower and upper bounds, and c                3 if x(i) has only an upper bound. c       On exit nbd is unchanged. c c     x is a double precision array of dimension n. c       On entry x specifies the Cauchy point xcp. c       On exit x(i) is the minimizer of Q over the subspace of c                                                        free variables. c c     d is a double precision array of dimension n. c       On entry d is the reduced gradient of Q at xcp. c       On exit d is the Newton direction of Q. c c    xp is a double precision array of dimension n. c       used to safeguard the projected Newton direction c c    xx is a double precision array of dimension n c       On entry it holds the current iterate c       On output it is unchanged c    gg is a double precision array of dimension n c       On entry it holds the gradient at the current iterate c       On output it is unchanged c c     ws and wy are double precision arrays; c     theta is a double precision variable; c     col is an integer variable; c     head is an integer variable. c       On entry they store the information defining the c                                          limited memory BFGS matrix: c         ws(n,m) stores S, a set of s-vectors; c         wy(n,m) stores Y, a set of y-vectors; c         theta is the scaling factor specifying B_0 = theta I; c         col is the number of variable metric corrections stored; c         head is the location of the 1st s- (or y-) vector in S (or Y). c       On exit they are unchanged. c c     iword is an integer variable. c       On entry iword is unspecified. c       On exit iword specifies the status of the subspace solution. c         iword = 0 if the solution is in the box, c                 1 if some bound is encountered. c c     wv is a double precision working array of dimension 2m. c c     wn is a double precision array of dimension 2m x 2m. c       On entry the upper triangle of wn stores the LEL&#94;T factorization c         of the indefinite matrix c c              K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ] c                  [L_a -R_z           theta*S'AA'S ] c                                                    where E = [-I  0] c                                                              [ 0  I] c       On exit wn is unchanged. c c     iprint is an INTEGER variable that must be set by the user. c       It controls the frequency and type of output generated: c        iprint<0    no output is generated; c        iprint=0    print only one line at the last iteration; c        0<iprint<99 print also f and |proj g| every iprint iterations; c        iprint=99   print details of every iteration except n-vectors; c        iprint=100  print also the changes of active set and final x; c        iprint>100  print details of every iteration including x and g; c       When iprint > 0, the file iterate.dat will be created to c                        summarize the iteration. c c     info is an integer variable. c       On entry info is unspecified. c       On exit info = 0       for normal return, c                    = nonzero for abnormal return c                                  when the matrix K is ill-conditioned. c c     Subprograms called: c c       Linpack dtrsl. c c c     References: c c       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited c       memory algorithm for bound constrained optimization'', c       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. c c c c                           *  *  * c c     NEOS, November 1994. (Latest revision June 1996.) c     Optimization Technology Center. c     Argonne National Laboratory and Northwestern University. c     Written by c                        Ciyou Zhu c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. c c c     ************ integer pointr , m2 , col2 , ibd , jy , js , i , j , k double precision alpha , xk , dk , temp1 , temp2 double precision one , zero parameter ( one = 1.0d0 , zero = 0.0d0 ) c double precision dd_p if ( nsub . le . 0 ) return if ( iprint . ge . 99 ) write ( 6 , 1001 ) c     Compute wv = W'Zd. pointr = head do 20 i = 1 , col temp1 = zero temp2 = zero do 10 j = 1 , nsub k = ind ( j ) temp1 = temp1 + wy ( k , pointr ) * d ( j ) temp2 = temp2 + ws ( k , pointr ) * d ( j ) 10 continue wv ( i ) = temp1 wv ( col + i ) = theta * temp2 pointr = mod ( pointr , m ) + 1 20 continue c     Compute wv:=K&#94;(-1)wv. m2 = 2 * m col2 = 2 * col call dtrsl ( wn , m2 , col2 , wv , 11 , info ) if ( info . ne . 0 ) return do 25 i = 1 , col wv ( i ) = - wv ( i ) 25 continue call dtrsl ( wn , m2 , col2 , wv , 01 , info ) if ( info . ne . 0 ) return c     Compute d = (1/theta)d + (1/theta**2)Z'W wv. pointr = head do 40 jy = 1 , col js = col + jy do 30 i = 1 , nsub k = ind ( i ) d ( i ) = d ( i ) + wy ( k , pointr ) * wv ( jy ) / theta + + ws ( k , pointr ) * wv ( js ) 30 continue pointr = mod ( pointr , m ) + 1 40 continue call dscal ( nsub , one / theta , d , 1 ) c c----------------------------------------------------------------- c     Let us try the projection, d is the Newton direction iword = 0 call dcopy ( n , x , 1 , xp , 1 ) c do 50 i = 1 , nsub k = ind ( i ) dk = d ( i ) xk = x ( k ) if ( nbd ( k ) . ne . 0 ) then c if ( nbd ( k ). eq . 1 ) then ! lower bounds only x ( k ) = max ( l ( k ), xk + dk ) if ( x ( k ). eq . l ( k ) ) iword = 1 else c if ( nbd ( k ). eq . 2 ) then ! upper and lower bounds xk = max ( l ( k ), xk + dk ) x ( k ) = min ( u ( k ), xk ) if ( x ( k ). eq . l ( k ) . or . x ( k ). eq . u ( k ) ) iword = 1 else c if ( nbd ( k ). eq . 3 ) then ! upper bounds only x ( k ) = min ( u ( k ), xk + dk ) if ( x ( k ). eq . u ( k ) ) iword = 1 end if end if end if c else ! free variables x ( k ) = xk + dk end if 50 continue c if ( iword . eq . 0 ) then go to 911 end if c c     check sign of the directional derivative c dd_p = zero do 55 i = 1 , n dd_p = dd_p + ( x ( i ) - xx ( i )) * gg ( i ) 55 continue if ( dd_p . gt . zero ) then call dcopy ( n , xp , 1 , x , 1 ) if ( iprint . ne . - 1 ) then write ( 6 , * ) ' Positive dir derivative in projection ' write ( 6 , * ) ' Using the backtracking step ' end if else go to 911 endif c c----------------------------------------------------------------- c alpha = one temp1 = alpha ibd = 0 do 60 i = 1 , nsub k = ind ( i ) dk = d ( i ) if ( nbd ( k ) . ne . 0 ) then if ( dk . lt . zero . and . nbd ( k ) . le . 2 ) then temp2 = l ( k ) - x ( k ) if ( temp2 . ge . zero ) then temp1 = zero else if ( dk * alpha . lt . temp2 ) then temp1 = temp2 / dk endif else if ( dk . gt . zero . and . nbd ( k ) . ge . 2 ) then temp2 = u ( k ) - x ( k ) if ( temp2 . le . zero ) then temp1 = zero else if ( dk * alpha . gt . temp2 ) then temp1 = temp2 / dk endif endif if ( temp1 . lt . alpha ) then alpha = temp1 ibd = i endif endif 60 continue if ( alpha . lt . one ) then dk = d ( ibd ) k = ind ( ibd ) if ( dk . gt . zero ) then x ( k ) = u ( k ) d ( ibd ) = zero else if ( dk . lt . zero ) then x ( k ) = l ( k ) d ( ibd ) = zero endif endif do 70 i = 1 , nsub k = ind ( i ) x ( k ) = x ( k ) + alpha * d ( i ) 70 continue cccccc 911 continue if ( iprint . ge . 99 ) write ( 6 , 1004 ) 1001 format ( / , '----------------SUBSM entered-----------------' , / ) 1004 format ( / , '----------------exit SUBSM --------------------' , / ) return end c====================== The end of subsm =============================== subroutine dcsrch ( f , g , stp , ftol , gtol , xtol , stpmin , stpmax , + task , isave , dsave ) character * ( * ) task integer isave ( 2 ) double precision f , g , stp , ftol , gtol , xtol , stpmin , stpmax double precision dsave ( 13 ) c     ********** c c     Subroutine dcsrch c c     This subroutine finds a step that satisfies a sufficient c     decrease condition and a curvature condition. c c     Each call of the subroutine updates an interval with c     endpoints stx and sty. The interval is initially chosen c     so that it contains a minimizer of the modified function c c           psi(stp) = f(stp) - f(0) - ftol*stp*f'(0). c c     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the c     interval is chosen so that it contains a minimizer of f. c c     The algorithm is designed to find a step that satisfies c     the sufficient decrease condition c c           f(stp) <= f(0) + ftol*stp*f'(0), c c     and the curvature condition c c           abs(f'(stp)) <= gtol*abs(f'(0)). c c     If ftol is less than gtol and if, for example, the function c     is bounded below, then there is always a step which satisfies c     both conditions. c c     If no step can be found that satisfies both conditions, then c     the algorithm stops with a warning. In this case stp only c     satisfies the sufficient decrease condition. c c     A typical invocation of dcsrch has the following outline: c c     task = 'START' c  10 continue c        call dcsrch( ... ) c        if (task .eq. 'FG') then c           Evaluate the function and the gradient at stp c           goto 10 c           end if c c     NOTE: The user must no alter work arrays between calls. c c     The subroutine statement is c c        subroutine dcsrch(f,g,stp,ftol,gtol,xtol,stpmin,stpmax, c                          task,isave,dsave) c     where c c       f is a double precision variable. c         On initial entry f is the value of the function at 0. c            On subsequent entries f is the value of the c            function at stp. c         On exit f is the value of the function at stp. c c       g is a double precision variable. c         On initial entry g is the derivative of the function at 0. c            On subsequent entries g is the derivative of the c            function at stp. c         On exit g is the derivative of the function at stp. c c       stp is a double precision variable. c         On entry stp is the current estimate of a satisfactory c            step. On initial entry, a positive initial estimate c            must be provided. c         On exit stp is the current estimate of a satisfactory step c            if task = 'FG'. If task = 'CONV' then stp satisfies c            the sufficient decrease and curvature condition. c c       ftol is a double precision variable. c         On entry ftol specifies a nonnegative tolerance for the c            sufficient decrease condition. c         On exit ftol is unchanged. c c       gtol is a double precision variable. c         On entry gtol specifies a nonnegative tolerance for the c            curvature condition. c         On exit gtol is unchanged. c c       xtol is a double precision variable. c         On entry xtol specifies a nonnegative relative tolerance c            for an acceptable step. The subroutine exits with a c            warning if the relative difference between sty and stx c            is less than xtol. c         On exit xtol is unchanged. c c       stpmin is a double precision variable. c         On entry stpmin is a nonnegative lower bound for the step. c         On exit stpmin is unchanged. c c       stpmax is a double precision variable. c         On entry stpmax is a nonnegative upper bound for the step. c         On exit stpmax is unchanged. c c       task is a character variable of length at least 60. c         On initial entry task must be set to 'START'. c         On exit task indicates the required action: c c            If task(1:2) = 'FG' then evaluate the function and c            derivative at stp and call dcsrch again. c c            If task(1:4) = 'CONV' then the search is successful. c c            If task(1:4) = 'WARN' then the subroutine is not able c            to satisfy the convergence conditions. The exit value of c            stp contains the best point found during the search. c c            If task(1:5) = 'ERROR' then there is an error in the c            input arguments. c c         On exit with convergence, a warning or an error, the c            variable task contains additional information. c c       isave is an integer work array of dimension 2. c c       dsave is a double precision work array of dimension 13. c c     Subprograms called c c       MINPACK-2 ... dcstep c c     MINPACK-1 Project. June 1983. c     Argonne National Laboratory. c     Jorge J. More' and David J. Thuente. c c     MINPACK-2 Project. October 1993. c     Argonne National Laboratory and University of Minnesota. c     Brett M. Averick, Richard G. Carter, and Jorge J. More'. c c     ********** double precision zero , p5 , p66 parameter ( zero = 0.0d0 , p5 = 0.5d0 , p66 = 0.66d0 ) double precision xtrapl , xtrapu parameter ( xtrapl = 1.1d0 , xtrapu = 4.0d0 ) logical brackt integer stage double precision finit , ftest , fm , fx , fxm , fy , fym , ginit , gtest , + gm , gx , gxm , gy , gym , stx , sty , stmin , stmax , width , width1 c     Initialization block. if ( task ( 1 : 5 ) . eq . 'START' ) then c        Check the input arguments for errors. if ( stp . lt . stpmin ) task = 'ERROR: STP .LT. STPMIN' if ( stp . gt . stpmax ) task = 'ERROR: STP .GT. STPMAX' if ( g . ge . zero ) task = 'ERROR: INITIAL G .GE. ZERO' if ( ftol . lt . zero ) task = 'ERROR: FTOL .LT. ZERO' if ( gtol . lt . zero ) task = 'ERROR: GTOL .LT. ZERO' if ( xtol . lt . zero ) task = 'ERROR: XTOL .LT. ZERO' if ( stpmin . lt . zero ) task = 'ERROR: STPMIN .LT. ZERO' if ( stpmax . lt . stpmin ) task = 'ERROR: STPMAX .LT. STPMIN' c        Exit if there are errors on input. if ( task ( 1 : 5 ) . eq . 'ERROR' ) return c        Initialize local variables. brackt = . false . stage = 1 finit = f ginit = g gtest = ftol * ginit width = stpmax - stpmin width1 = width / p5 c        The variables stx, fx, gx contain the values of the step, c        function, and derivative at the best step. c        The variables sty, fy, gy contain the value of the step, c        function, and derivative at sty. c        The variables stp, f, g contain the values of the step, c        function, and derivative at stp. stx = zero fx = finit gx = ginit sty = zero fy = finit gy = ginit stmin = zero stmax = stp + xtrapu * stp task = 'FG' goto 1000 else c        Restore local variables. if ( isave ( 1 ) . eq . 1 ) then brackt = . true . else brackt = . false . endif stage = isave ( 2 ) ginit = dsave ( 1 ) gtest = dsave ( 2 ) gx = dsave ( 3 ) gy = dsave ( 4 ) finit = dsave ( 5 ) fx = dsave ( 6 ) fy = dsave ( 7 ) stx = dsave ( 8 ) sty = dsave ( 9 ) stmin = dsave ( 10 ) stmax = dsave ( 11 ) width = dsave ( 12 ) width1 = dsave ( 13 ) endif c     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the c     algorithm enters the second stage. ftest = finit + stp * gtest if ( stage . eq . 1 . and . f . le . ftest . and . g . ge . zero ) + stage = 2 c     Test for warnings. if ( brackt . and . ( stp . le . stmin . or . stp . ge . stmax )) + task = 'WARNING: ROUNDING ERRORS PREVENT PROGRESS' if ( brackt . and . stmax - stmin . le . xtol * stmax ) + task = 'WARNING: XTOL TEST SATISFIED' if ( stp . eq . stpmax . and . f . le . ftest . and . g . le . gtest ) + task = 'WARNING: STP = STPMAX' if ( stp . eq . stpmin . and . ( f . gt . ftest . or . g . ge . gtest )) + task = 'WARNING: STP = STPMIN' c     Test for convergence. if ( f . le . ftest . and . abs ( g ) . le . gtol * ( - ginit )) + task = 'CONVERGENCE' c     Test for termination. if ( task ( 1 : 4 ) . eq . 'WARN' . or . task ( 1 : 4 ) . eq . 'CONV' ) goto 1000 c     A modified function is used to predict the step during the c     first stage if a lower function value has been obtained but c     the decrease is not sufficient. if ( stage . eq . 1 . and . f . le . fx . and . f . gt . ftest ) then c        Define the modified function and derivative values. fm = f - stp * gtest fxm = fx - stx * gtest fym = fy - sty * gtest gm = g - gtest gxm = gx - gtest gym = gy - gtest c        Call dcstep to update stx, sty, and to compute the new step. call dcstep ( stx , fxm , gxm , sty , fym , gym , stp , fm , gm , + brackt , stmin , stmax ) c        Reset the function and derivative values for f. fx = fxm + stx * gtest fy = fym + sty * gtest gx = gxm + gtest gy = gym + gtest else c       Call dcstep to update stx, sty, and to compute the new step. call dcstep ( stx , fx , gx , sty , fy , gy , stp , f , g , + brackt , stmin , stmax ) endif c     Decide if a bisection step is needed. if ( brackt ) then if ( abs ( sty - stx ) . ge . p66 * width1 ) stp = stx + p5 * ( sty - stx ) width1 = width width = abs ( sty - stx ) endif c     Set the minimum and maximum steps allowed for stp. if ( brackt ) then stmin = min ( stx , sty ) stmax = max ( stx , sty ) else stmin = stp + xtrapl * ( stp - stx ) stmax = stp + xtrapu * ( stp - stx ) endif c     Force the step to be within the bounds stpmax and stpmin. stp = max ( stp , stpmin ) stp = min ( stp , stpmax ) c     If further progress is not possible, let stp be the best c     point obtained during the search. if ( brackt . and . ( stp . le . stmin . or . stp . ge . stmax ) + . or . ( brackt . and . stmax - stmin . le . xtol * stmax )) stp = stx c     Obtain another function and derivative. task = 'FG' 1000 continue c     Save local variables. if ( brackt ) then isave ( 1 ) = 1 else isave ( 1 ) = 0 endif isave ( 2 ) = stage dsave ( 1 ) = ginit dsave ( 2 ) = gtest dsave ( 3 ) = gx dsave ( 4 ) = gy dsave ( 5 ) = finit dsave ( 6 ) = fx dsave ( 7 ) = fy dsave ( 8 ) = stx dsave ( 9 ) = sty dsave ( 10 ) = stmin dsave ( 11 ) = stmax dsave ( 12 ) = width dsave ( 13 ) = width1 return end c====================== The end of dcsrch ============================== subroutine dcstep ( stx , fx , dx , sty , fy , dy , stp , fp , dp , brackt , + stpmin , stpmax ) logical brackt double precision stx , fx , dx , sty , fy , dy , stp , fp , dp , stpmin , stpmax c     ********** c c     Subroutine dcstep c c     This subroutine computes a safeguarded step for a search c     procedure and updates an interval that contains a step that c     satisfies a sufficient decrease and a curvature condition. c c     The parameter stx contains the step with the least function c     value. If brackt is set to .true. then a minimizer has c     been bracketed in an interval with endpoints stx and sty. c     The parameter stp contains the current step. c     The subroutine assumes that if brackt is set to .true. then c c           min(stx,sty) < stp < max(stx,sty), c c     and that the derivative at stx is negative in the direction c     of the step. c c     The subroutine statement is c c       subroutine dcstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt, c                         stpmin,stpmax) c c     where c c       stx is a double precision variable. c         On entry stx is the best step obtained so far and is an c            endpoint of the interval that contains the minimizer. c         On exit stx is the updated best step. c c       fx is a double precision variable. c         On entry fx is the function at stx. c         On exit fx is the function at stx. c c       dx is a double precision variable. c         On entry dx is the derivative of the function at c            stx. The derivative must be negative in the direction of c            the step, that is, dx and stp - stx must have opposite c            signs. c         On exit dx is the derivative of the function at stx. c c       sty is a double precision variable. c         On entry sty is the second endpoint of the interval that c            contains the minimizer. c         On exit sty is the updated endpoint of the interval that c            contains the minimizer. c c       fy is a double precision variable. c         On entry fy is the function at sty. c         On exit fy is the function at sty. c c       dy is a double precision variable. c         On entry dy is the derivative of the function at sty. c         On exit dy is the derivative of the function at the exit sty. c c       stp is a double precision variable. c         On entry stp is the current step. If brackt is set to .true. c            then on input stp must be between stx and sty. c         On exit stp is a new trial step. c c       fp is a double precision variable. c         On entry fp is the function at stp c         On exit fp is unchanged. c c       dp is a double precision variable. c         On entry dp is the the derivative of the function at stp. c         On exit dp is unchanged. c c       brackt is an logical variable. c         On entry brackt specifies if a minimizer has been bracketed. c            Initially brackt must be set to .false. c         On exit brackt specifies if a minimizer has been bracketed. c            When a minimizer is bracketed brackt is set to .true. c c       stpmin is a double precision variable. c         On entry stpmin is a lower bound for the step. c         On exit stpmin is unchanged. c c       stpmax is a double precision variable. c         On entry stpmax is an upper bound for the step. c         On exit stpmax is unchanged. c c     MINPACK-1 Project. June 1983 c     Argonne National Laboratory. c     Jorge J. More' and David J. Thuente. c c     MINPACK-2 Project. October 1993. c     Argonne National Laboratory and University of Minnesota. c     Brett M. Averick and Jorge J. More'. c c     ********** double precision zero , p66 , two , three parameter ( zero = 0.0d0 , p66 = 0.66d0 , two = 2.0d0 , three = 3.0d0 ) double precision gamma , p , q , r , s , sgnd , stpc , stpf , stpq , theta sgnd = dp * ( dx / abs ( dx )) c     First case: A higher function value. The minimum is bracketed. c     If the cubic step is closer to stx than the quadratic step, the c     cubic step is taken, otherwise the average of the cubic and c     quadratic steps is taken. if ( fp . gt . fx ) then theta = three * ( fx - fp ) / ( stp - stx ) + dx + dp s = max ( abs ( theta ), abs ( dx ), abs ( dp )) gamma = s * sqrt (( theta / s ) ** 2 - ( dx / s ) * ( dp / s )) if ( stp . lt . stx ) gamma = - gamma p = ( gamma - dx ) + theta q = (( gamma - dx ) + gamma ) + dp r = p / q stpc = stx + r * ( stp - stx ) stpq = stx + (( dx / (( fx - fp ) / ( stp - stx ) + dx )) / two ) * + ( stp - stx ) if ( abs ( stpc - stx ) . lt . abs ( stpq - stx )) then stpf = stpc else stpf = stpc + ( stpq - stpc ) / two endif brackt = . true . c     Second case: A lower function value and derivatives of opposite c     sign. The minimum is bracketed. If the cubic step is farther from c     stp than the secant step, the cubic step is taken, otherwise the c     secant step is taken. else if ( sgnd . lt . zero ) then theta = three * ( fx - fp ) / ( stp - stx ) + dx + dp s = max ( abs ( theta ), abs ( dx ), abs ( dp )) gamma = s * sqrt (( theta / s ) ** 2 - ( dx / s ) * ( dp / s )) if ( stp . gt . stx ) gamma = - gamma p = ( gamma - dp ) + theta q = (( gamma - dp ) + gamma ) + dx r = p / q stpc = stp + r * ( stx - stp ) stpq = stp + ( dp / ( dp - dx )) * ( stx - stp ) if ( abs ( stpc - stp ) . gt . abs ( stpq - stp )) then stpf = stpc else stpf = stpq endif brackt = . true . c     Third case: A lower function value, derivatives of the same sign, c     and the magnitude of the derivative decreases. else if ( abs ( dp ) . lt . abs ( dx )) then c        The cubic step is computed only if the cubic tends to infinity c        in the direction of the step or if the minimum of the cubic c        is beyond stp. Otherwise the cubic step is defined to be the c        secant step. theta = three * ( fx - fp ) / ( stp - stx ) + dx + dp s = max ( abs ( theta ), abs ( dx ), abs ( dp )) c        The case gamma = 0 only arises if the cubic does not tend c        to infinity in the direction of the step. gamma = s * sqrt ( max ( zero ,( theta / s ) ** 2 - ( dx / s ) * ( dp / s ))) if ( stp . gt . stx ) gamma = - gamma p = ( gamma - dp ) + theta q = ( gamma + ( dx - dp )) + gamma r = p / q if ( r . lt . zero . and . gamma . ne . zero ) then stpc = stp + r * ( stx - stp ) else if ( stp . gt . stx ) then stpc = stpmax else stpc = stpmin endif stpq = stp + ( dp / ( dp - dx )) * ( stx - stp ) if ( brackt ) then c           A minimizer has been bracketed. If the cubic step is c           closer to stp than the secant step, the cubic step is c           taken, otherwise the secant step is taken. if ( abs ( stpc - stp ) . lt . abs ( stpq - stp )) then stpf = stpc else stpf = stpq endif if ( stp . gt . stx ) then stpf = min ( stp + p66 * ( sty - stp ), stpf ) else stpf = max ( stp + p66 * ( sty - stp ), stpf ) endif else c           A minimizer has not been bracketed. If the cubic step is c           farther from stp than the secant step, the cubic step is c           taken, otherwise the secant step is taken. if ( abs ( stpc - stp ) . gt . abs ( stpq - stp )) then stpf = stpc else stpf = stpq endif stpf = min ( stpmax , stpf ) stpf = max ( stpmin , stpf ) endif c     Fourth case: A lower function value, derivatives of the same sign, c     and the magnitude of the derivative does not decrease. If the c     minimum is not bracketed, the step is either stpmin or stpmax, c     otherwise the cubic step is taken. else if ( brackt ) then theta = three * ( fp - fy ) / ( sty - stp ) + dy + dp s = max ( abs ( theta ), abs ( dy ), abs ( dp )) gamma = s * sqrt (( theta / s ) ** 2 - ( dy / s ) * ( dp / s )) if ( stp . gt . sty ) gamma = - gamma p = ( gamma - dp ) + theta q = (( gamma - dp ) + gamma ) + dy r = p / q stpc = stp + r * ( sty - stp ) stpf = stpc else if ( stp . gt . stx ) then stpf = stpmax else stpf = stpmin endif endif c     Update the interval which contains a minimizer. if ( fp . gt . fx ) then sty = stp fy = fp dy = dp else if ( sgnd . lt . zero ) then sty = stx fy = fx dy = dx endif stx = stp fx = fp dx = dp endif c     Compute the new step. stp = stpf return end","tags":"","loc":"sourcefile/lbfgsb.f.html","title":"lbfgsb.f – ROHSA"},{"text":"L-BFGS-B submodule Contents Subroutines dpofa dtrsl Source Code linpack.f Source Code !! L-BFGS-B submodule c c  L-BFGS-B is released under the “New BSD License” (aka “Modified BSD License” c  or “3-clause license”) c  Please read attached file License.txt c subroutine dpofa ( a , lda , n , info ) integer lda , n , info double precision a ( lda , * ) c c     dpofa factors a double precision symmetric positive definite c     matrix. c c     dpofa is usually called by dpoco, but it can be called c     directly with a saving in time if  rcond  is not needed. c     (time for dpoco) = (1 + 18/n)*(time for dpofa) . c c     on entry c c        a       double precision(lda, n) c                the symmetric matrix to be factored.  only the c                diagonal and upper triangle are used. c c        lda     integer c                the leading dimension of the array  a . c c        n       integer c                the order of the matrix  a . c c     on return c c        a       an upper triangular matrix  r  so that  a = trans(r)*r c                where  trans(r)  is the transpose. c                the strict lower triangle is unaltered. c                if  info .ne. 0 , the factorization is not complete. c c        info    integer c                = 0  for normal return. c                = k  signals an error condition.  the leading minor c                     of order  k  is not positive definite. c c     linpack.  this version dated 08/14/78 . c     cleve moler, university of new mexico, argonne national lab. c c     subroutines and functions c c     blas ddot c     fortran sqrt c c     internal variables c double precision ddot , t double precision s integer j , jm1 , k c     begin block with ...exits to 40 c c do 30 j = 1 , n info = j s = 0.0d0 jm1 = j - 1 if ( jm1 . lt . 1 ) go to 20 do 10 k = 1 , jm1 t = a ( k , j ) - ddot ( k - 1 , a ( 1 , k ), 1 , a ( 1 , j ), 1 ) t = t / a ( k , k ) a ( k , j ) = t s = s + t * t 10 continue 20 continue s = a ( j , j ) - s c     ......exit if ( s . le . 0.0d0 ) go to 40 a ( j , j ) = sqrt ( s ) 30 continue info = 0 40 continue return end c====================== The end of dpofa =============================== subroutine dtrsl ( t , ldt , n , b , job , info ) integer ldt , n , job , info double precision t ( ldt , * ), b ( * ) c c c     dtrsl solves systems of the form c c                   t * x = b c     or c                   trans(t) * x = b c c     where t is a triangular matrix of order n. here trans(t) c     denotes the transpose of the matrix t. c c     on entry c c         t         double precision(ldt,n) c                   t contains the matrix of the system. the zero c                   elements of the matrix are not referenced, and c                   the corresponding elements of the array can be c                   used to store other information. c c         ldt       integer c                   ldt is the leading dimension of the array t. c c         n         integer c                   n is the order of the system. c c         b         double precision(n). c                   b contains the right hand side of the system. c c         job       integer c                   job specifies what kind of system is to be solved. c                   if job is c c                        00   solve t*x=b, t lower triangular, c                        01   solve t*x=b, t upper triangular, c                        10   solve trans(t)*x=b, t lower triangular, c                        11   solve trans(t)*x=b, t upper triangular. c c     on return c c         b         b contains the solution, if info .eq. 0. c                   otherwise b is unaltered. c c         info      integer c                   info contains zero if the system is nonsingular. c                   otherwise info contains the index of c                   the first zero diagonal element of t. c c     linpack. this version dated 08/14/78 . c     g. w. stewart, university of maryland, argonne national lab. c c     subroutines and functions c c     blas daxpy,ddot c     fortran mod c c     internal variables c double precision ddot , temp integer case , j , jj c c     begin block permitting ...exits to 150 c c        check for zero diagonal elements. c do 10 info = 1 , n c     ......exit if ( t ( info , info ) . eq . 0.0d0 ) go to 150 10 continue info = 0 c c        determine the task and go to it. c case = 1 if ( mod ( job , 10 ) . ne . 0 ) case = 2 if ( mod ( job , 100 ) / 10 . ne . 0 ) case = case + 2 go to ( 20 , 50 , 80 , 110 ), case c c        solve t*x=b for t lower triangular c 20 continue b ( 1 ) = b ( 1 ) / t ( 1 , 1 ) if ( n . lt . 2 ) go to 40 do 30 j = 2 , n temp = - b ( j - 1 ) call daxpy ( n - j + 1 , temp , t ( j , j - 1 ), 1 , b ( j ), 1 ) b ( j ) = b ( j ) / t ( j , j ) 30 continue 40 continue go to 140 c c        solve t*x=b for t upper triangular. c 50 continue b ( n ) = b ( n ) / t ( n , n ) if ( n . lt . 2 ) go to 70 do 60 jj = 2 , n j = n - jj + 1 temp = - b ( j + 1 ) call daxpy ( j , temp , t ( 1 , j + 1 ), 1 , b ( 1 ), 1 ) b ( j ) = b ( j ) / t ( j , j ) 60 continue 70 continue go to 140 c c        solve trans(t)*x=b for t lower triangular. c 80 continue b ( n ) = b ( n ) / t ( n , n ) if ( n . lt . 2 ) go to 100 do 90 jj = 2 , n j = n - jj + 1 b ( j ) = b ( j ) - ddot ( jj - 1 , t ( j + 1 , j ), 1 , b ( j + 1 ), 1 ) b ( j ) = b ( j ) / t ( j , j ) 90 continue 100 continue go to 140 c c        solve trans(t)*x=b for t upper triangular. c 110 continue b ( 1 ) = b ( 1 ) / t ( 1 , 1 ) if ( n . lt . 2 ) go to 130 do 120 j = 2 , n b ( j ) = b ( j ) - ddot ( j - 1 , t ( 1 , j ), 1 , b ( 1 ), 1 ) b ( j ) = b ( j ) / t ( j , j ) 120 continue 130 continue 140 continue 150 continue return end c====================== The end of dtrsl ===============================","tags":"","loc":"sourcefile/linpack.f.html","title":"linpack.f – ROHSA"},{"text":"Regularized Optimization for Hypers-spectral Analysis (ROHSA) This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mod_array.f90 mod_array.f90 sourcefile~main.f90->sourcefile~mod_array.f90 sourcefile~mod_optimize.f90 mod_optimize.f90 sourcefile~main.f90->sourcefile~mod_optimize.f90 sourcefile~mod_start.f90 mod_start.f90 sourcefile~main.f90->sourcefile~mod_start.f90 sourcefile~mod_read.f90 mod_read.f90 sourcefile~main.f90->sourcefile~mod_read.f90 sourcefile~mod_functions.f90 mod_functions.f90 sourcefile~main.f90->sourcefile~mod_functions.f90 sourcefile~mod_constants.f90 mod_constants.f90 sourcefile~main.f90->sourcefile~mod_constants.f90 sourcefile~mod_array.f90->sourcefile~mod_constants.f90 sourcefile~mod_optimize.f90->sourcefile~mod_array.f90 sourcefile~mod_optimize.f90->sourcefile~mod_constants.f90 sourcefile~mod_read.f90->sourcefile~mod_constants.f90 sourcefile~mod_functions.f90->sourcefile~mod_array.f90 sourcefile~mod_functions.f90->sourcefile~mod_optimize.f90 sourcefile~mod_functions.f90->sourcefile~mod_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs ROHSA Source Code main.f90 Source Code !! Regularized Optimization for Hypers-spectral Analysis (ROHSA) program ROHSA use mod_constants use mod_read use mod_array use mod_functions use mod_start use mod_optimize implicit none real ( xp ), dimension (:,:,:), allocatable :: data !! initial fits data real ( xp ), dimension (:,:,:), allocatable :: cube !! reshape data with nside --> cube real ( xp ), dimension (:,:,:), allocatable :: cube_mean !! mean cube over spatial axis real ( xp ), dimension (:,:,:), allocatable :: fit_params !! parameters to optimize with cube mean at each iteration real ( xp ), dimension (:,:,:), allocatable :: grid_params !! parameters to optimize at final step (dim of initial cube) real ( xp ), dimension (:,:), allocatable :: std_map !! standard deviation map fo the cube computed by ROHSA with lb and ub real ( xp ), dimension (:,:), allocatable :: std_cube !! standard deviation map fo the cube is given by the user integer , dimension ( 3 ) :: dim_data !! dimension of original data integer , dimension ( 3 ) :: dim_cube !! dimension of reshape cube real ( xp ), dimension (:,:), allocatable :: kernel !! convolution kernel integer :: ios = 0 !! ios integer integer :: i !! loop index integer :: j !! loop index integer :: k !! loop index logical :: noise !! if false --> STD map computed by ROHSA with lstd and ustd (if true given by the user) logical :: regul !! if true --> activate regulation integer :: nside !! size of the reshaped data 2&#94;{nside} integer :: n !! loop index integer :: power !! loop index integer :: n_gauss !! number of gaussian to fit integer :: m !! number of corrections used in the limited memory matrix by LBFGS-B integer :: lstd !! lower bound to compute the standard deviation map of the cube (if noise .eq. false) integer :: ustd !! upper bound to compute the standrad deviation map of the cube (if noise .eq. false) integer :: iprint !! print option integer :: iprint_init !! print option init integer :: maxiter !! max iteration for L-BFGS-B alogorithm integer :: maxiter_init !! max iteration for L-BFGS-B alogorithm (init mean spectrum) real ( xp ) :: lambda_amp !! lambda for amplitude parameter real ( xp ) :: lambda_mu !! lamnda for mean position parameter real ( xp ) :: lambda_sig !! lambda for dispersion parameter character ( len = 512 ) :: filename_parameters !! name of the parameters file (default parameters.txt) character ( len = 512 ) :: filename !! name of the data file character ( len = 512 ) :: fileout !! name of the output result character ( len = 512 ) :: filename_noise !! name of the file with STD map (if noise .eq. true) !Print header and get filename in argument call header () call get_command_argument ( 1 , filename_parameters ) print * , \"\" !Default user parameters n_gauss = 3 lambda_amp = 1._xp lambda_mu = 1._xp lambda_sig = 1._xp maxiter_init = 15000 maxiter = 800 m = 10 noise = . false . regul = . true . lstd = 0 ; ustd = 20 iprint = - 1 iprint_init = - 1 call read_parameters ( filename_parameters , filename , fileout , filename_noise , n_gauss , lambda_amp , lambda_mu , lambda_sig , & maxiter_init , maxiter , m , noise , regul , lstd , ustd , iprint , iprint_init ) print * , \"filename = '\" , trim ( filename ), \"'\" print * , \"fileout = '\" , trim ( fileout ), \"'\" print * , print * , \"______Parameters_____\" print * , print * , \"n_gauss = \" , n_gauss print * , \"lambda_amp = \" , lambda_amp print * , \"lambda_mu = \" , lambda_mu print * , \"lambda_sig = \" , lambda_sig print * , \"maxiter_itit = \" , maxiter_init print * , \"maxiter = \" , maxiter print * , \"lstd = \" , lstd print * , \"ustd = \" , ustd print * , \"noise = \" , noise print * , \"regul = \" , regul print * , allocate ( kernel ( 3 , 3 )) kernel ( 1 , 1 ) = 0._xp kernel ( 1 , 2 ) = - 0.25_xp kernel ( 1 , 3 ) = 0._xp kernel ( 2 , 1 ) = - 0.25_xp kernel ( 2 , 2 ) = 1._xp kernel ( 2 , 3 ) = - 0.25_xp kernel ( 3 , 1 ) = 0._xp kernel ( 3 , 2 ) = - 0.25_xp kernel ( 3 , 3 ) = 0._xp !Load data call read_cube ( filename , data ) if ( noise . eqv . . true .) then if ( filename_noise == \" \" ) then print * , \"--> noise = .true. (no input rms map)\" end if call read_map ( filename_noise , std_cube ) end if write ( * , * ) \"\" write ( * , * ) \"opening file and reading data\" dim_data = shape ( data ) write ( * , * ) \"dim_v, dim_y, dim_x = \" , dim_data write ( * , * ) \"\" write ( * , * ) \"number of los = \" , dim_data ( 2 ) * dim_data ( 3 ) nside = dim2nside ( dim_data ) write ( * , * ) \"nside = \" , nside call dim_data2dim_cube ( nside , dim_data , dim_cube ) !Allocate moemory for cube allocate ( cube ( dim_cube ( 1 ), dim_cube ( 2 ), dim_cube ( 3 ))) !Reshape the data (new cube of size nside) print * , write ( * , * ) \"Reshape cube, new dimensions :\" write ( * , * ) \"dim_v, dim_y, dim_x = \" , dim_cube print * , call reshape_up ( data , cube , dim_data , dim_cube ) !Allocate memory for fit_params array allocate ( fit_params ( 3 * n_gauss , 1 , 1 )) print * , \"                    Start iteration\" print * , !Start iteration do n = 0 , nside power = 2 ** n allocate ( cube_mean ( dim_cube ( 1 ), power , power )) call mean_array ( power , cube , cube_mean ) if ( n == 0 ) then print * , \"Init mean spectrum\" call init_spectrum ( n_gauss , fit_params (:, 1 , 1 ), dim_cube ( 1 ), cube_mean (:, 1 , 1 ), maxiter_init , m , iprint_init ) end if call go_up_level ( fit_params ) write ( * , * ) \"\" write ( * , * ) \"Update parameters level \" , n , \">\" , power if ( regul . eqv . . false .) then call upgrade ( cube_mean , fit_params , power , n_gauss , dim_cube ( 1 ), maxiter , m , iprint ) end if if ( regul . eqv . . true .) then if ( n == 0 ) then call upgrade ( cube_mean , fit_params , power , n_gauss , dim_cube ( 1 ), maxiter , m , iprint ) end if if ( n > 0 . and . n < nside ) then allocate ( std_map ( power , power )) if ( noise . eqv . . true .) then call mean_map ( power , std_cube , std_map ) else call set_stdmap ( std_map , cube_mean , lstd , ustd ) end if call update ( cube_mean , fit_params , n_gauss , dim_cube ( 1 ), power , power , lambda_amp , lambda_mu , lambda_sig , & maxiter , m , kernel , iprint , std_map ) deallocate ( std_map ) end if end if deallocate ( cube_mean ) enddo print * , write ( * , * ) \"Reshape cube, restore initial dimensions :\" write ( * , * ) \"dim_v, dim_y, dim_x = \" , dim_data allocate ( grid_params ( 3 * n_gauss , dim_data ( 2 ), dim_data ( 3 ))) call reshape_down ( fit_params , grid_params , ( / 3 * n_gauss , dim_cube ( 2 ), dim_cube ( 3 ) / ), ( / 3 * n_gauss , dim_data ( 2 ), dim_data ( 3 ) / )) print * , print * , \"Update last level ...\" print * , allocate ( std_map ( dim_data ( 2 ), dim_data ( 3 ))) if ( noise . eqv . . true .) then std_map = std_cube else call set_stdmap ( std_map , data , lstd , ustd ) end if if ( regul . eqv . . true .) then call update ( data , grid_params , n_gauss , dim_data ( 1 ), dim_data ( 2 ), dim_data ( 3 ), lambda_amp , lambda_mu , lambda_sig , & maxiter , m , kernel , iprint , std_map ) end if print * , print * , \"_____ Write output file _____\" print * , ! Open file open ( unit = 12 , file = fileout , action = \"write\" , iostat = ios ) if ( ios /= 0 ) stop \"opening file error\" ! Read cube dimension and compute the number of line write ( 12 , fmt =* ) \"# \" write ( 12 , fmt =* ) \"# ______Parameters_____\" write ( 12 , fmt =* ) \"# \" write ( 12 , fmt =* ) \"# n_gauss = \" , n_gauss write ( 12 , fmt =* ) \"# lambda_amp = \" , lambda_amp write ( 12 , fmt =* ) \"# lambda_mu = \" , lambda_mu write ( 12 , fmt =* ) \"# lambda_sig = \" , lambda_sig write ( 12 , fmt =* ) \"# maxiter_itit = \" , maxiter_init write ( 12 , fmt =* ) \"# maxiter = \" , maxiter write ( 12 , fmt =* ) \"# lstd = \" , lstd write ( 12 , fmt =* ) \"# ustd = \" , ustd write ( 12 , fmt =* ) \"# noise = \" , noise write ( 12 , fmt =* ) \"# regul = \" , regul write ( 12 , fmt =* ) \"# \" write ( 12 , fmt =* ) \"# i, j, A, mean, sigma\" do i = 1 , dim_data ( 2 ) do j = 1 , dim_data ( 3 ) do k = 1 , n_gauss write ( 12 , fmt =* ) i - 1 , j - 1 , grid_params ( 1 + (( k - 1 ) * 3 ), i , j ), grid_params ( 2 + (( k - 1 ) * 3 ), i , j ), grid_params ( 3 + (( k - 1 ) * 3 ), i , j ) enddo enddo enddo close ( 12 ) call ender () end program ROHSA","tags":"","loc":"sourcefile/main.f90.html","title":"main.f90 – ROHSA"},{"text":"This module contains tools (convolution/ravel) to manipulate 2D/3Darray This file depends on sourcefile~~mod_array.f90~~EfferentGraph sourcefile~mod_array.f90 mod_array.f90 sourcefile~mod_constants.f90 mod_constants.f90 sourcefile~mod_array.f90->sourcefile~mod_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mod_array.f90~~AfferentGraph sourcefile~mod_array.f90 mod_array.f90 sourcefile~mod_functions.f90 mod_functions.f90 sourcefile~mod_functions.f90->sourcefile~mod_array.f90 sourcefile~mod_optimize.f90 mod_optimize.f90 sourcefile~mod_functions.f90->sourcefile~mod_optimize.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_array.f90 sourcefile~main.f90->sourcefile~mod_functions.f90 sourcefile~main.f90->sourcefile~mod_optimize.f90 sourcefile~mod_optimize.f90->sourcefile~mod_array.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_array Source Code mod_array.f90 Source Code !! This module contains tools (convolution/ravel) to manipulate 2D/3Darray module mod_array !! This module contains tools (convolution/ravel) to manipulate 2D/3Darray use mod_constants implicit none private public :: convolution_2D_mirror , ravel_3D , unravel_3D contains subroutine convolution_2D_mirror ( image , conv , dim_y , dim_x , kernel , dim_k ) implicit none real ( xp ), intent ( in ), dimension (:,:), allocatable :: image real ( xp ), intent ( inout ), dimension (:,:), allocatable :: conv real ( xp ), intent ( in ), dimension (:,:), allocatable :: kernel integer , intent ( in ) :: dim_y , dim_x , dim_k integer :: i , j , ii , jj , m , n , mm , nn integer :: kCenterY , kCenterX real ( xp ), dimension (:,:), allocatable :: ext_conv , extended allocate ( ext_conv ( dim_y + 4 , dim_x + 4 )) allocate ( extended ( dim_y + 4 , dim_x + 4 )) ii = 0 ; jj = 0 ; mm = 0 ; nn = 0 kCenterY = 0 ; kCenterX = 0 ext_conv = 0._xp extended = 0._xp do j = 1 , dim_x do i = 1 , dim_y extended ( 2 + i , 2 + j ) = image ( i , j ) end do end do do j = 1 , 2 do i = 1 , dim_y extended ( 2 + i , j ) = image ( i , j ); end do end do do i = 1 , 2 do j = 1 , dim_x extended ( i , 2 + j ) = image ( i , j ); end do end do do j = dim_x + 1 , dim_x + 2 do i = 1 , dim_y extended ( 2 + i , 2 + j ) = image ( i , j - 2 ) end do end do do j = 1 , dim_x do i = dim_y + 1 , dim_y + 2 extended ( 2 + i , 2 + j ) = image ( i - 2 , j ) end do end do kCenterY = dim_k / 2 + 1 kCenterX = kCenterY do j = 1 , dim_x + 4 do i = 1 , dim_y + 4 do m = 1 , dim_k mm = dim_k - m + 1 do n = 1 , dim_k nn = dim_k - n + 1 ii = i + ( m - kCenterY ) jj = j + ( n - kCenterX ) if ( ii >= 1 . and . ii < dim_y + 4 . and . jj >= 1 . and . jj < dim_x + 4 ) then ext_conv ( i , j ) = ext_conv ( i , j ) + extended ( ii , jj ) * kernel ( mm , nn ) end if end do end do end do end do do j = 1 , dim_x do i = 1 , dim_y conv ( i , j ) = ext_conv ( 2 + i , 2 + j ) end do end do end subroutine convolution_2D_mirror ! Return a contiguous flattened 1D array from a 3D array subroutine ravel_3D ( cube , vector , dim_v , dim_y , dim_x ) implicit none integer , intent ( in ) :: dim_v , dim_y , dim_x real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube real ( xp ), intent ( inout ), dimension (:), allocatable :: vector integer :: i , j , k , i__ i__ = 1 do k = 1 , dim_x do j = 1 , dim_y do i = 1 , dim_v vector ( i__ ) = cube ( i , j , k ) i__ = i__ + 1 end do end do end do end subroutine ravel_3D ! Return a 3D array from a contiguous flattened 1D array subroutine unravel_3D ( vector , cube , dim_v , dim_y , dim_x ) implicit none integer , intent ( in ) :: dim_v , dim_y , dim_x real ( xp ), intent ( in ), dimension (:), allocatable :: vector real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube integer :: i , j , k , i__ i__ = 1 do k = 1 , dim_x do j = 1 , dim_y do i = 1 , dim_v cube ( i , j , k ) = vector ( i__ ) i__ = i__ + 1 end do end do end do end subroutine unravel_3D end module mod_array","tags":"","loc":"sourcefile/mod_array.f90.html","title":"mod_array.f90 – ROHSA"},{"text":"This module define physical and numerical constant used by ROHSA Files dependent on this one sourcefile~~mod_constants.f90~~AfferentGraph sourcefile~mod_constants.f90 mod_constants.f90 sourcefile~mod_array.f90 mod_array.f90 sourcefile~mod_array.f90->sourcefile~mod_constants.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_constants.f90 sourcefile~main.f90->sourcefile~mod_array.f90 sourcefile~mod_functions.f90 mod_functions.f90 sourcefile~main.f90->sourcefile~mod_functions.f90 sourcefile~mod_read.f90 mod_read.f90 sourcefile~main.f90->sourcefile~mod_read.f90 sourcefile~mod_optimize.f90 mod_optimize.f90 sourcefile~main.f90->sourcefile~mod_optimize.f90 sourcefile~mod_functions.f90->sourcefile~mod_constants.f90 sourcefile~mod_functions.f90->sourcefile~mod_array.f90 sourcefile~mod_functions.f90->sourcefile~mod_optimize.f90 sourcefile~mod_read.f90->sourcefile~mod_constants.f90 sourcefile~mod_optimize.f90->sourcefile~mod_constants.f90 sourcefile~mod_optimize.f90->sourcefile~mod_array.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_constants Source Code mod_constants.f90 Source Code !! This module define physical and numerical constant used by ROHSA module mod_constants !! This module define physical and numerical constant used by ROHSA use , intrinsic :: iso_fortran_env implicit none integer , parameter , public :: xp = REAL64 !physical constants FIXME CHECK VALUES real ( xp ), parameter , public :: G = 6.67408e-8_xp !nravitationnal cst in cgs real ( xp ), parameter , public :: c = 2.99792458e10_xp !speed of light in cgs real ( xp ), parameter , public :: pi = 4.0_xp * atan ( 1.0_xp ) real ( xp ), parameter , public :: M_sun = 1.98855e33_xp !mass of the sun in cgs real ( xp ), parameter , public :: cst_rad = 7.5657308531642009e-15_xp !radiation cst in cgs real ( xp ), parameter , public :: stefan = ( c * cst_rad ) / 4.0_xp !stefan cst in cgs real ( xp ), parameter , public :: kb = 1.3806488e-16_xp !boltzmann cst in cgs real ( xp ), parameter , public :: R = 8.3144598e7_xp !gas cst in csg = Boltzmann cst over proton mass real ( xp ), parameter , public :: gammag = 5._xp / 3._xp !adiabatic coefficient real ( xp ), parameter , public :: thomson = 6.6524587158e-25_xp !thomson cross-section in cgs end module mod_constants","tags":"","loc":"sourcefile/mod_constants.f90.html","title":"mod_constants.f90 – ROHSA"},{"text":"This module contains the main routines of ROHSA This file depends on sourcefile~~mod_functions.f90~~EfferentGraph sourcefile~mod_functions.f90 mod_functions.f90 sourcefile~mod_array.f90 mod_array.f90 sourcefile~mod_functions.f90->sourcefile~mod_array.f90 sourcefile~mod_constants.f90 mod_constants.f90 sourcefile~mod_functions.f90->sourcefile~mod_constants.f90 sourcefile~mod_optimize.f90 mod_optimize.f90 sourcefile~mod_functions.f90->sourcefile~mod_optimize.f90 sourcefile~mod_array.f90->sourcefile~mod_constants.f90 sourcefile~mod_optimize.f90->sourcefile~mod_array.f90 sourcefile~mod_optimize.f90->sourcefile~mod_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mod_functions.f90~~AfferentGraph sourcefile~mod_functions.f90 mod_functions.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_functions.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_functions Source Code mod_functions.f90 Source Code !! This module contains the main routines of ROHSA module mod_functions !! This module contains the main routines of ROHSA use mod_constants use mod_optimize use mod_array implicit none private public :: mean_array , mean_map , dim2nside , dim_data2dim_cube , reshape_up , reshape_down , go_up_level , init_spectrum , & upgrade , update , set_stdmap contains pure function dim2nside ( dim_cube ) !! Compute nside value from dim_y and dim_x implicit none integer :: dim2nside !! nside of the cube integer , intent ( in ), dimension ( 3 ) :: dim_cube !! cube dimension dim2nside = max ( 0 , int ( ceiling ( log ( real ( dim_cube ( 2 ))) / log ( 2. ))), int ( ceiling ( log ( real ( dim_cube ( 3 ))) / log ( 2. )))) return end function dim2nside subroutine dim_data2dim_cube ( nside , dim_data , dim_cube ) implicit none integer , intent ( in ), dimension ( 3 ) :: dim_data integer , intent ( inout ), dimension ( 3 ) :: dim_cube integer :: nside dim_cube ( 1 ) = dim_data ( 1 ) dim_cube ( 2 ) = 2 ** nside dim_cube ( 3 ) = dim_cube ( 2 ) end subroutine dim_data2dim_cube subroutine reshape_up ( data , cube , dim_data , dim_cube ) !! Reshape the data in a grid of  2&#94;{nside}  implicit none real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: data !! original cube real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube !! reshape cube integer , intent ( in ), dimension ( 3 ) :: dim_data !! original cube dimension integer , intent ( in ), dimension ( 3 ) :: dim_cube !! new cube dimension integer :: offset_w , offset_h offset_w = ( dim_cube ( 2 ) - dim_data ( 2 )) / 2 offset_h = ( dim_cube ( 3 ) - dim_data ( 3 )) / 2 cube (:, offset_w + 1 : offset_w + dim_data ( 2 ), offset_h + 1 : offset_h + dim_data ( 3 )) = data end subroutine reshape_up subroutine reshape_down ( cube , data , dim_cube , dim_data ) !! Reshape the cube ( 2&#94;{nside} ) into a grid with original dimension (opposite of reshape_up) implicit none real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! original cube real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: data !! reshape cube integer , intent ( in ), dimension ( 3 ) :: dim_data !! original cube dimension integer , intent ( in ), dimension ( 3 ) :: dim_cube !! new cube dimension integer :: offset_w , offset_h offset_w = ( dim_cube ( 2 ) - dim_data ( 2 )) / 2 offset_h = ( dim_cube ( 3 ) - dim_data ( 3 )) / 2 data = cube (:, offset_w + 1 : offset_w + dim_data ( 2 ), offset_h + 1 : offset_h + dim_data ( 3 )) end subroutine reshape_down subroutine mean_array ( nside , cube , cube_mean ) !! Average cube along spatial axis depending on level n implicit none integer , intent ( in ) :: nside !! nside of the cube real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! cube real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube_mean !! average cube integer :: i , j , k , l , n real ( xp ), dimension (:), allocatable :: spectrum allocate ( spectrum ( size ( cube , dim = 1 ))) spectrum = 0. n = size ( cube , dim = 2 ) / nside do i = 1 , size ( cube_mean , dim = 2 ) do j = 1 , size ( cube_mean , dim = 3 ) do k = 1 , n do l = 1 , n spectrum = spectrum + cube (:, k + (( i - 1 ) * n ), l + (( j - 1 ) * n )) enddo enddo spectrum = spectrum / ( n ** 2 ) cube_mean (:, i , j ) = spectrum spectrum = 0. enddo enddo end subroutine mean_array subroutine mean_map ( nside , map , map_mean ) !! Average map depending on level nside implicit none integer , intent ( in ) :: nside !! nside real ( xp ), intent ( in ), dimension (:,:), allocatable :: map !! map real ( xp ), intent ( inout ), dimension (:,:), allocatable :: map_mean !! avarage map integer :: i , j , k , l , n real ( xp ) :: val val = 0. n = size ( map , dim = 2 ) / nside do i = 1 , size ( map_mean , dim = 1 ) do j = 1 , size ( map_mean , dim = 2 ) do k = 1 , n do l = 1 , n val = val + map ( k + (( i - 1 ) * n ), l + (( j - 1 ) * n )) enddo enddo val = val / ( n ** 2 ) map_mean ( i , j ) = val val = 0. enddo enddo end subroutine mean_map subroutine go_up_level ( cube_params ) !! Projection of the solution at next level (nside += 1) implicit none real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube_params !! cube of parameters integer :: i , j , k , l real ( xp ), dimension (:,:,:), allocatable :: cube_params_down integer , dimension ( 3 ) :: dim dim = shape ( cube_params ) allocate ( cube_params_down ( dim ( 1 ), dim ( 2 ), dim ( 3 ))) cube_params_down = 0._xp cube_params_down = cube_params deallocate ( cube_params ) allocate ( cube_params ( dim ( 1 ), dim ( 2 ) * 2 , dim ( 3 ) * 2 )) cube_params = 0._xp do i = 1 , size ( cube_params_down , dim = 2 ) do j = 1 , size ( cube_params_down , dim = 3 ) do k = 1 , 2 do l = 1 , 2 cube_params (:, k + (( i - 1 ) * 2 ), l + (( j - 1 ) * 2 )) = cube_params_down (:, i , j ) enddo enddo enddo enddo end subroutine go_up_level subroutine init_spectrum ( n_gauss , params , dim_v , line , maxiter , m , iprint ) !! Initialization of the mean sprectrum with N Gaussian implicit none integer , intent ( in ) :: n_gauss !! number of Gaussian integer , intent ( in ) :: dim_v !! dimension along v axis integer , intent ( in ) :: maxiter !! Max number of iteration integer , intent ( in ) :: m !! number of corrections used in the limited memory matrix by LBFGS-B integer , intent ( in ) :: iprint !! print option real ( xp ), intent ( in ), dimension ( dim_v ) :: line !! spectrum real ( xp ), intent ( inout ), dimension ( 3 * n_gauss ) :: params !! params to optimize integer :: i , j , k , p real ( xp ), dimension (:), allocatable :: lb , ub real ( xp ), dimension ( dim_v ) :: model , residual real ( xp ), dimension (:), allocatable :: x do i = 1 , n_gauss allocate ( lb ( 3 * i ), ub ( 3 * i )) model = 0._xp residual = 0._xp lb = 0._xp ; ub = 0._xp call init_bounds ( line , i , dim_v , lb , ub ) do j = 1 , i do k = 1 , dim_v model ( k ) = model ( k ) + gaussian ( k , params ( 1 + ( 3 * ( j - 1 ))), params ( 2 + ( 3 * ( j - 1 ))), params ( 3 + ( 3 * ( j - 1 )))) end do enddo residual = model - line allocate ( x ( 3 * i )) x = 0._xp do p = 1 , 3 * ( i - 1 ) x ( p ) = params ( p ); end do x ( 2 + ( 3 * ( i - 1 ))) = minloc ( residual , dim_v ) x ( 1 + ( 3 * ( i - 1 ))) = line ( int ( x ( 2 + ( 3 * ( i - 1 ))))) * 2._xp / 3._xp x ( 3 + ( 3 * ( i - 1 ))) = 5._xp ; call minimize_spec ( 3 * i , m , x , lb , ub , line , dim_v , i , maxiter , iprint ) do p = 1 , 3 * i params ( p ) = x ( p ); end do deallocate ( x ) deallocate ( lb , ub ) enddo end subroutine init_spectrum subroutine init_bounds ( line , n_gauss , dim_v , lb , ub ) !! Initialize parameters bounds for optimization implicit none integer , intent ( in ) :: n_gauss !! number of Gaussian integer , intent ( in ) :: dim_v !! dimension along v axis real ( xp ), intent ( in ), dimension ( dim_v ) :: line !! spectrum real ( xp ), intent ( inout ), dimension ( 3 * n_gauss ) :: lb !! lower bounds real ( xp ), intent ( inout ), dimension ( 3 * n_gauss ) :: ub !! upper bounds integer :: i real ( xp ) :: max_line max_line = 0._xp max_line = maxval ( line ) do i = 1 , n_gauss ! amplitude bounds lb ( 1 + ( 3 * ( i - 1 ))) = 0._xp ; ub ( 1 + ( 3 * ( i - 1 ))) = max_line ; ! mean bounds lb ( 2 + ( 3 * ( i - 1 ))) = 0._xp ; ub ( 2 + ( 3 * ( i - 1 ))) = dim_v ; ! sigma bounds lb ( 3 + ( 3 * ( i - 1 ))) = 0.001_xp ; ub ( 3 + ( 3 * ( i - 1 ))) = 10 0._xp ; end do end subroutine init_bounds subroutine upgrade ( cube , params , power , n_gauss , dim_v , maxiter , m , iprint ) !! Upgrade parameters (spectra to spectra) using minimize function (here based on L-BFGS-B optimization module) implicit none real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! cube integer , intent ( in ) :: power !! nside of the cube integer , intent ( in ) :: n_gauss !! number of Gaussian integer , intent ( in ) :: dim_v !! dimension along v axis integer , intent ( in ) :: maxiter !! max number of iteration integer , intent ( in ) :: m !! number of corrections used in the limited memory matrix by LBFGS-B integer , intent ( in ) :: iprint !! print option real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: params !! cube parameters to update integer :: i , j real ( xp ), dimension (:), allocatable :: line real ( xp ), dimension (:), allocatable :: x real ( xp ), dimension (:), allocatable :: lb , ub do i = 1 , power do j = 1 , power ! print*, (i-1)*power+j, \" / \", power*power allocate ( line ( dim_v )) allocate ( x ( 3 * n_gauss ), lb ( 3 * n_gauss ), ub ( 3 * n_gauss )) line = cube (:, i , j ) x = params (:, i , j ) call init_bounds ( line , n_gauss , dim_v , lb , ub ) call minimize_spec ( 3 * n_gauss , m , x , lb , ub , line , dim_v , n_gauss , maxiter , iprint ) params (:, i , j ) = x deallocate ( line ) deallocate ( x , lb , ub ) end do end do end subroutine upgrade subroutine update ( cube , params , n_gauss , dim_v , dim_y , dim_x , lambda_amp , lambda_mu , lambda_sig , maxiter , m , kernel , & iprint , std_map ) !! Update parameters (entire cube) using minimize function (here based on L-BFGS-B optimization module) implicit none real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! cube real ( xp ), intent ( in ), dimension (:,:), allocatable :: std_map !! Standard deviation map real ( xp ), intent ( in ), dimension (:,:), allocatable :: kernel !! convolution kernel integer , intent ( in ) :: dim_v !! dimension along v axis integer , intent ( in ) :: dim_y !! dimension along spatial axis y integer , intent ( in ) :: dim_x !! dimension along spatial axis x integer , intent ( in ) :: n_gauss !! Number of Gaussian integer , intent ( in ) :: maxiter !! max number of iteration integer , intent ( in ) :: m !! number of corrections used in the limited memory matrix by LBFGS-B integer , intent ( in ) :: iprint !! print option real ( xp ), intent ( in ) :: lambda_amp !! lambda for amplitude parameter real ( xp ), intent ( in ) :: lambda_mu !! lambda for mean position parameter real ( xp ), intent ( in ) :: lambda_sig !! lambda for dispersion parameter real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: params !! parameters cube to update integer :: i , j integer :: n_beta real ( xp ), dimension (:,:,:), allocatable :: lb_3D , ub_3D real ( xp ), dimension (:), allocatable :: lb , ub real ( xp ), dimension (:), allocatable :: beta n_beta = 3 * n_gauss * dim_y * dim_x allocate ( lb ( n_beta ), ub ( n_beta ), beta ( n_beta )) allocate ( lb_3D ( 3 * n_gauss , dim_y , dim_x ), ub_3D ( 3 * n_gauss , dim_y , dim_x )) do j = 1 , dim_x do i = 1 , dim_y call init_bounds ( cube (:, i , j ), n_gauss , dim_v , lb_3D (:, i , j ), ub_3D (:, i , j )) end do end do call ravel_3D ( lb_3D , lb , 3 * n_gauss , dim_y , dim_x ) call ravel_3D ( ub_3D , ub , 3 * n_gauss , dim_y , dim_x ) call ravel_3D ( params , beta , 3 * n_gauss , dim_y , dim_x ) call minimize ( n_beta , m , beta , lb , ub , cube , n_gauss , dim_v , dim_y , dim_x , lambda_amp , lambda_mu , lambda_sig , maxiter , & kernel , iprint , std_map ) call unravel_3D ( beta , params , 3 * n_gauss , dim_y , dim_x ) end subroutine update subroutine set_stdmap ( std_map , cube , lb , ub ) !! Compute the STD map of a 3D array implicit none integer , intent ( in ) :: lb !! lower bound integer , intent ( in ) :: ub !! upper bound real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! cube real ( xp ), intent ( inout ), dimension (:,:), allocatable :: std_map !! standard deviation map of the cube real ( xp ), dimension (:), allocatable :: line integer , dimension ( 3 ) :: dim_cube integer :: i , j dim_cube = shape ( cube ) do j = 1 , dim_cube ( 3 ) do i = 1 , dim_cube ( 2 ) line = cube ( lb : ub , i , j ) std_map ( i , j ) = std ( line ) end do end do end subroutine set_stdmap pure function std ( array ) !! Compute the STD of a 1D array implicit none real ( xp ), intent ( in ), dimension (:) :: array !! 1D array integer :: i integer :: n real ( xp ) :: std !! standard deviation real ( xp ) :: mean real ( xp ) :: var mean = 0._xp ; var = 0._xp std = 0._xp n = size ( array ) mean = sum ( array ) / n do i = 1 , n var = var + ( array ( i ) - mean ) ** 2._xp end do var = var / ( n - 1 ) std = sqrt ( var ) return end function std end module mod_functions","tags":"","loc":"sourcefile/mod_functions.f90.html","title":"mod_functions.f90 – ROHSA"},{"text":"This module contains optimization subroutine and parametric model This file depends on sourcefile~~mod_optimize.f90~~EfferentGraph sourcefile~mod_optimize.f90 mod_optimize.f90 sourcefile~mod_array.f90 mod_array.f90 sourcefile~mod_optimize.f90->sourcefile~mod_array.f90 sourcefile~mod_constants.f90 mod_constants.f90 sourcefile~mod_optimize.f90->sourcefile~mod_constants.f90 sourcefile~mod_array.f90->sourcefile~mod_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mod_optimize.f90~~AfferentGraph sourcefile~mod_optimize.f90 mod_optimize.f90 sourcefile~mod_functions.f90 mod_functions.f90 sourcefile~mod_functions.f90->sourcefile~mod_optimize.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_optimize.f90 sourcefile~main.f90->sourcefile~mod_functions.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_optimize Source Code mod_optimize.f90 Source Code !! This module contains optimization subroutine and parametric model module mod_optimize !! This module contains optimization subroutine and parametric model use mod_constants use mod_array implicit none private public :: gaussian , minimize_spec , minimize contains pure function gaussian ( x , a , m , s ) !! Gaussian function implicit none integer , intent ( in ) :: x real ( xp ), intent ( in ) :: a , m , s real ( xp ) :: gaussian gaussian = a * exp ( - ( ( real ( x , xp ) - m ) ** 2 ) / ( 2._xp * s ** 2 ) ); end function gaussian subroutine minimize_spec ( n , m , x , lb , ub , line , dim_v , n_gauss , maxiter , iprint ) !! Minimize algorithn for a specturm implicit none integer , intent ( in ) :: n integer , intent ( in ) :: m integer , intent ( in ) :: dim_v integer , intent ( in ) :: n_gauss , maxiter integer , intent ( in ) :: iprint real ( xp ), intent ( in ), dimension (:), allocatable :: lb , ub real ( xp ), intent ( in ), dimension ( dim_v ) :: line real ( xp ), intent ( in ), dimension (:), allocatable :: x real ( xp ), parameter :: factr = 1.0d+7 , pgtol = 1.0d-5 character ( len = 60 ) :: task , csave logical :: lsave ( 4 ) integer :: isave ( 44 ) real ( xp ) :: f real ( xp ) :: dsave ( 29 ) integer , dimension (:), allocatable :: nbd , iwa real ( xp ), dimension (:), allocatable :: g , wa real ( xp ), dimension (:), allocatable :: residual !     Allocate dynamic arrays allocate ( nbd ( n ), g ( n )) allocate ( iwa ( 3 * n )) allocate ( wa ( 2 * m * n + 5 * n + 11 * m * m + 8 * m )) allocate ( residual ( dim_v )) residual = 0._xp ! Init nbd nbd = 2 !     We now define the starting point. !     We start the iteration by initializing task. task = 'START' !     The beginning of the loop do while ( task ( 1 : 2 ). eq . 'FG' . or . task . eq . 'NEW_X' . or . task . eq . 'START' ) !     This is the call to the L-BFGS-B code. call setulb ( n , m , x , lb , ub , nbd , f , g , factr , pgtol , wa , iwa , task , iprint , csave , lsave , isave , dsave ) if ( task ( 1 : 2 ) . eq . 'FG' ) then !     Compute function f and gradient g for the sample problem. call myresidual ( x , line , residual , n_gauss , dim_v ) f = myfunc_spec ( residual ) call mygrad_spec ( n_gauss , g , residual , x , dim_v ) elseif ( task ( 1 : 5 ) . eq . 'NEW_X' ) then !        1) Terminate if the total number of f and g evaluations !             exceeds maxiter. if ( isave ( 34 ) . ge . maxiter ) & task = 'STOP: TOTAL NO. of f AND g EVALUATIONS EXCEEDS LIMIT' !        2) Terminate if  |proj g|/(1+|f|) < 1.0d-10. if ( dsave ( 13 ) . le . 1.d-10 * ( 1.0d0 + abs ( f ))) & task = 'STOP: THE PROJECTED GRADIENT IS SUFFICIENTLY SMALL' endif !     end of loop do while end do end subroutine minimize_spec ! Compute the residual between model and data subroutine myresidual ( params , line , residual , n_gauss , dim_v ) implicit none integer , intent ( in ) :: dim_v , n_gauss real ( xp ), intent ( in ), dimension ( dim_v ) :: line real ( xp ), intent ( in ), dimension ( 3 * n_gauss ) :: params real ( xp ), intent ( inout ), dimension (:), allocatable :: residual integer :: i , k real ( xp ) :: g real ( xp ), dimension ( dim_v ) :: model g = 0._xp model = 0._xp do i = 1 , n_gauss do k = 1 , dim_v g = gaussian ( k , params ( 1 + ( 3 * ( i - 1 ))), params ( 2 + ( 3 * ( i - 1 ))), params ( 3 + ( 3 * ( i - 1 )))) model ( k ) = model ( k ) + g enddo enddo residual = model - line end subroutine myresidual ! Objective function to minimize for a spectrum pure function myfunc_spec ( residual ) implicit none real ( xp ), intent ( in ), dimension (:), allocatable :: residual real ( xp ) :: myfunc_spec myfunc_spec = 0._xp myfunc_spec = 0.5_xp * sum ( residual ** 2._xp ) end function myfunc_spec ! Griadient of the objective function to minimize for a spectrum subroutine mygrad_spec ( n_gauss , gradient , residual , params , dim_v ) implicit none integer , intent ( in ) :: n_gauss , dim_v real ( xp ), intent ( in ), dimension ( 3 * n_gauss ) :: params real ( xp ), intent ( in ), dimension (:), allocatable :: residual real ( xp ), intent ( inout ), dimension ( 3 * n_gauss ) :: gradient integer :: i , k real ( xp ) :: g real ( xp ), dimension (:,:), allocatable :: dF_over_dB allocate ( dF_over_dB ( 3 * n_gauss , dim_v )) g = 0._xp dF_over_dB = 0._xp gradient = 0._xp do i = 1 , n_gauss do k = 1 , dim_v dF_over_dB ( 1 + ( 3 * ( i - 1 )), k ) = dF_over_dB ( 1 + ( 3 * ( i - 1 )), k ) + & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )))) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 ))) ** 2._xp )) dF_over_dB ( 2 + ( 3 * ( i - 1 )), k ) = dF_over_dB ( 2 + ( 3 * ( i - 1 )), k ) + & params ( 1 + ( 3 * ( i - 1 ))) * ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 ))) ) / ( params ( 3 + ( 3 * ( i - 1 ))) ** 2._xp ) * & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )))) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 ))) ** 2._xp )) dF_over_dB ( 3 + ( 3 * ( i - 1 )), k ) = dF_over_dB ( 3 + ( 3 * ( i - 1 )), k ) + & params ( 1 + ( 3 * ( i - 1 ))) * ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 ))) ) ** 2._xp / ( params ( 3 + ( 3 * ( i - 1 ))) ** 3._xp ) * & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )))) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 ))) ** 2._xp )) enddo enddo do i = 1 , dim_v do k = 1 , 3 * n_gauss gradient ( k ) = gradient ( k ) + dF_over_dB ( k , i ) * residual ( i ) end do end do end subroutine mygrad_spec ! Minimize algorithn for a cube with regularization subroutine minimize ( n , m , x , lb , ub , cube , n_gauss , dim_v , dim_y , dim_x , lambda_amp , lambda_mu , lambda_sig , maxiter , & kernel , iprint , std_map ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: m integer , intent ( in ) :: dim_v , dim_y , dim_x integer , intent ( in ) :: n_gauss , maxiter integer , intent ( in ) :: iprint real ( xp ), intent ( in ) :: lambda_amp , lambda_mu , lambda_sig real ( xp ), intent ( in ), dimension (:), allocatable :: lb , ub real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube real ( xp ), intent ( in ), dimension (:,:), allocatable :: kernel real ( xp ), intent ( in ), dimension (:,:), allocatable :: std_map real ( xp ), intent ( in ), dimension (:), allocatable :: x real ( xp ), parameter :: factr = 1.0d+7 , pgtol = 1.0d-5 character ( len = 60 ) :: task , csave logical :: lsave ( 4 ) integer :: isave ( 44 ) real ( xp ) :: f real ( xp ) :: dsave ( 29 ) integer , dimension (:), allocatable :: nbd , iwa real ( xp ), dimension (:), allocatable :: g , wa real ( xp ), dimension (:,:,:), allocatable :: residual !     Allocate dynamic arrays allocate ( nbd ( n ), g ( n )) allocate ( iwa ( 3 * n )) allocate ( wa ( 2 * m * n + 5 * n + 11 * m * m + 8 * m )) allocate ( residual ( dim_v , dim_y , dim_x )) residual = 0._xp f = 0._xp g = 0._xp ! Init nbd nbd = 2 !     We now define the starting point. !     We start the iteration by initializing task. task = 'START' !     The beginning of the loop do while ( task ( 1 : 2 ). eq . 'FG' . or . task . eq . 'NEW_X' . or . task . eq . 'START' ) !     This is the call to the L-BFGS-B code. call setulb ( n , m , x , lb , ub , nbd , f , g , factr , pgtol , wa , iwa , task , iprint , csave , lsave , isave , dsave ) if ( task ( 1 : 2 ) . eq . 'FG' ) then !     Compute function f and gradient g for the sample problem. call f_g_cube ( f , g , cube , x , dim_v , dim_y , dim_x , n_gauss , kernel , lambda_amp , lambda_mu , lambda_sig , std_map ) elseif ( task ( 1 : 5 ) . eq . 'NEW_X' ) then !        1) Terminate if the total number of f and g evaluations !             exceeds maxiter. if ( isave ( 34 ) . ge . maxiter ) & task = 'STOP: TOTAL NO. of f AND g EVALUATIONS EXCEEDS LIMIT' !        2) Terminate if  |proj g|/(1+|f|) < 1.0d-10. if ( dsave ( 13 ) . le . 1.d-10 * ( 1.0d0 + abs ( f ))) & task = 'STOP: THE PROJECTED GRADIENT IS SUFFICIENTLY SMALL' endif !     end of loop do while end do end subroutine minimize ! Compute the objective function for a cube and the gradient of the obkective function subroutine f_g_cube ( f , g , cube , beta , dim_v , dim_y , dim_x , n_gauss , kernel , lambda_amp , lambda_mu , lambda_sig , & std_map ) implicit none integer , intent ( in ) :: n_gauss integer , intent ( in ) :: dim_v , dim_y , dim_x real ( xp ), intent ( in ) :: lambda_amp , lambda_mu , lambda_sig real ( xp ), intent ( in ), dimension (:), allocatable :: beta real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube real ( xp ), intent ( in ), dimension (:,:), allocatable :: kernel real ( xp ), intent ( in ), dimension (:,:), allocatable :: std_map real ( xp ), intent ( inout ) :: f real ( xp ), intent ( inout ), dimension (:), allocatable :: g integer :: i , j , k , l real ( xp ), dimension (:,:,:), allocatable :: residual real ( xp ), dimension (:), allocatable :: residual_1D real ( xp ), dimension (:,:,:), allocatable :: params real ( xp ), dimension (:,:), allocatable :: conv_amp , conv_mu , conv_sig real ( xp ), dimension (:,:), allocatable :: conv_conv_amp , conv_conv_mu , conv_conv_sig real ( xp ), dimension (:,:), allocatable :: image_amp , image_mu , image_sig real ( xp ), dimension (:,:,:), allocatable :: g_3D real ( xp ), dimension (:,:,:,:), allocatable :: dF_over_dB real ( xp ), dimension (:,:,:), allocatable :: dR_over_dB real ( xp ), dimension (:,:,:), allocatable :: deriv allocate ( dR_over_dB ( 3 * n_gauss , dim_y , dim_x )) allocate ( dF_over_dB ( 3 * n_gauss , dim_v , dim_y , dim_x )) allocate ( deriv ( 3 * n_gauss , dim_y , dim_x )) allocate ( g_3D ( 3 * n_gauss , dim_y , dim_x )) allocate ( residual ( dim_v , dim_y , dim_x )) allocate ( params ( 3 * n_gauss , dim_y , dim_x )) allocate ( conv_amp ( dim_y , dim_x ), conv_mu ( dim_y , dim_x ), conv_sig ( dim_y , dim_x )) allocate ( conv_conv_amp ( dim_y , dim_x ), conv_conv_mu ( dim_y , dim_x ), conv_conv_sig ( dim_y , dim_x )) allocate ( image_amp ( dim_y , dim_x ), image_mu ( dim_y , dim_x ), image_sig ( dim_y , dim_x )) dR_over_dB = 0._xp dF_over_dB = 0._xp deriv = 0._xp f = 0._xp g = 0._xp g_3D = 0._xp residual = 0._xp params = 0._xp call unravel_3D ( beta , params , 3 * n_gauss , dim_y , dim_x ) ! Compute the objective function and the gradient do j = 1 , dim_x do i = 1 , dim_y allocate ( residual_1D ( dim_v )) residual_1D = 0._xp call myresidual ( params (:, i , j ), cube (:, i , j ), residual_1D , n_gauss , dim_v ) residual (:, i , j ) = residual_1D if ( std_map ( i , j ) > 0._xp ) then f = f + ( myfunc_spec ( residual_1D ) / std_map ( i , j ) ** 2._xp ) end if deallocate ( residual_1D ) end do end do do l = 1 , dim_x do j = 1 , dim_y do i = 1 , n_gauss do k = 1 , dim_v dF_over_dB ( 1 + ( 3 * ( i - 1 )), k , j , l ) = dF_over_dB ( 1 + ( 3 * ( i - 1 )), k , j , l ) + & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l )) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 2._xp )) dF_over_dB ( 2 + ( 3 * ( i - 1 )), k , j , l ) = dF_over_dB ( 2 + ( 3 * ( i - 1 )), k , j , l ) + & params ( 1 + ( 3 * ( i - 1 )), j , l ) * ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l ) ) / ( params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 2._xp ) * & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l )) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 2._xp )) dF_over_dB ( 3 + ( 3 * ( i - 1 )), k , j , l ) = dF_over_dB ( 3 + ( 3 * ( i - 1 )), k , j , l ) + & params ( 1 + ( 3 * ( i - 1 )), j , l ) * ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l ) ) ** 2._xp / ( params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 3._xp ) * & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l )) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 2._xp )) enddo enddo end do end do do k = 1 , dim_v do j = 1 , dim_x do i = 1 , dim_y do l = 1 , 3 * n_gauss if ( std_map ( i , j ) > 0._xp ) then deriv ( l , i , j ) = deriv ( l , i , j ) + dF_over_dB ( l , k , i , j ) * ( residual ( k , i , j ) / std_map ( i , j ) ** 2._xp ) end if end do end do end do end do do k = 1 , n_gauss conv_amp = 0._xp ; conv_mu = 0._xp ; conv_sig = 0._xp conv_conv_amp = 0._xp ; conv_conv_mu = 0._xp ; conv_conv_sig = 0._xp image_amp = 0._xp ; image_mu = 0._xp ; image_sig = 0._xp image_amp = params ( 1 + ( 3 * ( k - 1 )),:,:) image_mu = params ( 2 + ( 3 * ( k - 1 )),:,:) image_sig = params ( 3 + ( 3 * ( k - 1 )),:,:) call convolution_2D_mirror ( image_amp , conv_amp , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( image_mu , conv_mu , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( image_sig , conv_sig , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( conv_amp , conv_conv_amp , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( conv_mu , conv_conv_mu , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( conv_sig , conv_conv_sig , dim_y , dim_x , kernel , 3 ) do j = 1 , dim_x do i = 1 , dim_y f = f + 0.5_xp * lambda_amp * conv_amp ( i , j ) ** 2 f = f + 0.5_xp * lambda_mu * conv_mu ( i , j ) ** 2 f = f + 0.5_xp * lambda_sig * conv_sig ( i , j ) ** 2 dR_over_dB ( 1 + ( 3 * ( k - 1 )), i , j ) = lambda_amp * conv_conv_amp ( i , j ) dR_over_dB ( 2 + ( 3 * ( k - 1 )), i , j ) = lambda_mu * conv_conv_mu ( i , j ) dR_over_dB ( 3 + ( 3 * ( k - 1 )), i , j ) = lambda_sig * conv_conv_sig ( i , j ) end do end do end do g_3D = deriv + dR_over_dB call ravel_3D ( g_3D , g , 3 * n_gauss , dim_y , dim_x ) end subroutine f_g_cube end module mod_optimize","tags":"","loc":"sourcefile/mod_optimize.f90.html","title":"mod_optimize.f90 – ROHSA"},{"text":"This module read the input user parameters (parameters.txt file / data / noise if true) This file depends on sourcefile~~mod_read.f90~~EfferentGraph sourcefile~mod_read.f90 mod_read.f90 sourcefile~mod_constants.f90 mod_constants.f90 sourcefile~mod_read.f90->sourcefile~mod_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mod_read.f90~~AfferentGraph sourcefile~mod_read.f90 mod_read.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_read.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_read Source Code mod_read.f90 Source Code !! This module read the input user parameters (parameters.txt file / data / noise if true) module mod_read !! This module read the input user parameters (parameters.txt file / data / noise if true) use mod_constants implicit none private public :: read_cube , read_map , read_parameters contains subroutine read_parameters ( filename_parameters , filename , fileout , filename_noise , n_gauss , lambda_amp , lambda_mu , & lambda_sig , maxiter_init , maxiter , m , noise , regul , lstd , ustd , iprint , iprint_init ) implicit none integer :: ios = 0 character ( len = 512 ), intent ( in ) :: filename_parameters integer , intent ( inout ) :: n_gauss integer , intent ( inout ) :: m integer , intent ( inout ) :: lstd , ustd integer , intent ( inout ) :: iprint , iprint_init integer , intent ( inout ) :: maxiter , maxiter_init real ( xp ), intent ( inout ) :: lambda_amp , lambda_mu , lambda_sig logical , intent ( inout ) :: noise , regul character ( len = 512 ), intent ( inout ) :: filename character ( len = 512 ), intent ( inout ) :: fileout character ( len = 512 ), intent ( inout ) :: filename_noise namelist / user_parameters / filename , fileout , filename_noise , n_gauss , lambda_amp , lambda_mu , & & lambda_sig , maxiter_init , maxiter , m , noise , regul , lstd , ustd , iprint , iprint_init open ( unit = 11 , file = filename_parameters , status = \"old\" , iostat = ios ) if ( ios /= 0 ) stop \"opening file error\" read ( 11 , user_parameters ) close ( 11 ) end subroutine read_parameters subroutine read_cube ( filename , cube ) implicit none integer :: ios = 0 , i integer :: v , y , x real ( xp ) :: val integer :: nv , ny , nx !cube dimension integer :: nl character ( len = 512 ), intent ( in ) :: filename real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube open ( unit = 11 , file = filename , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios /= 0 ) stop \"opening file error\" read ( 11 , fmt =* ) nv , ny , nx nl = nv * ny * nx allocate ( cube ( nv , ny , nx )) do i = 1 , nl read ( 11 , fmt =* ) v , y , x , val cube ( v + 1 , y + 1 , x + 1 ) = val enddo close ( 11 ) end subroutine read_cube subroutine read_map ( filename , map ) implicit none integer :: ios = 0 , i integer :: y , x real ( xp ) :: val integer :: ny , nx integer :: nl character ( len = 512 ), intent ( in ) :: filename real ( xp ), intent ( inout ), dimension (:,:), allocatable :: map open ( unit = 11 , file = filename , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios /= 0 ) stop \"opening file error\" read ( 11 , fmt =* ) ny , nx nl = ny * nx allocate ( map ( ny , nx )) do i = 1 , nl read ( 11 , fmt =* ) y , x , val map ( y + 1 , x + 1 ) = val enddo close ( 11 ) end subroutine read_map end Module mod_read","tags":"","loc":"sourcefile/mod_read.f90.html","title":"mod_read.f90 – ROHSA"},{"text":"Header/ender call module Files dependent on this one sourcefile~~mod_start.f90~~AfferentGraph sourcefile~mod_start.f90 mod_start.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_start.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_start Source Code mod_start.f90 Source Code !! Header/ender call module module mod_start !! Header/ender call module implicit none private public :: header , ender contains subroutine header () implicit none write ( * , * ) \"-------------------------------------------------------------------------\" call timestamp () write ( * , * ) \"\" write ( * , * ) \"  ____     ___    _   _   ____       _    \" write ( * , * ) \" |  _ \\   / _ \\  | | | | / ___|     / \\   \" write ( * , * ) \" | |_) | | | | | | |_| | \\___ \\    / _ \\  \" write ( * , * ) \" |  _ <  | |_| | |  _  |  ___) |  / ___ \\ \" write ( * , * ) \" |_| \\_\\  \\___/  |_| |_| |____/  /_/   \\_\\ \" write ( * , * ) \"\" write ( * , * ) \" Version 1.0.0\" write ( * , * ) \" ROHSA is released as open source code\" write ( * , * ) \" Check out the documentation: https://antoinemarchal.github.io/ROHSA/\" write ( * , * ) \"\" write ( * , * ) \"run: ./ROHSA parameters.txt\" write ( * , * ) \"-------------------------------------------------------------------------\" end subroutine header subroutine ender () implicit none write ( * , * ) \"##################################################################\" call timestamp () write ( * , * ) \" Terminate\" write ( * , * ) \"                        ROHSA ALGORITHM\" write ( * , * ) \"\" write ( * , * ) \"##################################################################\" end subroutine ender subroutine timestamp ( ) !*****************************************************************************80 ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! !  Example: ! !    31 May 2001   9:45:54.872 AM ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 May 2013 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return end subroutine timestamp end module mod_start","tags":"","loc":"sourcefile/mod_start.f90.html","title":"mod_start.f90 – ROHSA"},{"text":"L-BFGS-B submodule Contents Subroutines timer Source Code timer.f Source Code !! L-BFGS-B submodule c c  L-BFGS-B is released under the “New BSD License” (aka “Modified BSD License” c  or “3-clause license”) c  Please read attached file License.txt c subroutine timer ( ttime ) double precision ttime c real temp c c     This routine computes cpu time in double precision; it makes use of c     the intrinsic f90 cpu_time therefore a conversion type is c     needed. c c           J.L Morales  Departamento de Matematicas, c                        Instituto Tecnologico Autonomo de Mexico c                        Mexico D.F. c c           J.L Nocedal  Department of Electrical Engineering and c                        Computer Science. c                        Northwestern University. Evanston, IL. USA c c                        January 21, 2011 c temp = sngl ( ttime ) call cpu_time ( temp ) ttime = dble ( temp ) return end","tags":"","loc":"sourcefile/timer.f.html","title":"timer.f – ROHSA"},{"text":"function dnrm2(n, x, incx) Arguments Type Intent Optional Attributes Name integer :: n double precision :: x (n) Given a vector x of length n, this function calculates the Euclidean norm of x with stride incx. integer :: incx Return Value doubleprecision Contents None","tags":"","loc":"proc/dnrm2.html","title":"dnrm2 – ROHSA"},{"text":"function ddot(n, dx, incx, dy, incy) Arguments Type Intent Optional Attributes Name integer :: n double precision :: dx (*) integer :: incx double precision :: dy (*) integer :: incy Return Value doubleprecision Contents None","tags":"","loc":"proc/ddot.html","title":"ddot – ROHSA"},{"text":"subroutine daxpy(n, da, dx, incx, dy, incy) constant times a vector plus a vector.\n uses unrolled loops for increments equal to one.\n     jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n double precision :: da double precision :: dx (*) integer :: incx double precision :: dy (*) integer :: incy Called by proc~~daxpy~~CalledByGraph proc~daxpy daxpy proc~cauchy cauchy proc~cauchy->proc~daxpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/daxpy.html","title":"daxpy – ROHSA"},{"text":"subroutine dcopy(n, dx, incx, dy, incy) Arguments Type Intent Optional Attributes Name integer :: n double precision :: dx (*) integer :: incx double precision :: dy (*) integer :: incy Called by proc~~dcopy~~CalledByGraph proc~dcopy dcopy proc~cauchy cauchy proc~cauchy->proc~dcopy proc~lnsrlb lnsrlb proc~lnsrlb->proc~dcopy proc~mainlb mainlb proc~mainlb->proc~dcopy proc~subsm subsm proc~mainlb->proc~subsm proc~subsm->proc~dcopy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dcopy.html","title":"dcopy – ROHSA"},{"text":"subroutine dscal(n, da, dx, incx) Arguments Type Intent Optional Attributes Name integer :: n double precision :: da double precision :: dx (*) integer :: incx Called by proc~~dscal~~CalledByGraph proc~dscal dscal proc~mainlb mainlb proc~mainlb->proc~dscal proc~subsm subsm proc~mainlb->proc~subsm proc~subsm->proc~dscal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dscal.html","title":"dscal – ROHSA"},{"text":"subroutine setulb(n, m, x, l, u, nbd, f, g, factr, pgtol, wa, iwa, task, iprint, csave, lsave, isave, dsave) Arguments Type Intent Optional Attributes Name integer :: n integer :: m double precision :: x (n) double precision :: l (n) double precision :: u (n) integer :: nbd (n) double precision :: f double precision :: g (n) double precision :: factr double precision :: pgtol double precision :: wa (2*m*n+5*n+11*m*m+8*m) integer :: iwa (3*n) character(len=60) :: task integer :: iprint character(len=60) :: csave logical :: lsave (4) integer :: isave (44) double precision :: dsave (29) Called by proc~~setulb~~CalledByGraph proc~setulb setulb proc~minimize_spec minimize_spec proc~minimize_spec->proc~setulb proc~minimize minimize proc~minimize->proc~setulb proc~upgrade upgrade proc~upgrade->proc~minimize_spec proc~init_spectrum init_spectrum proc~init_spectrum->proc~minimize_spec proc~update update proc~update->proc~minimize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setulb.html","title":"setulb – ROHSA"},{"text":"subroutine mainlb(n, m, x, l, u, nbd, f, g, factr, pgtol, ws, wy, sy, ss, wt, wn, snd, z, r, d, t, xp, wa, index, iwhere, indx2, task, iprint, csave, lsave, isave, dsave) Arguments Type Intent Optional Attributes Name integer :: n integer :: m double precision :: x (n) double precision :: l (n) double precision :: u (n) integer :: nbd (n) double precision :: f double precision :: g (n) double precision :: factr double precision :: pgtol double precision :: ws (n,m) double precision :: wy (n,m) double precision :: sy (m,m) double precision :: ss (m,m) double precision :: wt (m,m) double precision :: wn (2*m,2*m) double precision :: snd (2*m,2*m) double precision :: z (n) double precision :: r (n) double precision :: d (n) double precision :: t (n) double precision :: xp (n) double precision :: wa (8*m) integer :: index (n) integer :: iwhere (n) integer :: indx2 (n) character(len=60) :: task integer :: iprint character(len=60) :: csave logical :: lsave (4) integer :: isave (23) double precision :: dsave (29) Calls proc~~mainlb~~CallsGraph proc~mainlb mainlb proc~cmprlb cmprlb proc~mainlb->proc~cmprlb proc~errclb errclb proc~mainlb->proc~errclb proc~dscal dscal proc~mainlb->proc~dscal proc~formt formt proc~mainlb->proc~formt proc~projgr projgr proc~mainlb->proc~projgr proc~prn1lb prn1lb proc~mainlb->proc~prn1lb proc~subsm subsm proc~mainlb->proc~subsm proc~prn3lb prn3lb proc~mainlb->proc~prn3lb proc~matupd matupd proc~mainlb->proc~matupd 2 2 proc~mainlb->2 proc~freev freev proc~mainlb->proc~freev proc~active active proc~mainlb->proc~active proc~prn2lb prn2lb proc~mainlb->proc~prn2lb proc~timer timer proc~mainlb->proc~timer proc~dcopy dcopy proc~mainlb->proc~dcopy proc~dpofa dpofa proc~formt->proc~dpofa 6 6 proc~prn1lb->6 proc~subsm->proc~dscal proc~subsm->proc~dcopy proc~dtrsl dtrsl proc~subsm->proc~dtrsl proc~prn3lb->2 proc~prn3lb->6 proc~prn2lb->2 proc~prn2lb->6 sngl sngl proc~timer->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mainlb.html","title":"mainlb – ROHSA"},{"text":"subroutine active(n, l, u, nbd, x, iwhere, iprint, prjctd, cnstnd, boxed) Arguments Type Intent Optional Attributes Name integer :: n double precision :: l (n) double precision :: u (n) integer :: nbd (n) double precision :: x (n) integer :: iwhere (n) integer :: iprint logical :: prjctd logical :: cnstnd logical :: boxed Called by proc~~active~~CalledByGraph proc~active active proc~mainlb mainlb proc~mainlb->proc~active Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/active.html","title":"active – ROHSA"},{"text":"subroutine bmv(m, sy, wt, col, v, p, info) Arguments Type Intent Optional Attributes Name integer :: m double precision :: sy (m,m) double precision :: wt (m,m) integer :: col double precision :: v (2*col) double precision :: p (2*col) integer :: info Called by proc~~bmv~~CalledByGraph proc~bmv bmv proc~cauchy cauchy proc~cauchy->proc~bmv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bmv.html","title":"bmv – ROHSA"},{"text":"subroutine cauchy(n, x, l, u, nbd, g, iorder, iwhere, t, d, xcp, m, wy, ws, sy, wt, theta, col, head, p, c, wbp, v, nseg, iprint, sbgnrm, info, epsmch) Arguments Type Intent Optional Attributes Name integer :: n double precision :: x (n) double precision :: l (n) double precision :: u (n) integer :: nbd (n) double precision :: g (n) integer :: iorder (n) integer :: iwhere (n) double precision :: t (n) double precision :: d (n) double precision :: xcp (n) integer :: m double precision :: wy (n,col) double precision :: ws (n,col) double precision :: sy (m,m) double precision :: wt (m,m) double precision :: theta integer :: col integer :: head double precision :: p (2*m) double precision :: c (2*m) double precision :: wbp (2*m) double precision :: v (2*m) integer :: nseg integer :: iprint double precision :: sbgnrm integer :: info double precision :: epsmch Calls proc~~cauchy~~CallsGraph proc~cauchy cauchy proc~hpsolb hpsolb proc~cauchy->proc~hpsolb proc~daxpy daxpy proc~cauchy->proc~daxpy 2 2 proc~cauchy->2 6 6 proc~cauchy->6 proc~bmv bmv proc~cauchy->proc~bmv proc~dcopy dcopy proc~cauchy->proc~dcopy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cauchy.html","title":"cauchy – ROHSA"},{"text":"subroutine cmprlb(n, m, x, g, ws, wy, sy, wt, z, r, wa, index, theta, col, head, nfree, cnstnd, info) Arguments Type Intent Optional Attributes Name integer :: n integer :: m double precision :: x (n) double precision :: g (n) double precision :: ws (n,m) double precision :: wy (n,m) double precision :: sy (m,m) double precision :: wt (m,m) double precision :: z (n) double precision :: r (n) double precision :: wa (4*m) integer :: index (n) double precision :: theta integer :: col integer :: head integer :: nfree logical :: cnstnd integer :: info Called by proc~~cmprlb~~CalledByGraph proc~cmprlb cmprlb proc~mainlb mainlb proc~mainlb->proc~cmprlb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cmprlb.html","title":"cmprlb – ROHSA"},{"text":"subroutine errclb(n, m, factr, l, u, nbd, task, info, k) Arguments Type Intent Optional Attributes Name integer :: n integer :: m double precision :: factr double precision :: l (n) double precision :: u (n) integer :: nbd (n) character(len=60) :: task integer :: info integer :: k Called by proc~~errclb~~CalledByGraph proc~errclb errclb proc~mainlb mainlb proc~mainlb->proc~errclb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/errclb.html","title":"errclb – ROHSA"},{"text":"subroutine formk(n, nsub, ind, nenter, ileave, indx2, iupdat, updatd, wn, wn1, m, ws, wy, sy, theta, col, head, info) Arguments Type Intent Optional Attributes Name integer :: n integer :: nsub integer :: ind (n) integer :: nenter integer :: ileave integer :: indx2 (n) integer :: iupdat logical :: updatd double precision :: wn (2*m,2*m) double precision :: wn1 (2*m,2*m) integer :: m double precision :: ws (n,m) double precision :: wy (n,m) double precision :: sy (m,m) double precision :: theta integer :: col integer :: head integer :: info Calls proc~~formk~~CallsGraph proc~formk formk proc~dpofa dpofa proc~formk->proc~dpofa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/formk.html","title":"formk – ROHSA"},{"text":"subroutine formt(m, wt, sy, ss, col, theta, info) Arguments Type Intent Optional Attributes Name integer :: m double precision :: wt (m,m) double precision :: sy (m,m) double precision :: ss (m,m) integer :: col double precision :: theta integer :: info Calls proc~~formt~~CallsGraph proc~formt formt proc~dpofa dpofa proc~formt->proc~dpofa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~formt~~CalledByGraph proc~formt formt proc~mainlb mainlb proc~mainlb->proc~formt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/formt.html","title":"formt – ROHSA"},{"text":"subroutine freev(n, nfree, index, nenter, ileave, indx2, iwhere, wrk, updatd, cnstnd, iprint, iter) Arguments Type Intent Optional Attributes Name integer :: n integer :: nfree integer :: index (n) integer :: nenter integer :: ileave integer :: indx2 (n) integer :: iwhere (n) logical :: wrk logical :: updatd logical :: cnstnd integer :: iprint integer :: iter Called by proc~~freev~~CalledByGraph proc~freev freev proc~mainlb mainlb proc~mainlb->proc~freev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/freev.html","title":"freev – ROHSA"},{"text":"subroutine hpsolb(n, t, iorder, iheap) Arguments Type Intent Optional Attributes Name integer :: n double precision :: t (n) integer :: iorder (n) integer :: iheap Called by proc~~hpsolb~~CalledByGraph proc~hpsolb hpsolb proc~cauchy cauchy proc~cauchy->proc~hpsolb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hpsolb.html","title":"hpsolb – ROHSA"},{"text":"subroutine lnsrlb(n, l, u, nbd, x, f, fold, gd, gdold, g, d, r, t, z, stp, dnorm, dtd, xstep, stpmx, iter, ifun, iback, nfgv, info, task, boxed, cnstnd, csave, isave, dsave) Arguments Type Intent Optional Attributes Name integer :: n double precision :: l (n) double precision :: u (n) integer :: nbd (n) double precision :: x (n) double precision :: f double precision :: fold double precision :: gd double precision :: gdold double precision :: g (n) double precision :: d (n) double precision :: r (n) double precision :: t (n) double precision :: z (n) double precision :: stp double precision :: dnorm double precision :: dtd double precision :: xstep double precision :: stpmx integer :: iter integer :: ifun integer :: iback integer :: nfgv integer :: info character(len=60) :: task logical :: boxed logical :: cnstnd character(len=60) :: csave integer :: isave (2) double precision :: dsave (13) Calls proc~~lnsrlb~~CallsGraph proc~lnsrlb lnsrlb proc~dcsrch dcsrch proc~lnsrlb->proc~dcsrch proc~dcopy dcopy proc~lnsrlb->proc~dcopy proc~dcstep dcstep proc~dcsrch->proc~dcstep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lnsrlb.html","title":"lnsrlb – ROHSA"},{"text":"subroutine matupd(n, m, ws, wy, sy, ss, d, r, itail, iupdat, col, head, theta, rr, dr, stp, dtd) Arguments Type Intent Optional Attributes Name integer :: n integer :: m double precision :: ws (n,m) double precision :: wy (n,m) double precision :: sy (m,m) double precision :: ss (m,m) double precision :: d (n) double precision :: r (n) integer :: itail integer :: iupdat integer :: col integer :: head double precision :: theta double precision :: rr double precision :: dr double precision :: stp double precision :: dtd Called by proc~~matupd~~CalledByGraph proc~matupd matupd proc~mainlb mainlb proc~mainlb->proc~matupd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/matupd.html","title":"matupd – ROHSA"},{"text":"subroutine prn1lb(n, m, l, u, x, iprint, itfile, epsmch) Arguments Type Intent Optional Attributes Name integer :: n integer :: m double precision :: l (n) double precision :: u (n) double precision :: x (n) integer :: iprint integer :: itfile double precision :: epsmch Calls proc~~prn1lb~~CallsGraph proc~prn1lb prn1lb 6 6 proc~prn1lb->6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~prn1lb~~CalledByGraph proc~prn1lb prn1lb proc~mainlb mainlb proc~mainlb->proc~prn1lb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/prn1lb.html","title":"prn1lb – ROHSA"},{"text":"subroutine prn2lb(n, x, f, g, iprint, itfile, iter, nfgv, nact, sbgnrm, nseg, word, iword, iback, stp, xstep) Arguments Type Intent Optional Attributes Name integer :: n double precision :: x (n) double precision :: f double precision :: g (n) integer :: iprint integer :: itfile integer :: iter integer :: nfgv integer :: nact double precision :: sbgnrm integer :: nseg character(len=3) :: word integer :: iword integer :: iback double precision :: stp double precision :: xstep Calls proc~~prn2lb~~CallsGraph proc~prn2lb prn2lb 2 2 proc~prn2lb->2 6 6 proc~prn2lb->6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~prn2lb~~CalledByGraph proc~prn2lb prn2lb proc~mainlb mainlb proc~mainlb->proc~prn2lb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/prn2lb.html","title":"prn2lb – ROHSA"},{"text":"subroutine prn3lb(n, x, f, task, iprint, info, itfile, iter, nfgv, nintol, nskip, nact, sbgnrm, time, nseg, word, iback, stp, xstep, k, cachyt, sbtime, lnscht) Arguments Type Intent Optional Attributes Name integer :: n double precision :: x (n) double precision :: f character(len=60) :: task integer :: iprint integer :: info integer :: itfile integer :: iter integer :: nfgv integer :: nintol integer :: nskip integer :: nact double precision :: sbgnrm double precision :: time integer :: nseg character(len=3) :: word integer :: iback double precision :: stp double precision :: xstep integer :: k double precision :: cachyt double precision :: sbtime double precision :: lnscht Calls proc~~prn3lb~~CallsGraph proc~prn3lb prn3lb 2 2 proc~prn3lb->2 6 6 proc~prn3lb->6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~prn3lb~~CalledByGraph proc~prn3lb prn3lb proc~mainlb mainlb proc~mainlb->proc~prn3lb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/prn3lb.html","title":"prn3lb – ROHSA"},{"text":"subroutine projgr(n, l, u, nbd, x, g, sbgnrm) Arguments Type Intent Optional Attributes Name integer :: n double precision :: l (n) double precision :: u (n) integer :: nbd (n) double precision :: x (n) double precision :: g (n) double precision :: sbgnrm Called by proc~~projgr~~CalledByGraph proc~projgr projgr proc~mainlb mainlb proc~mainlb->proc~projgr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/projgr.html","title":"projgr – ROHSA"},{"text":"subroutine subsm(n, m, nsub, ind, l, u, nbd, x, d, xp, ws, wy, theta, xx, gg, col, head, iword, wv, wn, iprint, info) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: nsub integer :: ind (nsub) double precision :: l (n) double precision :: u (n) integer :: nbd (n) double precision :: x (n) double precision :: d (n) double precision :: xp (n) double precision :: ws (n,m) double precision :: wy (n,m) double precision :: theta double precision :: xx (n) double precision :: gg (n) integer :: col integer :: head integer :: iword double precision :: wv (2*m) double precision :: wn (2*m,2*m) integer :: iprint integer :: info Calls proc~~subsm~~CallsGraph proc~subsm subsm proc~dtrsl dtrsl proc~subsm->proc~dtrsl proc~dscal dscal proc~subsm->proc~dscal proc~dcopy dcopy proc~subsm->proc~dcopy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~subsm~~CalledByGraph proc~subsm subsm proc~mainlb mainlb proc~mainlb->proc~subsm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subsm.html","title":"subsm – ROHSA"},{"text":"subroutine dcsrch(f, g, stp, ftol, gtol, xtol, stpmin, stpmax, task, isave, dsave) Arguments Type Intent Optional Attributes Name double precision :: f double precision :: g double precision :: stp double precision :: ftol double precision :: gtol double precision :: xtol double precision :: stpmin double precision :: stpmax character(len=*) :: task integer :: isave (2) double precision :: dsave (13) Calls proc~~dcsrch~~CallsGraph proc~dcsrch dcsrch proc~dcstep dcstep proc~dcsrch->proc~dcstep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dcsrch~~CalledByGraph proc~dcsrch dcsrch proc~lnsrlb lnsrlb proc~lnsrlb->proc~dcsrch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dcsrch.html","title":"dcsrch – ROHSA"},{"text":"subroutine dcstep(stx, fx, dx, sty, fy, dy, stp, fp, dp, brackt, stpmin, stpmax) Arguments Type Intent Optional Attributes Name double precision :: stx double precision :: fx double precision :: dx double precision :: sty double precision :: fy double precision :: dy double precision :: stp double precision :: fp double precision :: dp logical :: brackt double precision :: stpmin double precision :: stpmax Called by proc~~dcstep~~CalledByGraph proc~dcstep dcstep proc~dcsrch dcsrch proc~dcsrch->proc~dcstep proc~lnsrlb lnsrlb proc~lnsrlb->proc~dcsrch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dcstep.html","title":"dcstep – ROHSA"},{"text":"subroutine dpofa(a, lda, n, info) Arguments Type Intent Optional Attributes Name double precision :: a (lda,*) integer :: lda integer :: n integer :: info Called by proc~~dpofa~~CalledByGraph proc~dpofa dpofa proc~formt formt proc~formt->proc~dpofa proc~formk formk proc~formk->proc~dpofa proc~mainlb mainlb proc~mainlb->proc~formt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dpofa.html","title":"dpofa – ROHSA"},{"text":"subroutine dtrsl(t, ldt, n, b, job, info) Arguments Type Intent Optional Attributes Name double precision :: t (ldt,*) integer :: ldt integer :: n double precision :: b (*) integer :: job integer :: info Called by proc~~dtrsl~~CalledByGraph proc~dtrsl dtrsl proc~subsm subsm proc~subsm->proc~dtrsl proc~mainlb mainlb proc~mainlb->proc~subsm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dtrsl.html","title":"dtrsl – ROHSA"},{"text":"subroutine timer(ttime) Arguments Type Intent Optional Attributes Name double precision :: ttime Calls proc~~timer~~CallsGraph proc~timer timer sngl sngl proc~timer->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~timer~~CalledByGraph proc~timer timer proc~mainlb mainlb proc~mainlb->proc~timer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timer.html","title":"timer – ROHSA"},{"text":"public subroutine convolution_2D_mirror(image, conv, dim_y, dim_x, kernel, dim_k) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:), allocatable :: image real(kind=xp), intent(inout), dimension(:,:), allocatable :: conv integer, intent(in) :: dim_y integer, intent(in) :: dim_x real(kind=xp), intent(in), dimension(:,:), allocatable :: kernel integer, intent(in) :: dim_k Called by proc~~convolution_2d_mirror~~CalledByGraph proc~convolution_2d_mirror convolution_2D_mirror proc~f_g_cube f_g_cube proc~f_g_cube->proc~convolution_2d_mirror proc~minimize minimize proc~minimize->proc~f_g_cube proc~update update proc~update->proc~minimize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code convolution_2D_mirror Source Code subroutine convolution_2D_mirror ( image , conv , dim_y , dim_x , kernel , dim_k ) implicit none real ( xp ), intent ( in ), dimension (:,:), allocatable :: image real ( xp ), intent ( inout ), dimension (:,:), allocatable :: conv real ( xp ), intent ( in ), dimension (:,:), allocatable :: kernel integer , intent ( in ) :: dim_y , dim_x , dim_k integer :: i , j , ii , jj , m , n , mm , nn integer :: kCenterY , kCenterX real ( xp ), dimension (:,:), allocatable :: ext_conv , extended allocate ( ext_conv ( dim_y + 4 , dim_x + 4 )) allocate ( extended ( dim_y + 4 , dim_x + 4 )) ii = 0 ; jj = 0 ; mm = 0 ; nn = 0 kCenterY = 0 ; kCenterX = 0 ext_conv = 0._xp extended = 0._xp do j = 1 , dim_x do i = 1 , dim_y extended ( 2 + i , 2 + j ) = image ( i , j ) end do end do do j = 1 , 2 do i = 1 , dim_y extended ( 2 + i , j ) = image ( i , j ); end do end do do i = 1 , 2 do j = 1 , dim_x extended ( i , 2 + j ) = image ( i , j ); end do end do do j = dim_x + 1 , dim_x + 2 do i = 1 , dim_y extended ( 2 + i , 2 + j ) = image ( i , j - 2 ) end do end do do j = 1 , dim_x do i = dim_y + 1 , dim_y + 2 extended ( 2 + i , 2 + j ) = image ( i - 2 , j ) end do end do kCenterY = dim_k / 2 + 1 kCenterX = kCenterY do j = 1 , dim_x + 4 do i = 1 , dim_y + 4 do m = 1 , dim_k mm = dim_k - m + 1 do n = 1 , dim_k nn = dim_k - n + 1 ii = i + ( m - kCenterY ) jj = j + ( n - kCenterX ) if ( ii >= 1 . and . ii < dim_y + 4 . and . jj >= 1 . and . jj < dim_x + 4 ) then ext_conv ( i , j ) = ext_conv ( i , j ) + extended ( ii , jj ) * kernel ( mm , nn ) end if end do end do end do end do do j = 1 , dim_x do i = 1 , dim_y conv ( i , j ) = ext_conv ( 2 + i , 2 + j ) end do end do end subroutine convolution_2D_mirror","tags":"","loc":"proc/convolution_2d_mirror.html","title":"convolution_2D_mirror – ROHSA"},{"text":"public subroutine ravel_3D(cube, vector, dim_v, dim_y, dim_x) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube real(kind=xp), intent(inout), dimension(:), allocatable :: vector integer, intent(in) :: dim_v integer, intent(in) :: dim_y integer, intent(in) :: dim_x Called by proc~~ravel_3d~~CalledByGraph proc~ravel_3d ravel_3D proc~update update proc~update->proc~ravel_3d proc~minimize minimize proc~update->proc~minimize proc~f_g_cube f_g_cube proc~f_g_cube->proc~ravel_3d proc~minimize->proc~f_g_cube Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ravel_3D Source Code subroutine ravel_3D ( cube , vector , dim_v , dim_y , dim_x ) implicit none integer , intent ( in ) :: dim_v , dim_y , dim_x real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube real ( xp ), intent ( inout ), dimension (:), allocatable :: vector integer :: i , j , k , i__ i__ = 1 do k = 1 , dim_x do j = 1 , dim_y do i = 1 , dim_v vector ( i__ ) = cube ( i , j , k ) i__ = i__ + 1 end do end do end do end subroutine ravel_3D","tags":"","loc":"proc/ravel_3d.html","title":"ravel_3D – ROHSA"},{"text":"public subroutine unravel_3D(vector, cube, dim_v, dim_y, dim_x) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:), allocatable :: vector real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube integer, intent(in) :: dim_v integer, intent(in) :: dim_y integer, intent(in) :: dim_x Called by proc~~unravel_3d~~CalledByGraph proc~unravel_3d unravel_3D proc~update update proc~update->proc~unravel_3d proc~minimize minimize proc~update->proc~minimize proc~f_g_cube f_g_cube proc~f_g_cube->proc~unravel_3d proc~minimize->proc~f_g_cube Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code unravel_3D Source Code subroutine unravel_3D ( vector , cube , dim_v , dim_y , dim_x ) implicit none integer , intent ( in ) :: dim_v , dim_y , dim_x real ( xp ), intent ( in ), dimension (:), allocatable :: vector real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube integer :: i , j , k , i__ i__ = 1 do k = 1 , dim_x do j = 1 , dim_y do i = 1 , dim_v cube ( i , j , k ) = vector ( i__ ) i__ = i__ + 1 end do end do end do end subroutine unravel_3D","tags":"","loc":"proc/unravel_3d.html","title":"unravel_3D – ROHSA"},{"text":"public pure function dim2nside(dim_cube) Compute nside value from dim_y and dim_x Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dim_cube cube dimension Return Value integer nside of the cube Called by proc~~dim2nside~~CalledByGraph proc~dim2nside dim2nside program~rohsa ROHSA program~rohsa->proc~dim2nside Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dim2nside Source Code pure function dim2nside ( dim_cube ) !! Compute nside value from dim_y and dim_x implicit none integer :: dim2nside !! nside of the cube integer , intent ( in ), dimension ( 3 ) :: dim_cube !! cube dimension dim2nside = max ( 0 , int ( ceiling ( log ( real ( dim_cube ( 2 ))) / log ( 2. ))), int ( ceiling ( log ( real ( dim_cube ( 3 ))) / log ( 2. )))) return end function dim2nside","tags":"","loc":"proc/dim2nside.html","title":"dim2nside – ROHSA"},{"text":"private pure function std(array) Compute the STD of a 1D array Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:) :: array 1D array Return Value real(kind=xp) standard deviation Called by proc~~std~~CalledByGraph proc~std std proc~set_stdmap set_stdmap proc~set_stdmap->proc~std program~rohsa ROHSA program~rohsa->proc~set_stdmap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code std Source Code pure function std ( array ) !! Compute the STD of a 1D array implicit none real ( xp ), intent ( in ), dimension (:) :: array !! 1D array integer :: i integer :: n real ( xp ) :: std !! standard deviation real ( xp ) :: mean real ( xp ) :: var mean = 0._xp ; var = 0._xp std = 0._xp n = size ( array ) mean = sum ( array ) / n do i = 1 , n var = var + ( array ( i ) - mean ) ** 2._xp end do var = var / ( n - 1 ) std = sqrt ( var ) return end function std","tags":"","loc":"proc/std.html","title":"std – ROHSA"},{"text":"public subroutine dim_data2dim_cube(nside, dim_data, dim_cube) Arguments Type Intent Optional Attributes Name integer :: nside integer, intent(in), dimension(3) :: dim_data integer, intent(inout), dimension(3) :: dim_cube Called by proc~~dim_data2dim_cube~~CalledByGraph proc~dim_data2dim_cube dim_data2dim_cube program~rohsa ROHSA program~rohsa->proc~dim_data2dim_cube Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dim_data2dim_cube Source Code subroutine dim_data2dim_cube ( nside , dim_data , dim_cube ) implicit none integer , intent ( in ), dimension ( 3 ) :: dim_data integer , intent ( inout ), dimension ( 3 ) :: dim_cube integer :: nside dim_cube ( 1 ) = dim_data ( 1 ) dim_cube ( 2 ) = 2 ** nside dim_cube ( 3 ) = dim_cube ( 2 ) end subroutine dim_data2dim_cube","tags":"","loc":"proc/dim_data2dim_cube.html","title":"dim_data2dim_cube – ROHSA"},{"text":"public subroutine reshape_up(data, cube, dim_data, dim_cube) Reshape the data in a grid of 2&#94;{nside} Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: data original cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube reshape cube integer, intent(in), dimension(3) :: dim_data original cube dimension integer, intent(in), dimension(3) :: dim_cube new cube dimension Called by proc~~reshape_up~~CalledByGraph proc~reshape_up reshape_up program~rohsa ROHSA program~rohsa->proc~reshape_up Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code reshape_up Source Code subroutine reshape_up ( data , cube , dim_data , dim_cube ) !! Reshape the data in a grid of  2&#94;{nside}  implicit none real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: data !! original cube real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube !! reshape cube integer , intent ( in ), dimension ( 3 ) :: dim_data !! original cube dimension integer , intent ( in ), dimension ( 3 ) :: dim_cube !! new cube dimension integer :: offset_w , offset_h offset_w = ( dim_cube ( 2 ) - dim_data ( 2 )) / 2 offset_h = ( dim_cube ( 3 ) - dim_data ( 3 )) / 2 cube (:, offset_w + 1 : offset_w + dim_data ( 2 ), offset_h + 1 : offset_h + dim_data ( 3 )) = data end subroutine reshape_up","tags":"","loc":"proc/reshape_up.html","title":"reshape_up – ROHSA"},{"text":"public subroutine reshape_down(cube, data, dim_cube, dim_data) Reshape the cube ( 2&#94;{nside} ) into a grid with original dimension (opposite of reshape_up) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube original cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: data reshape cube integer, intent(in), dimension(3) :: dim_cube new cube dimension integer, intent(in), dimension(3) :: dim_data original cube dimension Contents Source Code reshape_down Source Code subroutine reshape_down ( cube , data , dim_cube , dim_data ) !! Reshape the cube ( 2&#94;{nside} ) into a grid with original dimension (opposite of reshape_up) implicit none real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! original cube real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: data !! reshape cube integer , intent ( in ), dimension ( 3 ) :: dim_data !! original cube dimension integer , intent ( in ), dimension ( 3 ) :: dim_cube !! new cube dimension integer :: offset_w , offset_h offset_w = ( dim_cube ( 2 ) - dim_data ( 2 )) / 2 offset_h = ( dim_cube ( 3 ) - dim_data ( 3 )) / 2 data = cube (:, offset_w + 1 : offset_w + dim_data ( 2 ), offset_h + 1 : offset_h + dim_data ( 3 )) end subroutine reshape_down","tags":"","loc":"proc/reshape_down.html","title":"reshape_down – ROHSA"},{"text":"public subroutine mean_array(nside, cube, cube_mean) Average cube along spatial axis depending on level n Arguments Type Intent Optional Attributes Name integer, intent(in) :: nside nside of the cube real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube_mean average cube Called by proc~~mean_array~~CalledByGraph proc~mean_array mean_array program~rohsa ROHSA program~rohsa->proc~mean_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mean_array Source Code subroutine mean_array ( nside , cube , cube_mean ) !! Average cube along spatial axis depending on level n implicit none integer , intent ( in ) :: nside !! nside of the cube real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! cube real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube_mean !! average cube integer :: i , j , k , l , n real ( xp ), dimension (:), allocatable :: spectrum allocate ( spectrum ( size ( cube , dim = 1 ))) spectrum = 0. n = size ( cube , dim = 2 ) / nside do i = 1 , size ( cube_mean , dim = 2 ) do j = 1 , size ( cube_mean , dim = 3 ) do k = 1 , n do l = 1 , n spectrum = spectrum + cube (:, k + (( i - 1 ) * n ), l + (( j - 1 ) * n )) enddo enddo spectrum = spectrum / ( n ** 2 ) cube_mean (:, i , j ) = spectrum spectrum = 0. enddo enddo end subroutine mean_array","tags":"","loc":"proc/mean_array.html","title":"mean_array – ROHSA"},{"text":"public subroutine mean_map(nside, map, map_mean) Average map depending on level nside Arguments Type Intent Optional Attributes Name integer, intent(in) :: nside nside real(kind=xp), intent(in), dimension(:,:), allocatable :: map map real(kind=xp), intent(inout), dimension(:,:), allocatable :: map_mean avarage map Called by proc~~mean_map~~CalledByGraph proc~mean_map mean_map program~rohsa ROHSA program~rohsa->proc~mean_map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mean_map Source Code subroutine mean_map ( nside , map , map_mean ) !! Average map depending on level nside implicit none integer , intent ( in ) :: nside !! nside real ( xp ), intent ( in ), dimension (:,:), allocatable :: map !! map real ( xp ), intent ( inout ), dimension (:,:), allocatable :: map_mean !! avarage map integer :: i , j , k , l , n real ( xp ) :: val val = 0. n = size ( map , dim = 2 ) / nside do i = 1 , size ( map_mean , dim = 1 ) do j = 1 , size ( map_mean , dim = 2 ) do k = 1 , n do l = 1 , n val = val + map ( k + (( i - 1 ) * n ), l + (( j - 1 ) * n )) enddo enddo val = val / ( n ** 2 ) map_mean ( i , j ) = val val = 0. enddo enddo end subroutine mean_map","tags":"","loc":"proc/mean_map.html","title":"mean_map – ROHSA"},{"text":"public subroutine go_up_level(cube_params) Projection of the solution at next level (nside += 1) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube_params cube of parameters Called by proc~~go_up_level~~CalledByGraph proc~go_up_level go_up_level program~rohsa ROHSA program~rohsa->proc~go_up_level Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code go_up_level Source Code subroutine go_up_level ( cube_params ) !! Projection of the solution at next level (nside += 1) implicit none real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube_params !! cube of parameters integer :: i , j , k , l real ( xp ), dimension (:,:,:), allocatable :: cube_params_down integer , dimension ( 3 ) :: dim dim = shape ( cube_params ) allocate ( cube_params_down ( dim ( 1 ), dim ( 2 ), dim ( 3 ))) cube_params_down = 0._xp cube_params_down = cube_params deallocate ( cube_params ) allocate ( cube_params ( dim ( 1 ), dim ( 2 ) * 2 , dim ( 3 ) * 2 )) cube_params = 0._xp do i = 1 , size ( cube_params_down , dim = 2 ) do j = 1 , size ( cube_params_down , dim = 3 ) do k = 1 , 2 do l = 1 , 2 cube_params (:, k + (( i - 1 ) * 2 ), l + (( j - 1 ) * 2 )) = cube_params_down (:, i , j ) enddo enddo enddo enddo end subroutine go_up_level","tags":"","loc":"proc/go_up_level.html","title":"go_up_level – ROHSA"},{"text":"public subroutine init_spectrum(n_gauss, params, dim_v, line, maxiter, m, iprint) Initialization of the mean sprectrum with N Gaussian Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_gauss number of Gaussian real(kind=xp), intent(inout), dimension(3*n_gauss) :: params params to optimize integer, intent(in) :: dim_v dimension along v axis real(kind=xp), intent(in), dimension(dim_v) :: line spectrum integer, intent(in) :: maxiter Max number of iteration integer, intent(in) :: m number of corrections used in the limited memory matrix by LBFGS-B integer, intent(in) :: iprint print option Calls proc~~init_spectrum~~CallsGraph proc~init_spectrum init_spectrum proc~init_bounds init_bounds proc~init_spectrum->proc~init_bounds proc~minimize_spec minimize_spec proc~init_spectrum->proc~minimize_spec proc~gaussian gaussian proc~init_spectrum->proc~gaussian proc~myfunc_spec myfunc_spec proc~minimize_spec->proc~myfunc_spec proc~setulb setulb proc~minimize_spec->proc~setulb proc~myresidual myresidual proc~minimize_spec->proc~myresidual proc~mygrad_spec mygrad_spec proc~minimize_spec->proc~mygrad_spec proc~myresidual->proc~gaussian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code init_spectrum Source Code subroutine init_spectrum ( n_gauss , params , dim_v , line , maxiter , m , iprint ) !! Initialization of the mean sprectrum with N Gaussian implicit none integer , intent ( in ) :: n_gauss !! number of Gaussian integer , intent ( in ) :: dim_v !! dimension along v axis integer , intent ( in ) :: maxiter !! Max number of iteration integer , intent ( in ) :: m !! number of corrections used in the limited memory matrix by LBFGS-B integer , intent ( in ) :: iprint !! print option real ( xp ), intent ( in ), dimension ( dim_v ) :: line !! spectrum real ( xp ), intent ( inout ), dimension ( 3 * n_gauss ) :: params !! params to optimize integer :: i , j , k , p real ( xp ), dimension (:), allocatable :: lb , ub real ( xp ), dimension ( dim_v ) :: model , residual real ( xp ), dimension (:), allocatable :: x do i = 1 , n_gauss allocate ( lb ( 3 * i ), ub ( 3 * i )) model = 0._xp residual = 0._xp lb = 0._xp ; ub = 0._xp call init_bounds ( line , i , dim_v , lb , ub ) do j = 1 , i do k = 1 , dim_v model ( k ) = model ( k ) + gaussian ( k , params ( 1 + ( 3 * ( j - 1 ))), params ( 2 + ( 3 * ( j - 1 ))), params ( 3 + ( 3 * ( j - 1 )))) end do enddo residual = model - line allocate ( x ( 3 * i )) x = 0._xp do p = 1 , 3 * ( i - 1 ) x ( p ) = params ( p ); end do x ( 2 + ( 3 * ( i - 1 ))) = minloc ( residual , dim_v ) x ( 1 + ( 3 * ( i - 1 ))) = line ( int ( x ( 2 + ( 3 * ( i - 1 ))))) * 2._xp / 3._xp x ( 3 + ( 3 * ( i - 1 ))) = 5._xp ; call minimize_spec ( 3 * i , m , x , lb , ub , line , dim_v , i , maxiter , iprint ) do p = 1 , 3 * i params ( p ) = x ( p ); end do deallocate ( x ) deallocate ( lb , ub ) enddo end subroutine init_spectrum","tags":"","loc":"proc/init_spectrum.html","title":"init_spectrum – ROHSA"},{"text":"private subroutine init_bounds(line, n_gauss, dim_v, lb, ub) Initialize parameters bounds for optimization Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(dim_v) :: line spectrum integer, intent(in) :: n_gauss number of Gaussian integer, intent(in) :: dim_v dimension along v axis real(kind=xp), intent(inout), dimension(3*n_gauss) :: lb lower bounds real(kind=xp), intent(inout), dimension(3*n_gauss) :: ub upper bounds Called by proc~~init_bounds~~CalledByGraph proc~init_bounds init_bounds proc~upgrade upgrade proc~upgrade->proc~init_bounds proc~init_spectrum init_spectrum proc~init_spectrum->proc~init_bounds Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code init_bounds Source Code subroutine init_bounds ( line , n_gauss , dim_v , lb , ub ) !! Initialize parameters bounds for optimization implicit none integer , intent ( in ) :: n_gauss !! number of Gaussian integer , intent ( in ) :: dim_v !! dimension along v axis real ( xp ), intent ( in ), dimension ( dim_v ) :: line !! spectrum real ( xp ), intent ( inout ), dimension ( 3 * n_gauss ) :: lb !! lower bounds real ( xp ), intent ( inout ), dimension ( 3 * n_gauss ) :: ub !! upper bounds integer :: i real ( xp ) :: max_line max_line = 0._xp max_line = maxval ( line ) do i = 1 , n_gauss ! amplitude bounds lb ( 1 + ( 3 * ( i - 1 ))) = 0._xp ; ub ( 1 + ( 3 * ( i - 1 ))) = max_line ; ! mean bounds lb ( 2 + ( 3 * ( i - 1 ))) = 0._xp ; ub ( 2 + ( 3 * ( i - 1 ))) = dim_v ; ! sigma bounds lb ( 3 + ( 3 * ( i - 1 ))) = 0.001_xp ; ub ( 3 + ( 3 * ( i - 1 ))) = 10 0._xp ; end do end subroutine init_bounds","tags":"","loc":"proc/init_bounds.html","title":"init_bounds – ROHSA"},{"text":"public subroutine upgrade(cube, params, power, n_gauss, dim_v, maxiter, m, iprint) Upgrade parameters (spectra to spectra) using minimize function (here based on L-BFGS-B optimization module) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: params cube parameters to update integer, intent(in) :: power nside of the cube integer, intent(in) :: n_gauss number of Gaussian integer, intent(in) :: dim_v dimension along v axis integer, intent(in) :: maxiter max number of iteration integer, intent(in) :: m number of corrections used in the limited memory matrix by LBFGS-B integer, intent(in) :: iprint print option Calls proc~~upgrade~~CallsGraph proc~upgrade upgrade proc~init_bounds init_bounds proc~upgrade->proc~init_bounds proc~minimize_spec minimize_spec proc~upgrade->proc~minimize_spec proc~myfunc_spec myfunc_spec proc~minimize_spec->proc~myfunc_spec proc~setulb setulb proc~minimize_spec->proc~setulb proc~myresidual myresidual proc~minimize_spec->proc~myresidual proc~mygrad_spec mygrad_spec proc~minimize_spec->proc~mygrad_spec proc~gaussian gaussian proc~myresidual->proc~gaussian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code upgrade Source Code subroutine upgrade ( cube , params , power , n_gauss , dim_v , maxiter , m , iprint ) !! Upgrade parameters (spectra to spectra) using minimize function (here based on L-BFGS-B optimization module) implicit none real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! cube integer , intent ( in ) :: power !! nside of the cube integer , intent ( in ) :: n_gauss !! number of Gaussian integer , intent ( in ) :: dim_v !! dimension along v axis integer , intent ( in ) :: maxiter !! max number of iteration integer , intent ( in ) :: m !! number of corrections used in the limited memory matrix by LBFGS-B integer , intent ( in ) :: iprint !! print option real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: params !! cube parameters to update integer :: i , j real ( xp ), dimension (:), allocatable :: line real ( xp ), dimension (:), allocatable :: x real ( xp ), dimension (:), allocatable :: lb , ub do i = 1 , power do j = 1 , power ! print*, (i-1)*power+j, \" / \", power*power allocate ( line ( dim_v )) allocate ( x ( 3 * n_gauss ), lb ( 3 * n_gauss ), ub ( 3 * n_gauss )) line = cube (:, i , j ) x = params (:, i , j ) call init_bounds ( line , n_gauss , dim_v , lb , ub ) call minimize_spec ( 3 * n_gauss , m , x , lb , ub , line , dim_v , n_gauss , maxiter , iprint ) params (:, i , j ) = x deallocate ( line ) deallocate ( x , lb , ub ) end do end do end subroutine upgrade","tags":"","loc":"proc/upgrade.html","title":"upgrade – ROHSA"},{"text":"public subroutine update(cube, params, n_gauss, dim_v, dim_y, dim_x, lambda_amp, lambda_mu, lambda_sig, maxiter, m, kernel, iprint, std_map) Update parameters (entire cube) using minimize function (here based on L-BFGS-B optimization module) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: params parameters cube to update integer, intent(in) :: n_gauss Number of Gaussian integer, intent(in) :: dim_v dimension along v axis integer, intent(in) :: dim_y dimension along spatial axis y integer, intent(in) :: dim_x dimension along spatial axis x real(kind=xp), intent(in) :: lambda_amp lambda for amplitude parameter real(kind=xp), intent(in) :: lambda_mu lambda for mean position parameter real(kind=xp), intent(in) :: lambda_sig lambda for dispersion parameter integer, intent(in) :: maxiter max number of iteration integer, intent(in) :: m number of corrections used in the limited memory matrix by LBFGS-B real(kind=xp), intent(in), dimension(:,:), allocatable :: kernel convolution kernel integer, intent(in) :: iprint print option real(kind=xp), intent(in), dimension(:,:), allocatable :: std_map Standard deviation map Calls proc~~update~~CallsGraph proc~update update proc~ravel_3d ravel_3D proc~update->proc~ravel_3d proc~minimize minimize proc~update->proc~minimize proc~unravel_3d unravel_3D proc~update->proc~unravel_3d proc~setulb setulb proc~minimize->proc~setulb proc~f_g_cube f_g_cube proc~minimize->proc~f_g_cube proc~f_g_cube->proc~ravel_3d proc~f_g_cube->proc~unravel_3d proc~myfunc_spec myfunc_spec proc~f_g_cube->proc~myfunc_spec proc~convolution_2d_mirror convolution_2D_mirror proc~f_g_cube->proc~convolution_2d_mirror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code update Source Code subroutine update ( cube , params , n_gauss , dim_v , dim_y , dim_x , lambda_amp , lambda_mu , lambda_sig , maxiter , m , kernel , & iprint , std_map ) !! Update parameters (entire cube) using minimize function (here based on L-BFGS-B optimization module) implicit none real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! cube real ( xp ), intent ( in ), dimension (:,:), allocatable :: std_map !! Standard deviation map real ( xp ), intent ( in ), dimension (:,:), allocatable :: kernel !! convolution kernel integer , intent ( in ) :: dim_v !! dimension along v axis integer , intent ( in ) :: dim_y !! dimension along spatial axis y integer , intent ( in ) :: dim_x !! dimension along spatial axis x integer , intent ( in ) :: n_gauss !! Number of Gaussian integer , intent ( in ) :: maxiter !! max number of iteration integer , intent ( in ) :: m !! number of corrections used in the limited memory matrix by LBFGS-B integer , intent ( in ) :: iprint !! print option real ( xp ), intent ( in ) :: lambda_amp !! lambda for amplitude parameter real ( xp ), intent ( in ) :: lambda_mu !! lambda for mean position parameter real ( xp ), intent ( in ) :: lambda_sig !! lambda for dispersion parameter real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: params !! parameters cube to update integer :: i , j integer :: n_beta real ( xp ), dimension (:,:,:), allocatable :: lb_3D , ub_3D real ( xp ), dimension (:), allocatable :: lb , ub real ( xp ), dimension (:), allocatable :: beta n_beta = 3 * n_gauss * dim_y * dim_x allocate ( lb ( n_beta ), ub ( n_beta ), beta ( n_beta )) allocate ( lb_3D ( 3 * n_gauss , dim_y , dim_x ), ub_3D ( 3 * n_gauss , dim_y , dim_x )) do j = 1 , dim_x do i = 1 , dim_y call init_bounds ( cube (:, i , j ), n_gauss , dim_v , lb_3D (:, i , j ), ub_3D (:, i , j )) end do end do call ravel_3D ( lb_3D , lb , 3 * n_gauss , dim_y , dim_x ) call ravel_3D ( ub_3D , ub , 3 * n_gauss , dim_y , dim_x ) call ravel_3D ( params , beta , 3 * n_gauss , dim_y , dim_x ) call minimize ( n_beta , m , beta , lb , ub , cube , n_gauss , dim_v , dim_y , dim_x , lambda_amp , lambda_mu , lambda_sig , maxiter , & kernel , iprint , std_map ) call unravel_3D ( beta , params , 3 * n_gauss , dim_y , dim_x ) end subroutine update","tags":"","loc":"proc/update.html","title":"update – ROHSA"},{"text":"public subroutine set_stdmap(std_map, cube, lb, ub) Compute the STD map of a 3D array Arguments Type Intent Optional Attributes Name real(kind=xp), intent(inout), dimension(:,:), allocatable :: std_map standard deviation map of the cube real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube cube integer, intent(in) :: lb lower bound integer, intent(in) :: ub upper bound Calls proc~~set_stdmap~~CallsGraph proc~set_stdmap set_stdmap proc~std std proc~set_stdmap->proc~std Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_stdmap~~CalledByGraph proc~set_stdmap set_stdmap program~rohsa ROHSA program~rohsa->proc~set_stdmap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_stdmap Source Code subroutine set_stdmap ( std_map , cube , lb , ub ) !! Compute the STD map of a 3D array implicit none integer , intent ( in ) :: lb !! lower bound integer , intent ( in ) :: ub !! upper bound real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube !! cube real ( xp ), intent ( inout ), dimension (:,:), allocatable :: std_map !! standard deviation map of the cube real ( xp ), dimension (:), allocatable :: line integer , dimension ( 3 ) :: dim_cube integer :: i , j dim_cube = shape ( cube ) do j = 1 , dim_cube ( 3 ) do i = 1 , dim_cube ( 2 ) line = cube ( lb : ub , i , j ) std_map ( i , j ) = std ( line ) end do end do end subroutine set_stdmap","tags":"","loc":"proc/set_stdmap.html","title":"set_stdmap – ROHSA"},{"text":"public pure function gaussian(x, a, m, s) Gaussian function Arguments Type Intent Optional Attributes Name integer, intent(in) :: x real(kind=xp), intent(in) :: a real(kind=xp), intent(in) :: m real(kind=xp), intent(in) :: s Return Value real(kind=xp) Called by proc~~gaussian~~CalledByGraph proc~gaussian gaussian proc~init_spectrum init_spectrum proc~init_spectrum->proc~gaussian proc~minimize_spec minimize_spec proc~init_spectrum->proc~minimize_spec proc~myresidual myresidual proc~myresidual->proc~gaussian proc~minimize_spec->proc~myresidual proc~upgrade upgrade proc~upgrade->proc~minimize_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gaussian Source Code pure function gaussian ( x , a , m , s ) !! Gaussian function implicit none integer , intent ( in ) :: x real ( xp ), intent ( in ) :: a , m , s real ( xp ) :: gaussian gaussian = a * exp ( - ( ( real ( x , xp ) - m ) ** 2 ) / ( 2._xp * s ** 2 ) ); end function gaussian","tags":"","loc":"proc/gaussian.html","title":"gaussian – ROHSA"},{"text":"private pure function myfunc_spec(residual) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:), allocatable :: residual Return Value real(kind=xp) Called by proc~~myfunc_spec~~CalledByGraph proc~myfunc_spec myfunc_spec proc~minimize_spec minimize_spec proc~minimize_spec->proc~myfunc_spec proc~f_g_cube f_g_cube proc~f_g_cube->proc~myfunc_spec proc~upgrade upgrade proc~upgrade->proc~minimize_spec proc~minimize minimize proc~minimize->proc~f_g_cube proc~init_spectrum init_spectrum proc~init_spectrum->proc~minimize_spec proc~update update proc~update->proc~minimize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code myfunc_spec Source Code pure function myfunc_spec ( residual ) implicit none real ( xp ), intent ( in ), dimension (:), allocatable :: residual real ( xp ) :: myfunc_spec myfunc_spec = 0._xp myfunc_spec = 0.5_xp * sum ( residual ** 2._xp ) end function myfunc_spec","tags":"","loc":"proc/myfunc_spec.html","title":"myfunc_spec – ROHSA"},{"text":"public subroutine minimize_spec(n, m, x, lb, ub, line, dim_v, n_gauss, maxiter, iprint) Minimize algorithn for a specturm Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m real(kind=xp), intent(in), dimension(:), allocatable :: x real(kind=xp), intent(in), dimension(:), allocatable :: lb real(kind=xp), intent(in), dimension(:), allocatable :: ub real(kind=xp), intent(in), dimension(dim_v) :: line integer, intent(in) :: dim_v integer, intent(in) :: n_gauss integer, intent(in) :: maxiter integer, intent(in) :: iprint Calls proc~~minimize_spec~~CallsGraph proc~minimize_spec minimize_spec proc~myfunc_spec myfunc_spec proc~minimize_spec->proc~myfunc_spec proc~setulb setulb proc~minimize_spec->proc~setulb proc~myresidual myresidual proc~minimize_spec->proc~myresidual proc~mygrad_spec mygrad_spec proc~minimize_spec->proc~mygrad_spec proc~gaussian gaussian proc~myresidual->proc~gaussian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~minimize_spec~~CalledByGraph proc~minimize_spec minimize_spec proc~upgrade upgrade proc~upgrade->proc~minimize_spec proc~init_spectrum init_spectrum proc~init_spectrum->proc~minimize_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code minimize_spec Source Code subroutine minimize_spec ( n , m , x , lb , ub , line , dim_v , n_gauss , maxiter , iprint ) !! Minimize algorithn for a specturm implicit none integer , intent ( in ) :: n integer , intent ( in ) :: m integer , intent ( in ) :: dim_v integer , intent ( in ) :: n_gauss , maxiter integer , intent ( in ) :: iprint real ( xp ), intent ( in ), dimension (:), allocatable :: lb , ub real ( xp ), intent ( in ), dimension ( dim_v ) :: line real ( xp ), intent ( in ), dimension (:), allocatable :: x real ( xp ), parameter :: factr = 1.0d+7 , pgtol = 1.0d-5 character ( len = 60 ) :: task , csave logical :: lsave ( 4 ) integer :: isave ( 44 ) real ( xp ) :: f real ( xp ) :: dsave ( 29 ) integer , dimension (:), allocatable :: nbd , iwa real ( xp ), dimension (:), allocatable :: g , wa real ( xp ), dimension (:), allocatable :: residual !     Allocate dynamic arrays allocate ( nbd ( n ), g ( n )) allocate ( iwa ( 3 * n )) allocate ( wa ( 2 * m * n + 5 * n + 11 * m * m + 8 * m )) allocate ( residual ( dim_v )) residual = 0._xp ! Init nbd nbd = 2 !     We now define the starting point. !     We start the iteration by initializing task. task = 'START' !     The beginning of the loop do while ( task ( 1 : 2 ). eq . 'FG' . or . task . eq . 'NEW_X' . or . task . eq . 'START' ) !     This is the call to the L-BFGS-B code. call setulb ( n , m , x , lb , ub , nbd , f , g , factr , pgtol , wa , iwa , task , iprint , csave , lsave , isave , dsave ) if ( task ( 1 : 2 ) . eq . 'FG' ) then !     Compute function f and gradient g for the sample problem. call myresidual ( x , line , residual , n_gauss , dim_v ) f = myfunc_spec ( residual ) call mygrad_spec ( n_gauss , g , residual , x , dim_v ) elseif ( task ( 1 : 5 ) . eq . 'NEW_X' ) then !        1) Terminate if the total number of f and g evaluations !             exceeds maxiter. if ( isave ( 34 ) . ge . maxiter ) & task = 'STOP: TOTAL NO. of f AND g EVALUATIONS EXCEEDS LIMIT' !        2) Terminate if  |proj g|/(1+|f|) < 1.0d-10. if ( dsave ( 13 ) . le . 1.d-10 * ( 1.0d0 + abs ( f ))) & task = 'STOP: THE PROJECTED GRADIENT IS SUFFICIENTLY SMALL' endif !     end of loop do while end do end subroutine minimize_spec","tags":"","loc":"proc/minimize_spec.html","title":"minimize_spec – ROHSA"},{"text":"private subroutine myresidual(params, line, residual, n_gauss, dim_v) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(3*n_gauss) :: params real(kind=xp), intent(in), dimension(dim_v) :: line real(kind=xp), intent(inout), dimension(:), allocatable :: residual integer, intent(in) :: n_gauss integer, intent(in) :: dim_v Calls proc~~myresidual~~CallsGraph proc~myresidual myresidual proc~gaussian gaussian proc~myresidual->proc~gaussian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~myresidual~~CalledByGraph proc~myresidual myresidual proc~minimize_spec minimize_spec proc~minimize_spec->proc~myresidual proc~upgrade upgrade proc~upgrade->proc~minimize_spec proc~init_spectrum init_spectrum proc~init_spectrum->proc~minimize_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code myresidual Source Code subroutine myresidual ( params , line , residual , n_gauss , dim_v ) implicit none integer , intent ( in ) :: dim_v , n_gauss real ( xp ), intent ( in ), dimension ( dim_v ) :: line real ( xp ), intent ( in ), dimension ( 3 * n_gauss ) :: params real ( xp ), intent ( inout ), dimension (:), allocatable :: residual integer :: i , k real ( xp ) :: g real ( xp ), dimension ( dim_v ) :: model g = 0._xp model = 0._xp do i = 1 , n_gauss do k = 1 , dim_v g = gaussian ( k , params ( 1 + ( 3 * ( i - 1 ))), params ( 2 + ( 3 * ( i - 1 ))), params ( 3 + ( 3 * ( i - 1 )))) model ( k ) = model ( k ) + g enddo enddo residual = model - line end subroutine myresidual","tags":"","loc":"proc/myresidual.html","title":"myresidual – ROHSA"},{"text":"private subroutine mygrad_spec(n_gauss, gradient, residual, params, dim_v) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_gauss real(kind=xp), intent(inout), dimension(3*n_gauss) :: gradient real(kind=xp), intent(in), dimension(:), allocatable :: residual real(kind=xp), intent(in), dimension(3*n_gauss) :: params integer, intent(in) :: dim_v Called by proc~~mygrad_spec~~CalledByGraph proc~mygrad_spec mygrad_spec proc~minimize_spec minimize_spec proc~minimize_spec->proc~mygrad_spec proc~upgrade upgrade proc~upgrade->proc~minimize_spec proc~init_spectrum init_spectrum proc~init_spectrum->proc~minimize_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mygrad_spec Source Code subroutine mygrad_spec ( n_gauss , gradient , residual , params , dim_v ) implicit none integer , intent ( in ) :: n_gauss , dim_v real ( xp ), intent ( in ), dimension ( 3 * n_gauss ) :: params real ( xp ), intent ( in ), dimension (:), allocatable :: residual real ( xp ), intent ( inout ), dimension ( 3 * n_gauss ) :: gradient integer :: i , k real ( xp ) :: g real ( xp ), dimension (:,:), allocatable :: dF_over_dB allocate ( dF_over_dB ( 3 * n_gauss , dim_v )) g = 0._xp dF_over_dB = 0._xp gradient = 0._xp do i = 1 , n_gauss do k = 1 , dim_v dF_over_dB ( 1 + ( 3 * ( i - 1 )), k ) = dF_over_dB ( 1 + ( 3 * ( i - 1 )), k ) + & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )))) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 ))) ** 2._xp )) dF_over_dB ( 2 + ( 3 * ( i - 1 )), k ) = dF_over_dB ( 2 + ( 3 * ( i - 1 )), k ) + & params ( 1 + ( 3 * ( i - 1 ))) * ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 ))) ) / ( params ( 3 + ( 3 * ( i - 1 ))) ** 2._xp ) * & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )))) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 ))) ** 2._xp )) dF_over_dB ( 3 + ( 3 * ( i - 1 )), k ) = dF_over_dB ( 3 + ( 3 * ( i - 1 )), k ) + & params ( 1 + ( 3 * ( i - 1 ))) * ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 ))) ) ** 2._xp / ( params ( 3 + ( 3 * ( i - 1 ))) ** 3._xp ) * & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )))) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 ))) ** 2._xp )) enddo enddo do i = 1 , dim_v do k = 1 , 3 * n_gauss gradient ( k ) = gradient ( k ) + dF_over_dB ( k , i ) * residual ( i ) end do end do end subroutine mygrad_spec","tags":"","loc":"proc/mygrad_spec.html","title":"mygrad_spec – ROHSA"},{"text":"public subroutine minimize(n, m, x, lb, ub, cube, n_gauss, dim_v, dim_y, dim_x, lambda_amp, lambda_mu, lambda_sig, maxiter, kernel, iprint, std_map) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m real(kind=xp), intent(in), dimension(:), allocatable :: x real(kind=xp), intent(in), dimension(:), allocatable :: lb real(kind=xp), intent(in), dimension(:), allocatable :: ub real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube integer, intent(in) :: n_gauss integer, intent(in) :: dim_v integer, intent(in) :: dim_y integer, intent(in) :: dim_x real(kind=xp), intent(in) :: lambda_amp real(kind=xp), intent(in) :: lambda_mu real(kind=xp), intent(in) :: lambda_sig integer, intent(in) :: maxiter real(kind=xp), intent(in), dimension(:,:), allocatable :: kernel integer, intent(in) :: iprint real(kind=xp), intent(in), dimension(:,:), allocatable :: std_map Calls proc~~minimize~~CallsGraph proc~minimize minimize proc~setulb setulb proc~minimize->proc~setulb proc~f_g_cube f_g_cube proc~minimize->proc~f_g_cube proc~myfunc_spec myfunc_spec proc~f_g_cube->proc~myfunc_spec proc~ravel_3d ravel_3D proc~f_g_cube->proc~ravel_3d proc~convolution_2d_mirror convolution_2D_mirror proc~f_g_cube->proc~convolution_2d_mirror proc~unravel_3d unravel_3D proc~f_g_cube->proc~unravel_3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~minimize~~CalledByGraph proc~minimize minimize proc~update update proc~update->proc~minimize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code minimize Source Code subroutine minimize ( n , m , x , lb , ub , cube , n_gauss , dim_v , dim_y , dim_x , lambda_amp , lambda_mu , lambda_sig , maxiter , & kernel , iprint , std_map ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: m integer , intent ( in ) :: dim_v , dim_y , dim_x integer , intent ( in ) :: n_gauss , maxiter integer , intent ( in ) :: iprint real ( xp ), intent ( in ) :: lambda_amp , lambda_mu , lambda_sig real ( xp ), intent ( in ), dimension (:), allocatable :: lb , ub real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube real ( xp ), intent ( in ), dimension (:,:), allocatable :: kernel real ( xp ), intent ( in ), dimension (:,:), allocatable :: std_map real ( xp ), intent ( in ), dimension (:), allocatable :: x real ( xp ), parameter :: factr = 1.0d+7 , pgtol = 1.0d-5 character ( len = 60 ) :: task , csave logical :: lsave ( 4 ) integer :: isave ( 44 ) real ( xp ) :: f real ( xp ) :: dsave ( 29 ) integer , dimension (:), allocatable :: nbd , iwa real ( xp ), dimension (:), allocatable :: g , wa real ( xp ), dimension (:,:,:), allocatable :: residual !     Allocate dynamic arrays allocate ( nbd ( n ), g ( n )) allocate ( iwa ( 3 * n )) allocate ( wa ( 2 * m * n + 5 * n + 11 * m * m + 8 * m )) allocate ( residual ( dim_v , dim_y , dim_x )) residual = 0._xp f = 0._xp g = 0._xp ! Init nbd nbd = 2 !     We now define the starting point. !     We start the iteration by initializing task. task = 'START' !     The beginning of the loop do while ( task ( 1 : 2 ). eq . 'FG' . or . task . eq . 'NEW_X' . or . task . eq . 'START' ) !     This is the call to the L-BFGS-B code. call setulb ( n , m , x , lb , ub , nbd , f , g , factr , pgtol , wa , iwa , task , iprint , csave , lsave , isave , dsave ) if ( task ( 1 : 2 ) . eq . 'FG' ) then !     Compute function f and gradient g for the sample problem. call f_g_cube ( f , g , cube , x , dim_v , dim_y , dim_x , n_gauss , kernel , lambda_amp , lambda_mu , lambda_sig , std_map ) elseif ( task ( 1 : 5 ) . eq . 'NEW_X' ) then !        1) Terminate if the total number of f and g evaluations !             exceeds maxiter. if ( isave ( 34 ) . ge . maxiter ) & task = 'STOP: TOTAL NO. of f AND g EVALUATIONS EXCEEDS LIMIT' !        2) Terminate if  |proj g|/(1+|f|) < 1.0d-10. if ( dsave ( 13 ) . le . 1.d-10 * ( 1.0d0 + abs ( f ))) & task = 'STOP: THE PROJECTED GRADIENT IS SUFFICIENTLY SMALL' endif !     end of loop do while end do end subroutine minimize","tags":"","loc":"proc/minimize.html","title":"minimize – ROHSA"},{"text":"private subroutine f_g_cube(f, g, cube, beta, dim_v, dim_y, dim_x, n_gauss, kernel, lambda_amp, lambda_mu, lambda_sig, std_map) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(inout) :: f real(kind=xp), intent(inout), dimension(:), allocatable :: g real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube real(kind=xp), intent(in), dimension(:), allocatable :: beta integer, intent(in) :: dim_v integer, intent(in) :: dim_y integer, intent(in) :: dim_x integer, intent(in) :: n_gauss real(kind=xp), intent(in), dimension(:,:), allocatable :: kernel real(kind=xp), intent(in) :: lambda_amp real(kind=xp), intent(in) :: lambda_mu real(kind=xp), intent(in) :: lambda_sig real(kind=xp), intent(in), dimension(:,:), allocatable :: std_map Calls proc~~f_g_cube~~CallsGraph proc~f_g_cube f_g_cube proc~myfunc_spec myfunc_spec proc~f_g_cube->proc~myfunc_spec proc~ravel_3d ravel_3D proc~f_g_cube->proc~ravel_3d proc~convolution_2d_mirror convolution_2D_mirror proc~f_g_cube->proc~convolution_2d_mirror proc~unravel_3d unravel_3D proc~f_g_cube->proc~unravel_3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~f_g_cube~~CalledByGraph proc~f_g_cube f_g_cube proc~minimize minimize proc~minimize->proc~f_g_cube proc~update update proc~update->proc~minimize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code f_g_cube Source Code subroutine f_g_cube ( f , g , cube , beta , dim_v , dim_y , dim_x , n_gauss , kernel , lambda_amp , lambda_mu , lambda_sig , & std_map ) implicit none integer , intent ( in ) :: n_gauss integer , intent ( in ) :: dim_v , dim_y , dim_x real ( xp ), intent ( in ) :: lambda_amp , lambda_mu , lambda_sig real ( xp ), intent ( in ), dimension (:), allocatable :: beta real ( xp ), intent ( in ), dimension (:,:,:), allocatable :: cube real ( xp ), intent ( in ), dimension (:,:), allocatable :: kernel real ( xp ), intent ( in ), dimension (:,:), allocatable :: std_map real ( xp ), intent ( inout ) :: f real ( xp ), intent ( inout ), dimension (:), allocatable :: g integer :: i , j , k , l real ( xp ), dimension (:,:,:), allocatable :: residual real ( xp ), dimension (:), allocatable :: residual_1D real ( xp ), dimension (:,:,:), allocatable :: params real ( xp ), dimension (:,:), allocatable :: conv_amp , conv_mu , conv_sig real ( xp ), dimension (:,:), allocatable :: conv_conv_amp , conv_conv_mu , conv_conv_sig real ( xp ), dimension (:,:), allocatable :: image_amp , image_mu , image_sig real ( xp ), dimension (:,:,:), allocatable :: g_3D real ( xp ), dimension (:,:,:,:), allocatable :: dF_over_dB real ( xp ), dimension (:,:,:), allocatable :: dR_over_dB real ( xp ), dimension (:,:,:), allocatable :: deriv allocate ( dR_over_dB ( 3 * n_gauss , dim_y , dim_x )) allocate ( dF_over_dB ( 3 * n_gauss , dim_v , dim_y , dim_x )) allocate ( deriv ( 3 * n_gauss , dim_y , dim_x )) allocate ( g_3D ( 3 * n_gauss , dim_y , dim_x )) allocate ( residual ( dim_v , dim_y , dim_x )) allocate ( params ( 3 * n_gauss , dim_y , dim_x )) allocate ( conv_amp ( dim_y , dim_x ), conv_mu ( dim_y , dim_x ), conv_sig ( dim_y , dim_x )) allocate ( conv_conv_amp ( dim_y , dim_x ), conv_conv_mu ( dim_y , dim_x ), conv_conv_sig ( dim_y , dim_x )) allocate ( image_amp ( dim_y , dim_x ), image_mu ( dim_y , dim_x ), image_sig ( dim_y , dim_x )) dR_over_dB = 0._xp dF_over_dB = 0._xp deriv = 0._xp f = 0._xp g = 0._xp g_3D = 0._xp residual = 0._xp params = 0._xp call unravel_3D ( beta , params , 3 * n_gauss , dim_y , dim_x ) ! Compute the objective function and the gradient do j = 1 , dim_x do i = 1 , dim_y allocate ( residual_1D ( dim_v )) residual_1D = 0._xp call myresidual ( params (:, i , j ), cube (:, i , j ), residual_1D , n_gauss , dim_v ) residual (:, i , j ) = residual_1D if ( std_map ( i , j ) > 0._xp ) then f = f + ( myfunc_spec ( residual_1D ) / std_map ( i , j ) ** 2._xp ) end if deallocate ( residual_1D ) end do end do do l = 1 , dim_x do j = 1 , dim_y do i = 1 , n_gauss do k = 1 , dim_v dF_over_dB ( 1 + ( 3 * ( i - 1 )), k , j , l ) = dF_over_dB ( 1 + ( 3 * ( i - 1 )), k , j , l ) + & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l )) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 2._xp )) dF_over_dB ( 2 + ( 3 * ( i - 1 )), k , j , l ) = dF_over_dB ( 2 + ( 3 * ( i - 1 )), k , j , l ) + & params ( 1 + ( 3 * ( i - 1 )), j , l ) * ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l ) ) / ( params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 2._xp ) * & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l )) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 2._xp )) dF_over_dB ( 3 + ( 3 * ( i - 1 )), k , j , l ) = dF_over_dB ( 3 + ( 3 * ( i - 1 )), k , j , l ) + & params ( 1 + ( 3 * ( i - 1 )), j , l ) * ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l ) ) ** 2._xp / ( params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 3._xp ) * & exp ( ( - ( real ( k , xp ) - params ( 2 + ( 3 * ( i - 1 )), j , l )) ** 2._xp ) / ( 2._xp * params ( 3 + ( 3 * ( i - 1 )), j , l ) ** 2._xp )) enddo enddo end do end do do k = 1 , dim_v do j = 1 , dim_x do i = 1 , dim_y do l = 1 , 3 * n_gauss if ( std_map ( i , j ) > 0._xp ) then deriv ( l , i , j ) = deriv ( l , i , j ) + dF_over_dB ( l , k , i , j ) * ( residual ( k , i , j ) / std_map ( i , j ) ** 2._xp ) end if end do end do end do end do do k = 1 , n_gauss conv_amp = 0._xp ; conv_mu = 0._xp ; conv_sig = 0._xp conv_conv_amp = 0._xp ; conv_conv_mu = 0._xp ; conv_conv_sig = 0._xp image_amp = 0._xp ; image_mu = 0._xp ; image_sig = 0._xp image_amp = params ( 1 + ( 3 * ( k - 1 )),:,:) image_mu = params ( 2 + ( 3 * ( k - 1 )),:,:) image_sig = params ( 3 + ( 3 * ( k - 1 )),:,:) call convolution_2D_mirror ( image_amp , conv_amp , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( image_mu , conv_mu , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( image_sig , conv_sig , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( conv_amp , conv_conv_amp , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( conv_mu , conv_conv_mu , dim_y , dim_x , kernel , 3 ) call convolution_2D_mirror ( conv_sig , conv_conv_sig , dim_y , dim_x , kernel , 3 ) do j = 1 , dim_x do i = 1 , dim_y f = f + 0.5_xp * lambda_amp * conv_amp ( i , j ) ** 2 f = f + 0.5_xp * lambda_mu * conv_mu ( i , j ) ** 2 f = f + 0.5_xp * lambda_sig * conv_sig ( i , j ) ** 2 dR_over_dB ( 1 + ( 3 * ( k - 1 )), i , j ) = lambda_amp * conv_conv_amp ( i , j ) dR_over_dB ( 2 + ( 3 * ( k - 1 )), i , j ) = lambda_mu * conv_conv_mu ( i , j ) dR_over_dB ( 3 + ( 3 * ( k - 1 )), i , j ) = lambda_sig * conv_conv_sig ( i , j ) end do end do end do g_3D = deriv + dR_over_dB call ravel_3D ( g_3D , g , 3 * n_gauss , dim_y , dim_x ) end subroutine f_g_cube","tags":"","loc":"proc/f_g_cube.html","title":"f_g_cube – ROHSA"},{"text":"public subroutine read_parameters(filename_parameters, filename, fileout, filename_noise, n_gauss, lambda_amp, lambda_mu, lambda_sig, maxiter_init, maxiter, m, noise, regul, lstd, ustd, iprint, iprint_init) Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: filename_parameters character(len=512), intent(inout) :: filename character(len=512), intent(inout) :: fileout character(len=512), intent(inout) :: filename_noise integer, intent(inout) :: n_gauss real(kind=xp), intent(inout) :: lambda_amp real(kind=xp), intent(inout) :: lambda_mu real(kind=xp), intent(inout) :: lambda_sig integer, intent(inout) :: maxiter_init integer, intent(inout) :: maxiter integer, intent(inout) :: m logical, intent(inout) :: noise logical, intent(inout) :: regul integer, intent(inout) :: lstd integer, intent(inout) :: ustd integer, intent(inout) :: iprint integer, intent(inout) :: iprint_init Called by proc~~read_parameters~~CalledByGraph proc~read_parameters read_parameters program~rohsa ROHSA program~rohsa->proc~read_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_parameters Source Code subroutine read_parameters ( filename_parameters , filename , fileout , filename_noise , n_gauss , lambda_amp , lambda_mu , & lambda_sig , maxiter_init , maxiter , m , noise , regul , lstd , ustd , iprint , iprint_init ) implicit none integer :: ios = 0 character ( len = 512 ), intent ( in ) :: filename_parameters integer , intent ( inout ) :: n_gauss integer , intent ( inout ) :: m integer , intent ( inout ) :: lstd , ustd integer , intent ( inout ) :: iprint , iprint_init integer , intent ( inout ) :: maxiter , maxiter_init real ( xp ), intent ( inout ) :: lambda_amp , lambda_mu , lambda_sig logical , intent ( inout ) :: noise , regul character ( len = 512 ), intent ( inout ) :: filename character ( len = 512 ), intent ( inout ) :: fileout character ( len = 512 ), intent ( inout ) :: filename_noise namelist / user_parameters / filename , fileout , filename_noise , n_gauss , lambda_amp , lambda_mu , & & lambda_sig , maxiter_init , maxiter , m , noise , regul , lstd , ustd , iprint , iprint_init open ( unit = 11 , file = filename_parameters , status = \"old\" , iostat = ios ) if ( ios /= 0 ) stop \"opening file error\" read ( 11 , user_parameters ) close ( 11 ) end subroutine read_parameters","tags":"","loc":"proc/read_parameters.html","title":"read_parameters – ROHSA"},{"text":"public subroutine read_cube(filename, cube) Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: filename real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube Called by proc~~read_cube~~CalledByGraph proc~read_cube read_cube program~rohsa ROHSA program~rohsa->proc~read_cube Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_cube Source Code subroutine read_cube ( filename , cube ) implicit none integer :: ios = 0 , i integer :: v , y , x real ( xp ) :: val integer :: nv , ny , nx !cube dimension integer :: nl character ( len = 512 ), intent ( in ) :: filename real ( xp ), intent ( inout ), dimension (:,:,:), allocatable :: cube open ( unit = 11 , file = filename , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios /= 0 ) stop \"opening file error\" read ( 11 , fmt =* ) nv , ny , nx nl = nv * ny * nx allocate ( cube ( nv , ny , nx )) do i = 1 , nl read ( 11 , fmt =* ) v , y , x , val cube ( v + 1 , y + 1 , x + 1 ) = val enddo close ( 11 ) end subroutine read_cube","tags":"","loc":"proc/read_cube.html","title":"read_cube – ROHSA"},{"text":"public subroutine read_map(filename, map) Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: filename real(kind=xp), intent(inout), dimension(:,:), allocatable :: map Called by proc~~read_map~~CalledByGraph proc~read_map read_map program~rohsa ROHSA program~rohsa->proc~read_map Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_map Source Code subroutine read_map ( filename , map ) implicit none integer :: ios = 0 , i integer :: y , x real ( xp ) :: val integer :: ny , nx integer :: nl character ( len = 512 ), intent ( in ) :: filename real ( xp ), intent ( inout ), dimension (:,:), allocatable :: map open ( unit = 11 , file = filename , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios /= 0 ) stop \"opening file error\" read ( 11 , fmt =* ) ny , nx nl = ny * nx allocate ( map ( ny , nx )) do i = 1 , nl read ( 11 , fmt =* ) y , x , val map ( y + 1 , x + 1 ) = val enddo close ( 11 ) end subroutine read_map","tags":"","loc":"proc/read_map.html","title":"read_map – ROHSA"},{"text":"public subroutine header() Arguments None Calls proc~~header~~CallsGraph proc~header header proc~timestamp timestamp proc~header->proc~timestamp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~header~~CalledByGraph proc~header header program~rohsa ROHSA program~rohsa->proc~header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code header Source Code subroutine header () implicit none write ( * , * ) \"-------------------------------------------------------------------------\" call timestamp () write ( * , * ) \"\" write ( * , * ) \"  ____     ___    _   _   ____       _    \" write ( * , * ) \" |  _ \\   / _ \\  | | | | / ___|     / \\   \" write ( * , * ) \" | |_) | | | | | | |_| | \\___ \\    / _ \\  \" write ( * , * ) \" |  _ <  | |_| | |  _  |  ___) |  / ___ \\ \" write ( * , * ) \" |_| \\_\\  \\___/  |_| |_| |____/  /_/   \\_\\ \" write ( * , * ) \"\" write ( * , * ) \" Version 1.0.0\" write ( * , * ) \" ROHSA is released as open source code\" write ( * , * ) \" Check out the documentation: https://antoinemarchal.github.io/ROHSA/\" write ( * , * ) \"\" write ( * , * ) \"run: ./ROHSA parameters.txt\" write ( * , * ) \"-------------------------------------------------------------------------\" end subroutine header","tags":"","loc":"proc/header.html","title":"header – ROHSA"},{"text":"public subroutine ender() Arguments None Calls proc~~ender~~CallsGraph proc~ender ender proc~timestamp timestamp proc~ender->proc~timestamp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ender~~CalledByGraph proc~ender ender program~rohsa ROHSA program~rohsa->proc~ender Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ender Source Code subroutine ender () implicit none write ( * , * ) \"##################################################################\" call timestamp () write ( * , * ) \" Terminate\" write ( * , * ) \"                        ROHSA ALGORITHM\" write ( * , * ) \"\" write ( * , * ) \"##################################################################\" end subroutine ender","tags":"","loc":"proc/ender.html","title":"ender – ROHSA"},{"text":"private subroutine timestamp() TIMESTAMP prints the current YMDHMS date as a time stamp. Arguments None Called by proc~~timestamp~~CalledByGraph proc~timestamp timestamp proc~header header proc~header->proc~timestamp proc~ender ender proc~ender->proc~timestamp program~rohsa ROHSA program~rohsa->proc~header program~rohsa->proc~ender Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code timestamp Source Code subroutine timestamp ( ) !*****************************************************************************80 ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! !  Example: ! !    31 May 2001   9:45:54.872 AM ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 May 2013 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return end subroutine timestamp","tags":"","loc":"proc/timestamp.html","title":"timestamp – ROHSA"},{"text":"This module contains tools (convolution/ravel) to manipulate 2D/3Darray Uses mod_constants module~~mod_array~~UsesGraph module~mod_array mod_array module~mod_constants mod_constants module~mod_array->module~mod_constants iso_fortran_env iso_fortran_env module~mod_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_array~~UsedByGraph module~mod_array mod_array module~mod_functions mod_functions module~mod_functions->module~mod_array module~mod_optimize mod_optimize module~mod_functions->module~mod_optimize program~rohsa ROHSA program~rohsa->module~mod_array program~rohsa->module~mod_functions program~rohsa->module~mod_optimize module~mod_optimize->module~mod_array Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines convolution_2D_mirror ravel_3D unravel_3D Subroutines public subroutine convolution_2D_mirror (image, conv, dim_y, dim_x, kernel, dim_k) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:), allocatable :: image real(kind=xp), intent(inout), dimension(:,:), allocatable :: conv integer, intent(in) :: dim_y integer, intent(in) :: dim_x real(kind=xp), intent(in), dimension(:,:), allocatable :: kernel integer, intent(in) :: dim_k public subroutine ravel_3D (cube, vector, dim_v, dim_y, dim_x) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube real(kind=xp), intent(inout), dimension(:), allocatable :: vector integer, intent(in) :: dim_v integer, intent(in) :: dim_y integer, intent(in) :: dim_x public subroutine unravel_3D (vector, cube, dim_v, dim_y, dim_x) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:), allocatable :: vector real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube integer, intent(in) :: dim_v integer, intent(in) :: dim_y integer, intent(in) :: dim_x","tags":"","loc":"module/mod_array.html","title":"mod_array – ROHSA"},{"text":"This module define physical and numerical constant used by ROHSA Uses iso_fortran_env module~~mod_constants~~UsesGraph module~mod_constants mod_constants iso_fortran_env iso_fortran_env module~mod_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_constants~~UsedByGraph module~mod_constants mod_constants module~mod_array mod_array module~mod_array->module~mod_constants module~mod_functions mod_functions module~mod_functions->module~mod_constants module~mod_functions->module~mod_array module~mod_optimize mod_optimize module~mod_functions->module~mod_optimize module~mod_read mod_read module~mod_read->module~mod_constants program~rohsa ROHSA program~rohsa->module~mod_constants program~rohsa->module~mod_array program~rohsa->module~mod_functions program~rohsa->module~mod_read program~rohsa->module~mod_optimize module~mod_optimize->module~mod_constants module~mod_optimize->module~mod_array Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables xp G c pi M_sun cst_rad stefan kb R gammag thomson Variables Type Visibility Attributes Name Initial integer, public, parameter :: xp = REAL64 real(kind=xp), public, parameter :: G = 6.67408e-8_xp real(kind=xp), public, parameter :: c = 2.99792458e10_xp real(kind=xp), public, parameter :: pi = 4.0_xp*atan(1.0_xp) real(kind=xp), public, parameter :: M_sun = 1.98855e33_xp real(kind=xp), public, parameter :: cst_rad = 7.5657308531642009e-15_xp real(kind=xp), public, parameter :: stefan = (c*cst_rad)/4.0_xp real(kind=xp), public, parameter :: kb = 1.3806488e-16_xp real(kind=xp), public, parameter :: R = 8.3144598e7_xp real(kind=xp), public, parameter :: gammag = 5._xp/3._xp real(kind=xp), public, parameter :: thomson = 6.6524587158e-25_xp","tags":"","loc":"module/mod_constants.html","title":"mod_constants – ROHSA"},{"text":"This module contains the main routines of ROHSA Uses mod_constants mod_optimize mod_array module~~mod_functions~~UsesGraph module~mod_functions mod_functions module~mod_constants mod_constants module~mod_functions->module~mod_constants module~mod_array mod_array module~mod_functions->module~mod_array module~mod_optimize mod_optimize module~mod_functions->module~mod_optimize iso_fortran_env iso_fortran_env module~mod_constants->iso_fortran_env module~mod_array->module~mod_constants module~mod_optimize->module~mod_constants module~mod_optimize->module~mod_array Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_functions~~UsedByGraph module~mod_functions mod_functions program~rohsa ROHSA program~rohsa->module~mod_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions dim2nside std Subroutines dim_data2dim_cube reshape_up reshape_down mean_array mean_map go_up_level init_spectrum init_bounds upgrade update set_stdmap Functions public pure function dim2nside (dim_cube) Compute nside value from dim_y and dim_x Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: dim_cube cube dimension Return Value integer nside of the cube private pure function std (array) Compute the STD of a 1D array Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:) :: array 1D array Return Value real(kind=xp) standard deviation Subroutines public subroutine dim_data2dim_cube (nside, dim_data, dim_cube) Arguments Type Intent Optional Attributes Name integer :: nside integer, intent(in), dimension(3) :: dim_data integer, intent(inout), dimension(3) :: dim_cube public subroutine reshape_up (data, cube, dim_data, dim_cube) Reshape the data in a grid of 2&#94;{nside} Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: data original cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube reshape cube integer, intent(in), dimension(3) :: dim_data original cube dimension integer, intent(in), dimension(3) :: dim_cube new cube dimension public subroutine reshape_down (cube, data, dim_cube, dim_data) Reshape the cube ( 2&#94;{nside} ) into a grid with original dimension (opposite of reshape_up) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube original cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: data reshape cube integer, intent(in), dimension(3) :: dim_cube new cube dimension integer, intent(in), dimension(3) :: dim_data original cube dimension public subroutine mean_array (nside, cube, cube_mean) Average cube along spatial axis depending on level n Arguments Type Intent Optional Attributes Name integer, intent(in) :: nside nside of the cube real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube_mean average cube public subroutine mean_map (nside, map, map_mean) Average map depending on level nside Arguments Type Intent Optional Attributes Name integer, intent(in) :: nside nside real(kind=xp), intent(in), dimension(:,:), allocatable :: map map real(kind=xp), intent(inout), dimension(:,:), allocatable :: map_mean avarage map public subroutine go_up_level (cube_params) Projection of the solution at next level (nside += 1) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube_params cube of parameters public subroutine init_spectrum (n_gauss, params, dim_v, line, maxiter, m, iprint) Initialization of the mean sprectrum with N Gaussian Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_gauss number of Gaussian real(kind=xp), intent(inout), dimension(3*n_gauss) :: params params to optimize integer, intent(in) :: dim_v dimension along v axis real(kind=xp), intent(in), dimension(dim_v) :: line spectrum integer, intent(in) :: maxiter Max number of iteration integer, intent(in) :: m number of corrections used in the limited memory matrix by LBFGS-B integer, intent(in) :: iprint print option private subroutine init_bounds (line, n_gauss, dim_v, lb, ub) Initialize parameters bounds for optimization Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(dim_v) :: line spectrum integer, intent(in) :: n_gauss number of Gaussian integer, intent(in) :: dim_v dimension along v axis real(kind=xp), intent(inout), dimension(3*n_gauss) :: lb lower bounds real(kind=xp), intent(inout), dimension(3*n_gauss) :: ub upper bounds public subroutine upgrade (cube, params, power, n_gauss, dim_v, maxiter, m, iprint) Upgrade parameters (spectra to spectra) using minimize function (here based on L-BFGS-B optimization module) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: params cube parameters to update integer, intent(in) :: power nside of the cube integer, intent(in) :: n_gauss number of Gaussian integer, intent(in) :: dim_v dimension along v axis integer, intent(in) :: maxiter max number of iteration integer, intent(in) :: m number of corrections used in the limited memory matrix by LBFGS-B integer, intent(in) :: iprint print option public subroutine update (cube, params, n_gauss, dim_v, dim_y, dim_x, lambda_amp, lambda_mu, lambda_sig, maxiter, m, kernel, iprint, std_map) Update parameters (entire cube) using minimize function (here based on L-BFGS-B optimization module) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube cube real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: params parameters cube to update integer, intent(in) :: n_gauss Number of Gaussian integer, intent(in) :: dim_v dimension along v axis integer, intent(in) :: dim_y dimension along spatial axis y integer, intent(in) :: dim_x dimension along spatial axis x real(kind=xp), intent(in) :: lambda_amp lambda for amplitude parameter real(kind=xp), intent(in) :: lambda_mu lambda for mean position parameter real(kind=xp), intent(in) :: lambda_sig lambda for dispersion parameter integer, intent(in) :: maxiter max number of iteration integer, intent(in) :: m number of corrections used in the limited memory matrix by LBFGS-B real(kind=xp), intent(in), dimension(:,:), allocatable :: kernel convolution kernel integer, intent(in) :: iprint print option real(kind=xp), intent(in), dimension(:,:), allocatable :: std_map Standard deviation map public subroutine set_stdmap (std_map, cube, lb, ub) Compute the STD map of a 3D array Arguments Type Intent Optional Attributes Name real(kind=xp), intent(inout), dimension(:,:), allocatable :: std_map standard deviation map of the cube real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube cube integer, intent(in) :: lb lower bound integer, intent(in) :: ub upper bound","tags":"","loc":"module/mod_functions.html","title":"mod_functions – ROHSA"},{"text":"This module contains optimization subroutine and parametric model Uses mod_constants mod_array module~~mod_optimize~~UsesGraph module~mod_optimize mod_optimize module~mod_constants mod_constants module~mod_optimize->module~mod_constants module~mod_array mod_array module~mod_optimize->module~mod_array iso_fortran_env iso_fortran_env module~mod_constants->iso_fortran_env module~mod_array->module~mod_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_optimize~~UsedByGraph module~mod_optimize mod_optimize module~mod_functions mod_functions module~mod_functions->module~mod_optimize program~rohsa ROHSA program~rohsa->module~mod_optimize program~rohsa->module~mod_functions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions gaussian myfunc_spec Subroutines minimize_spec myresidual mygrad_spec minimize f_g_cube Functions public pure function gaussian (x, a, m, s) Gaussian function Arguments Type Intent Optional Attributes Name integer, intent(in) :: x real(kind=xp), intent(in) :: a real(kind=xp), intent(in) :: m real(kind=xp), intent(in) :: s Return Value real(kind=xp) private pure function myfunc_spec (residual) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(:), allocatable :: residual Return Value real(kind=xp) Subroutines public subroutine minimize_spec (n, m, x, lb, ub, line, dim_v, n_gauss, maxiter, iprint) Minimize algorithn for a specturm Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m real(kind=xp), intent(in), dimension(:), allocatable :: x real(kind=xp), intent(in), dimension(:), allocatable :: lb real(kind=xp), intent(in), dimension(:), allocatable :: ub real(kind=xp), intent(in), dimension(dim_v) :: line integer, intent(in) :: dim_v integer, intent(in) :: n_gauss integer, intent(in) :: maxiter integer, intent(in) :: iprint private subroutine myresidual (params, line, residual, n_gauss, dim_v) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(in), dimension(3*n_gauss) :: params real(kind=xp), intent(in), dimension(dim_v) :: line real(kind=xp), intent(inout), dimension(:), allocatable :: residual integer, intent(in) :: n_gauss integer, intent(in) :: dim_v private subroutine mygrad_spec (n_gauss, gradient, residual, params, dim_v) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_gauss real(kind=xp), intent(inout), dimension(3*n_gauss) :: gradient real(kind=xp), intent(in), dimension(:), allocatable :: residual real(kind=xp), intent(in), dimension(3*n_gauss) :: params integer, intent(in) :: dim_v public subroutine minimize (n, m, x, lb, ub, cube, n_gauss, dim_v, dim_y, dim_x, lambda_amp, lambda_mu, lambda_sig, maxiter, kernel, iprint, std_map) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m real(kind=xp), intent(in), dimension(:), allocatable :: x real(kind=xp), intent(in), dimension(:), allocatable :: lb real(kind=xp), intent(in), dimension(:), allocatable :: ub real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube integer, intent(in) :: n_gauss integer, intent(in) :: dim_v integer, intent(in) :: dim_y integer, intent(in) :: dim_x real(kind=xp), intent(in) :: lambda_amp real(kind=xp), intent(in) :: lambda_mu real(kind=xp), intent(in) :: lambda_sig integer, intent(in) :: maxiter real(kind=xp), intent(in), dimension(:,:), allocatable :: kernel integer, intent(in) :: iprint real(kind=xp), intent(in), dimension(:,:), allocatable :: std_map private subroutine f_g_cube (f, g, cube, beta, dim_v, dim_y, dim_x, n_gauss, kernel, lambda_amp, lambda_mu, lambda_sig, std_map) Arguments Type Intent Optional Attributes Name real(kind=xp), intent(inout) :: f real(kind=xp), intent(inout), dimension(:), allocatable :: g real(kind=xp), intent(in), dimension(:,:,:), allocatable :: cube real(kind=xp), intent(in), dimension(:), allocatable :: beta integer, intent(in) :: dim_v integer, intent(in) :: dim_y integer, intent(in) :: dim_x integer, intent(in) :: n_gauss real(kind=xp), intent(in), dimension(:,:), allocatable :: kernel real(kind=xp), intent(in) :: lambda_amp real(kind=xp), intent(in) :: lambda_mu real(kind=xp), intent(in) :: lambda_sig real(kind=xp), intent(in), dimension(:,:), allocatable :: std_map","tags":"","loc":"module/mod_optimize.html","title":"mod_optimize – ROHSA"},{"text":"This module read the input user parameters (parameters.txt file / data / noise if true) Uses mod_constants module~~mod_read~~UsesGraph module~mod_read mod_read module~mod_constants mod_constants module~mod_read->module~mod_constants iso_fortran_env iso_fortran_env module~mod_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_read~~UsedByGraph module~mod_read mod_read program~rohsa ROHSA program~rohsa->module~mod_read Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines read_parameters read_cube read_map Subroutines public subroutine read_parameters (filename_parameters, filename, fileout, filename_noise, n_gauss, lambda_amp, lambda_mu, lambda_sig, maxiter_init, maxiter, m, noise, regul, lstd, ustd, iprint, iprint_init) Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: filename_parameters character(len=512), intent(inout) :: filename character(len=512), intent(inout) :: fileout character(len=512), intent(inout) :: filename_noise integer, intent(inout) :: n_gauss real(kind=xp), intent(inout) :: lambda_amp real(kind=xp), intent(inout) :: lambda_mu real(kind=xp), intent(inout) :: lambda_sig integer, intent(inout) :: maxiter_init integer, intent(inout) :: maxiter integer, intent(inout) :: m logical, intent(inout) :: noise logical, intent(inout) :: regul integer, intent(inout) :: lstd integer, intent(inout) :: ustd integer, intent(inout) :: iprint integer, intent(inout) :: iprint_init public subroutine read_cube (filename, cube) Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: filename real(kind=xp), intent(inout), dimension(:,:,:), allocatable :: cube public subroutine read_map (filename, map) Arguments Type Intent Optional Attributes Name character(len=512), intent(in) :: filename real(kind=xp), intent(inout), dimension(:,:), allocatable :: map","tags":"","loc":"module/mod_read.html","title":"mod_read – ROHSA"},{"text":"Header/ender call module Used by module~~mod_start~~UsedByGraph module~mod_start mod_start program~rohsa ROHSA program~rohsa->module~mod_start Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines header ender timestamp Subroutines public subroutine header () Arguments None public subroutine ender () Arguments None private subroutine timestamp () TIMESTAMP prints the current YMDHMS date as a time stamp. Arguments None","tags":"","loc":"module/mod_start.html","title":"mod_start – ROHSA"},{"text":"Uses mod_constants mod_read mod_array mod_functions mod_start mod_optimize program~~rohsa~~UsesGraph program~rohsa ROHSA module~mod_functions mod_functions program~rohsa->module~mod_functions module~mod_array mod_array program~rohsa->module~mod_array module~mod_start mod_start program~rohsa->module~mod_start module~mod_optimize mod_optimize program~rohsa->module~mod_optimize module~mod_constants mod_constants program~rohsa->module~mod_constants module~mod_read mod_read program~rohsa->module~mod_read module~mod_functions->module~mod_array module~mod_functions->module~mod_optimize module~mod_functions->module~mod_constants module~mod_array->module~mod_constants module~mod_optimize->module~mod_array module~mod_optimize->module~mod_constants iso_fortran_env iso_fortran_env module~mod_constants->iso_fortran_env module~mod_read->module~mod_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~rohsa~~CallsGraph program~rohsa ROHSA proc~mean_array mean_array program~rohsa->proc~mean_array proc~dim2nside dim2nside program~rohsa->proc~dim2nside proc~read_map read_map program~rohsa->proc~read_map proc~read_parameters read_parameters program~rohsa->proc~read_parameters proc~go_up_level go_up_level program~rohsa->proc~go_up_level proc~set_stdmap set_stdmap program~rohsa->proc~set_stdmap proc~header header program~rohsa->proc~header proc~dim_data2dim_cube dim_data2dim_cube program~rohsa->proc~dim_data2dim_cube proc~ender ender program~rohsa->proc~ender proc~read_cube read_cube program~rohsa->proc~read_cube proc~reshape_up reshape_up program~rohsa->proc~reshape_up proc~mean_map mean_map program~rohsa->proc~mean_map proc~std std proc~set_stdmap->proc~std proc~timestamp timestamp proc~header->proc~timestamp proc~ender->proc~timestamp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables data cube cube_mean fit_params grid_params std_map std_cube dim_data dim_cube kernel ios i j k noise regul nside n power n_gauss m lstd ustd iprint iprint_init maxiter maxiter_init lambda_amp lambda_mu lambda_sig filename_parameters filename fileout filename_noise Source Code ROHSA Variables Type Attributes Name Initial real(kind=xp), dimension(:,:,:), allocatable :: data initial fits data real(kind=xp), dimension(:,:,:), allocatable :: cube reshape data with nside --> cube real(kind=xp), dimension(:,:,:), allocatable :: cube_mean mean cube over spatial axis real(kind=xp), dimension(:,:,:), allocatable :: fit_params parameters to optimize with cube mean at each iteration real(kind=xp), dimension(:,:,:), allocatable :: grid_params parameters to optimize at final step (dim of initial cube) real(kind=xp), dimension(:,:), allocatable :: std_map standard deviation map fo the cube computed by ROHSA with lb and ub real(kind=xp), dimension(:,:), allocatable :: std_cube standard deviation map fo the cube is given by the user integer, dimension(3) :: dim_data dimension of original data integer, dimension(3) :: dim_cube dimension of reshape cube real(kind=xp), dimension(:,:), allocatable :: kernel convolution kernel integer :: ios = 0 ios integer integer :: i loop index integer :: j loop index integer :: k loop index logical :: noise if false --> STD map computed by ROHSA with lstd and ustd (if true given by the user) logical :: regul if true --> activate regulation integer :: nside size of the reshaped data 2&#94;{nside} integer :: n loop index integer :: power loop index integer :: n_gauss number of gaussian to fit integer :: m number of corrections used in the limited memory matrix by LBFGS-B integer :: lstd lower bound to compute the standard deviation map of the cube (if noise .eq. false) integer :: ustd upper bound to compute the standrad deviation map of the cube (if noise .eq. false) integer :: iprint print option integer :: iprint_init print option init integer :: maxiter max iteration for L-BFGS-B alogorithm integer :: maxiter_init max iteration for L-BFGS-B alogorithm (init mean spectrum) real(kind=xp) :: lambda_amp lambda for amplitude parameter real(kind=xp) :: lambda_mu lamnda for mean position parameter real(kind=xp) :: lambda_sig lambda for dispersion parameter character(len=512) :: filename_parameters name of the parameters file (default parameters.txt) character(len=512) :: filename name of the data file character(len=512) :: fileout name of the output result character(len=512) :: filename_noise name of the file with STD map (if noise .eq. true) Source Code program ROHSA use mod_constants use mod_read use mod_array use mod_functions use mod_start use mod_optimize implicit none real ( xp ), dimension (:,:,:), allocatable :: data !! initial fits data real ( xp ), dimension (:,:,:), allocatable :: cube !! reshape data with nside --> cube real ( xp ), dimension (:,:,:), allocatable :: cube_mean !! mean cube over spatial axis real ( xp ), dimension (:,:,:), allocatable :: fit_params !! parameters to optimize with cube mean at each iteration real ( xp ), dimension (:,:,:), allocatable :: grid_params !! parameters to optimize at final step (dim of initial cube) real ( xp ), dimension (:,:), allocatable :: std_map !! standard deviation map fo the cube computed by ROHSA with lb and ub real ( xp ), dimension (:,:), allocatable :: std_cube !! standard deviation map fo the cube is given by the user integer , dimension ( 3 ) :: dim_data !! dimension of original data integer , dimension ( 3 ) :: dim_cube !! dimension of reshape cube real ( xp ), dimension (:,:), allocatable :: kernel !! convolution kernel integer :: ios = 0 !! ios integer integer :: i !! loop index integer :: j !! loop index integer :: k !! loop index logical :: noise !! if false --> STD map computed by ROHSA with lstd and ustd (if true given by the user) logical :: regul !! if true --> activate regulation integer :: nside !! size of the reshaped data 2&#94;{nside} integer :: n !! loop index integer :: power !! loop index integer :: n_gauss !! number of gaussian to fit integer :: m !! number of corrections used in the limited memory matrix by LBFGS-B integer :: lstd !! lower bound to compute the standard deviation map of the cube (if noise .eq. false) integer :: ustd !! upper bound to compute the standrad deviation map of the cube (if noise .eq. false) integer :: iprint !! print option integer :: iprint_init !! print option init integer :: maxiter !! max iteration for L-BFGS-B alogorithm integer :: maxiter_init !! max iteration for L-BFGS-B alogorithm (init mean spectrum) real ( xp ) :: lambda_amp !! lambda for amplitude parameter real ( xp ) :: lambda_mu !! lamnda for mean position parameter real ( xp ) :: lambda_sig !! lambda for dispersion parameter character ( len = 512 ) :: filename_parameters !! name of the parameters file (default parameters.txt) character ( len = 512 ) :: filename !! name of the data file character ( len = 512 ) :: fileout !! name of the output result character ( len = 512 ) :: filename_noise !! name of the file with STD map (if noise .eq. true) !Print header and get filename in argument call header () call get_command_argument ( 1 , filename_parameters ) print * , \"\" !Default user parameters n_gauss = 3 lambda_amp = 1._xp lambda_mu = 1._xp lambda_sig = 1._xp maxiter_init = 15000 maxiter = 800 m = 10 noise = . false . regul = . true . lstd = 0 ; ustd = 20 iprint = - 1 iprint_init = - 1 call read_parameters ( filename_parameters , filename , fileout , filename_noise , n_gauss , lambda_amp , lambda_mu , lambda_sig , & maxiter_init , maxiter , m , noise , regul , lstd , ustd , iprint , iprint_init ) print * , \"filename = '\" , trim ( filename ), \"'\" print * , \"fileout = '\" , trim ( fileout ), \"'\" print * , print * , \"______Parameters_____\" print * , print * , \"n_gauss = \" , n_gauss print * , \"lambda_amp = \" , lambda_amp print * , \"lambda_mu = \" , lambda_mu print * , \"lambda_sig = \" , lambda_sig print * , \"maxiter_itit = \" , maxiter_init print * , \"maxiter = \" , maxiter print * , \"lstd = \" , lstd print * , \"ustd = \" , ustd print * , \"noise = \" , noise print * , \"regul = \" , regul print * , allocate ( kernel ( 3 , 3 )) kernel ( 1 , 1 ) = 0._xp kernel ( 1 , 2 ) = - 0.25_xp kernel ( 1 , 3 ) = 0._xp kernel ( 2 , 1 ) = - 0.25_xp kernel ( 2 , 2 ) = 1._xp kernel ( 2 , 3 ) = - 0.25_xp kernel ( 3 , 1 ) = 0._xp kernel ( 3 , 2 ) = - 0.25_xp kernel ( 3 , 3 ) = 0._xp !Load data call read_cube ( filename , data ) if ( noise . eqv . . true .) then if ( filename_noise == \" \" ) then print * , \"--> noise = .true. (no input rms map)\" end if call read_map ( filename_noise , std_cube ) end if write ( * , * ) \"\" write ( * , * ) \"opening file and reading data\" dim_data = shape ( data ) write ( * , * ) \"dim_v, dim_y, dim_x = \" , dim_data write ( * , * ) \"\" write ( * , * ) \"number of los = \" , dim_data ( 2 ) * dim_data ( 3 ) nside = dim2nside ( dim_data ) write ( * , * ) \"nside = \" , nside call dim_data2dim_cube ( nside , dim_data , dim_cube ) !Allocate moemory for cube allocate ( cube ( dim_cube ( 1 ), dim_cube ( 2 ), dim_cube ( 3 ))) !Reshape the data (new cube of size nside) print * , write ( * , * ) \"Reshape cube, new dimensions :\" write ( * , * ) \"dim_v, dim_y, dim_x = \" , dim_cube print * , call reshape_up ( data , cube , dim_data , dim_cube ) !Allocate memory for fit_params array allocate ( fit_params ( 3 * n_gauss , 1 , 1 )) print * , \"                    Start iteration\" print * , !Start iteration do n = 0 , nside power = 2 ** n allocate ( cube_mean ( dim_cube ( 1 ), power , power )) call mean_array ( power , cube , cube_mean ) if ( n == 0 ) then print * , \"Init mean spectrum\" call init_spectrum ( n_gauss , fit_params (:, 1 , 1 ), dim_cube ( 1 ), cube_mean (:, 1 , 1 ), maxiter_init , m , iprint_init ) end if call go_up_level ( fit_params ) write ( * , * ) \"\" write ( * , * ) \"Update parameters level \" , n , \">\" , power if ( regul . eqv . . false .) then call upgrade ( cube_mean , fit_params , power , n_gauss , dim_cube ( 1 ), maxiter , m , iprint ) end if if ( regul . eqv . . true .) then if ( n == 0 ) then call upgrade ( cube_mean , fit_params , power , n_gauss , dim_cube ( 1 ), maxiter , m , iprint ) end if if ( n > 0 . and . n < nside ) then allocate ( std_map ( power , power )) if ( noise . eqv . . true .) then call mean_map ( power , std_cube , std_map ) else call set_stdmap ( std_map , cube_mean , lstd , ustd ) end if call update ( cube_mean , fit_params , n_gauss , dim_cube ( 1 ), power , power , lambda_amp , lambda_mu , lambda_sig , & maxiter , m , kernel , iprint , std_map ) deallocate ( std_map ) end if end if deallocate ( cube_mean ) enddo print * , write ( * , * ) \"Reshape cube, restore initial dimensions :\" write ( * , * ) \"dim_v, dim_y, dim_x = \" , dim_data allocate ( grid_params ( 3 * n_gauss , dim_data ( 2 ), dim_data ( 3 ))) call reshape_down ( fit_params , grid_params , ( / 3 * n_gauss , dim_cube ( 2 ), dim_cube ( 3 ) / ), ( / 3 * n_gauss , dim_data ( 2 ), dim_data ( 3 ) / )) print * , print * , \"Update last level ...\" print * , allocate ( std_map ( dim_data ( 2 ), dim_data ( 3 ))) if ( noise . eqv . . true .) then std_map = std_cube else call set_stdmap ( std_map , data , lstd , ustd ) end if if ( regul . eqv . . true .) then call update ( data , grid_params , n_gauss , dim_data ( 1 ), dim_data ( 2 ), dim_data ( 3 ), lambda_amp , lambda_mu , lambda_sig , & maxiter , m , kernel , iprint , std_map ) end if print * , print * , \"_____ Write output file _____\" print * , ! Open file open ( unit = 12 , file = fileout , action = \"write\" , iostat = ios ) if ( ios /= 0 ) stop \"opening file error\" ! Read cube dimension and compute the number of line write ( 12 , fmt =* ) \"# \" write ( 12 , fmt =* ) \"# ______Parameters_____\" write ( 12 , fmt =* ) \"# \" write ( 12 , fmt =* ) \"# n_gauss = \" , n_gauss write ( 12 , fmt =* ) \"# lambda_amp = \" , lambda_amp write ( 12 , fmt =* ) \"# lambda_mu = \" , lambda_mu write ( 12 , fmt =* ) \"# lambda_sig = \" , lambda_sig write ( 12 , fmt =* ) \"# maxiter_itit = \" , maxiter_init write ( 12 , fmt =* ) \"# maxiter = \" , maxiter write ( 12 , fmt =* ) \"# lstd = \" , lstd write ( 12 , fmt =* ) \"# ustd = \" , ustd write ( 12 , fmt =* ) \"# noise = \" , noise write ( 12 , fmt =* ) \"# regul = \" , regul write ( 12 , fmt =* ) \"# \" write ( 12 , fmt =* ) \"# i, j, A, mean, sigma\" do i = 1 , dim_data ( 2 ) do j = 1 , dim_data ( 3 ) do k = 1 , n_gauss write ( 12 , fmt =* ) i - 1 , j - 1 , grid_params ( 1 + (( k - 1 ) * 3 ), i , j ), grid_params ( 2 + (( k - 1 ) * 3 ), i , j ), grid_params ( 3 + (( k - 1 ) * 3 ), i , j ) enddo enddo enddo close ( 12 ) call ender () end program ROHSA","tags":"","loc":"program/rohsa.html","title":"ROHSA – ROHSA"},{"text":"User Guide","tags":"","loc":"page//index.html","title":"User Guide – ROHSA"},{"text":"Getting Started 1. Installation 2. Running ROHSA","tags":"","loc":"page/01_getting_started/index.html","title":"Getting Started – ROHSA"},{"text":"Installing ROHSA Dependencies ROHSA has the following dependencies: Make for building FIDASIM. (Required) Fortran (Required) git for version control (Optional) Ford for creating HTML documentation (Optional) Download the code source The last version of ROHSA (1.1.0) can be downloaded from here Once you have downloaded the .tar.gz or .zip file unpack it using the following commands. tar -zxf ROHSA-1.1.0.tar.gz or if you downloaded the .zip file unzip ROHSA-1.1.0.zip Get the git repository You can also use git if you want to follow the developement of the code git clone https://github.com/antoinemarchal/ROHSA.git ROHSA Building ROHSA Once you are in the src/ directory you are now able to build the code running the following cd ROHSA/src/ make You can now check if ROHSA is bluit correctly ( marchalenv ) Antoines-MacBook-Pro:src antoinemarchal$ ./ROHSA \n ------------------------------------------------------------------------- 16 April 2018 11 :08:50.786 AM\n\n   ____     ___    _   _   ____       _ | _ \\ / _ \\ | | | | / ___ | / \\ | | _ ) | | | | | | | _ | | \\_ __ \\ / _ \\ | _ < | | _ | | | _ | ___ ) | / ___ \\ | _ | \\_\\ \\_ __/ | _ | | _ | | ____/  /_/ \\_\\ Version 1 .1.0\n  ROHSA is released as open source code\n  Check out the documentation: https://antoinemarchal.github.io/ROHSA/\n\n run: ./ROHSA parameters.txt\n -------------------------------------------------------------------------\n\nSTOP opening file error","tags":"","loc":"page/01_getting_started/install.html","title":"Installation – ROHSA"},{"text":"Running ROHSA User Parameters Input file Once the source code is compiled, you can run ROHSA using the parameters.txt file. & user_parameters filename = '' !! name of the data file\n   ,fileout = '' !! name of the output result\n   ,filename_noise = '' !! name of the file with STD map ( if noise .eq. true ) ,n_gauss = 8 !! number of gaussian to fit\n   ,lambda_amp = 1 .d0    !! lambda for amplitude parameter\n   ,lambda_mu = 1 .d0     !! lamnda for mean position parameter\n   ,lambda_sig = 1 .d0    !! lambda for dispersion parameter\n   ,maxiter_init = 15000 !! max iteration for L-BFGS-B alogorithm ( init mean spectrum ) ,maxiter = 800 !! max iteration for L-BFGS-B alogorithm\n   ,m = 10 !! number of corrections used in the limited memory matrix by LBFGS-B\n   ,noise = .false.      !! if false --> STD map computed by ROHSA with lstd and ustd ( if true given by the user ) ,regul = .true.       !! if true --> activate regulation\n   ,lstd = 160 !! lower bound to compute the standard deviation map of the cube ( if noise .eq. false ) ,ustd = 198 !! upper bound to compute the standrad deviation map of the cube ( if noise .eq. false ) ,iprint = -1          !! print option\n   ,iprint_init = -1     !! print option init\n   / parameters.txt contains all the free parameters of ROHSA. Warning If one of the parameters if missing, ROHSA wil take the default value encoded in the main.f90 source file. Print option (L-BFGS-B argument) iprint is an INTEGER variable that must be set by the user. It controls the frequency and type of output generated: iprint< 0 no output is generated ; iprint = 0 print only one line at the last iteration ; 0 <iprint< 99 print also f and | proj g | every iprint iterations ; iprint = 99 print details of every iteration except n-vectors ; iprint = 100 print also the changes of active set and final x ; iprint>100  print details of every iteration including x and g ; When iprint > 0 , the file iterate.dat will be created to summarize the iteration. Note For any question about the parameters, please contact us at the following address : antoine.marchal@ias.u-psud.fr Data format ROHSA does not support FITS file in version 1.1.0. It wiil be added in a next release. \nYou can find a python code : fits2dat.py in src/ directory to convert your .fits file into a .dat file. Running ROHSA You can now run your Gaussian decomposition with ROHSA. Enjoy ! ./ROHSA parameters.txt ( Clumpix ) amarchal@glx-calcul3:~/ROHSA/src$ ./ROHSA parameters.txt \n ------------------------------------------------------------------------- 17 April 2018 9 :45:45.824 AM\n\n   ____     ___    _   _   ____       _ | _ \\ / _ \\ | | | | / ___ | / \\ | | _ ) | | | | | | | _ | | \\_ __ \\ / _ \\ | _ < | | _ | | | _ | ___ ) | / ___ \\ | _ | \\_\\ \\_ __/ | _ | | _ | | ____/  /_/ \\_\\ Version 1 .1.0\n  ROHSA is released as open source code\n  Check out the documentation: https://antoinemarchal.github.io/ROHSA/\n\n run: ./ROHSA parameters.txt\n ------------------------------------------------------------------------- filename = './data.dat' fileout = './result.dat' ______Parameters_____ n_gauss = 8 lambda_amp = 1 .0000000000000000 lambda_mu = 1 .0000000000000000 lambda_sig = 1 .0000000000000000 maxiter_itit = 15000 maxiter = 800 lstd = 160 ustd = 198 noise = F regul = T\n\n\n opening file and reading data\n dim_v, dim_y, dim_x = 395 94 67 number of los = 6298 nside = 7 Reshape cube, new dimensions :\n dim_v, dim_y, dim_x = 395 128 128 Start iteration\n\n Init mean spectrum\n\n Update parameters level 0 > 1 RUNNING THE L-BFGS-B CODE\n\n           * * *\n\nMachine precision = 2 .220D-16 N = 24 M = 10 At X0 3 variables are exactly at the bounds\n\nAt iterate 0 f = 1 .29989D-02 | proj g | = 4 .42658D-05\n\nAt iterate 1 f = 1 .29989D-02 | proj g | = 6 .62203D-05\n\n...","tags":"","loc":"page/01_getting_started/running.html","title":"Running ROHSA – ROHSA"},{"text":"Model The two dimensional vector expressing the line of sight is denoted by (l, b) . Lets start with a non linear least square formulation of the optimization problem. \nWe have p empirical pairs (x_u&#94;{l,b}, y_u&#94;{l,b}) and we want to find the parameters \\mathbf{\\beta} of the model curve G(\\mathbf{\\beta}) so that the sum of the squares of deviations f(\\mathbf{\\beta}) is minimized. \\begin{align}\n  \\hat{\\mathbf{\\beta}} = \\underset{\\beta}{argmin} \\, f(\\mathbf{\\beta})\n\\end{align} Let's define the model G as a sum of Gaussian characterized by three parameters, i.e. amplitude A : \\, q = 3k+1 , \nposition \\mu : \\, q = 3k+2 and dispersion \\sigma : \\, q = 3k+3 with k \\in \\left\\{ 0, ..., N \\right\\} \\begin{align}\n  G(x_u&#94;{l,b}, \\mathbf{\\beta_q&#94;{l,b}}) = \\sum_{k=1}&#94;{N} \\left ( \\beta_{3k}&#94;{l,b} \\, exp \\left \\{  \\frac{- \\, (x_u&#94;{l,b} \\, - \\,\n    \\beta_{3k+1}&#94;{l,b})&#94;2}{2 (\\beta_{3k+2}&#94;{l,b})&#94;2}\n    \\right\\} \\right)\n\\end{align} We define the residual function F of each pairs (x_u&#94;{l,b}, y_u&#94;{l,b}) : \\begin{align}\n  F(x_u&#94;{l,b}, y_u&#94;{l,b}, \\mathbf{\\beta&#94;{l,b}}) = G(x_u&#94;{l,b}, \\mathbf{\\beta&#94;{l,b}}) \\, - \\, y_u&#94;{l,b}\n\\end{align} For a non linear least square formulation, the objective function f is : \\begin{align}\n  f(\\mathbf{\\beta}) = \\frac{1}{2} \\, \\sum_{l=1}&#94;L \\, \\sum_{b=1}&#94;B \\left [ \\sum_{u=1}&#94;{U} \\, F&#94;2(x_u&#94;{l,b}, y_u&#94;{l,b}, \\mathbf{\\beta&#94;{l,b}}) \\right ]\n  \\, + \\, \\underbrace{\\sum_{q=1}&#94;{3n} \\, \\lambda_q \\, R_q(\\mathbf{\\beta_q})}_{regularization}\n\\end{align} Note that we add a regularization term in order to minimize f(\\mathbf{\\beta_q}) considering spatial constraints. If we regularize over 4 neighbors R_q(\\mathbf{\\beta}) is equal to, \\begin{align}\n  R_q(\\mathbf{\\beta_q}) = \\frac{1}{2} \\, \\sum_{l=1}&#94;L \\, \\sum_{b=1}&#94;B \\left[ Y_q&#94;{l,b} \\right]&#94;2\n\\end{align} with \\begin{align}\n    Y_q&#94;{l,b} = \\frac{1}{4} \\, \\left ( 4 \\, \\beta_q&#94;{l,b} \\, - \\,\n    \\beta_q&#94;{l+1,b} \\, - \\, \\beta_q&#94;{l,b+1} \\, - \\, \\beta_q&#94;{l,b-1} \\, - \\, \\beta_q&#94;{l-1,b} \\right ) \n\\end{align} In order to consider the boundary of the cube, we use a mirror conditions. Furthermore, it is convenient to express R_q(\\mathbf{\\beta_q}) as a convolution product : \\begin{align}\n  \\mathbf{Y_q} = \\mathbf{K} \\, * \\, \\mathbf{\\beta_q}\n\\end{align} \\noindent\nwith the kernel \\textbf{K} , \\begin{align}\n  \\mathbf{K} =\n  \\left[\n  \\begin{array}{ccc}\n    0 & -1 & 0 \\\\\n    -1 & 4 & -1 \\\\\n    0 & -1 & 0 \\\\\n  \\end{array}\n  \\right] \\, / \\, 4\n\\end{align} The gradient of the objective function that we need to use the optimization algorithm of our choice is then : \\begin{align}\n  \\nabla f(\\mathbf{\\beta}) &= \\frac{\\partial f(\\mathbf{\\beta})}{\\partial \\beta_q&#94;{l,b}} \n  &= \\sum_{u=1}&#94;U \\, \\frac{\\partial F_u&#94;{l,b}}{\\partial \\beta_q&#94;{l,b}} \\, \\times \\,\n  F_u&#94;{l,b} \\, + \\, \\lambda_q \\, \\frac{\\partial}{\\partial \\beta_q&#94;{l,b}} \\left[ \\frac{1}{2} \\, \\sum_{l=1}&#94;L \\, \\sum_{b=1}&#94;B \\left[ Y_q&#94;{l,b} \\right]&#94;2\n    \\right]\n\\end{align} Finally, the gradient of the objective function can be written as follows : \\begin{align}\n  \\nabla f(\\mathbf{\\beta}) = \\frac{\\partial f(\\mathbf{\\beta})}{\\partial \\beta_q&#94;{l,b}} = \\sum_{u=1}&#94;U \\, \\frac{\\partial F_u&#94;{l,b}}{\\partial \\beta_q&#94;{l,b}} \\, \\times \\,\n  F_u&#94;{l,b} \\, + \\, \\lambda_q \\, Z_q&#94;{l,b}\n\\end{align} with, \\begin{align}\n    \\mathbf{Z_q} = \\mathbf{K} \\, * \\, \\mathbf{Y_q}\n\\end{align}","tags":"","loc":"page/02_model/index.html","title":"Model – ROHSA"},{"text":"Algorithm ROHSA algorithm To initiate the model parameters, we chose a hierarchical approach. Since the fluctuation along the velocity axis \nare weak from one spectrum to its neighbors, it is possible to go from the highest resolution (initial resolution) \nto the lowest resolution (mean spectrum of the observation) averaging at each step, along the velocity axis, over four neighbors. \nStarting now from the lower one, we adopt the following algorithm : we optimize N Gaussian on the single mean spectrum. \nThen we propagate the solution as initialization of the optimization at the next level which contains four spectra. \nWe repeat the process until we reach the highest resolution, i.e. the initial one. Figure 1 and Algorithm 1 shows a graphic \nvisualization and the pseudo-code of the algo- rithm. It is important to maintain the regularization at each step of \nthe descent to link the amplitude, the position and the dispersion of each Gaussian over the two spatial dimensions. Optimization algorithm We used a quasi-Newton method, the L-BFGS-B (Limited-memory Broyden–Fletcher–Goldfarb–Shanno with Bounds) \nalgorithm (see Zhu et al. 1997 to perform the optimization. \nL-BFGS-B uses an estimation to the inverse Hessian matrix H (the second derivative of f(β)) to identify the direction \nof steepest descent and to update the input parameters at each iteration. \nIf the problem has n parameters to optimize, H takes nxn values in memory. \nL-BFGS-B allows us to estimate H storing considerably \nless variables. Since we are already locked by the huge amount of data, we want to minimize the allocated memory in order to \ncompute the larger field we can. Finally, since we want the positivity of each amplitude of the Gaussian, \nwe used L-BFGS-B to support boundary conditions.","tags":"","loc":"page/03_algorithm/index.html","title":"Algorithm – ROHSA"}]}